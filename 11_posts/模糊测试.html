<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>模糊测试 | MatrweのBlog</title><meta name="author" content="Matrwe"><meta name="copyright" content="Matrwe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="模糊测试">
<meta property="og:type" content="website">
<meta property="og:title" content="模糊测试">
<meta property="og:url" content="https://imatrwe.github.io/11_posts/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95.html">
<meta property="og:site_name" content="MatrweのBlog">
<meta property="og:description" content="模糊测试">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410282058501.png">
<meta property="article:published_time" content="2024-10-28T13:23:51.145Z">
<meta property="article:modified_time" content="2024-10-28T12:58:58.739Z">
<meta property="article:author" content="Matrwe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410282058501.png"><link rel="shortcut icon" href="/img/avatar.png"><link rel="canonical" href="https://imatrwe.github.io/11_posts/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '模糊测试',
  isPost: false,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-10-28 20:58:58'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">0</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-home-page" id="page-header" style="background-image: url(/img/top.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">MatrweのBlog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="page-site-info"><h1 id="site-title">模糊测试</h1></div></header><main class="layout" id="content-inner"><div id="page"><div id="article-container"><h1 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h1><p><strong>模糊测试</strong>又称为fuzzing，是一种软件测试技术。其核心概念为<strong>自动</strong>产生<strong>随机输入</strong>到一个程序中，并监视程序异常，如崩溃、断言失败，以发现可能的程序错误。</p>
<p>fuzzing流程大致可以拆成三个组件分别为：</p>
<p>1.种子选择、2.突变、3.覆盖范围。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281003948.png" alt="img"></p>
<p>模糊器的好坏，通常是：</p>
<ol>
<li><strong>种子选择</strong>是否能挑出真正有意义的种子</li>
<li><strong>变异</strong>的随机是否有效率</li>
<li><strong>覆盖</strong>实现的方式是否会造成大量的开销。</li>
</ol>
<h2 id="插桩（instrumentation）"><a href="#插桩（instrumentation）" class="headerlink" title="插桩（instrumentation）"></a>插桩（instrumentation）</h2><p>在保证原程序逻辑的完整性下，在程序中插入一些程序码来采集运行期间的执行状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int test_var = 0;</span><br><span class="line"></span><br><span class="line">// original (1)</span><br><span class="line">void b() &#123; ...; &#125;</span><br><span class="line">void a() &#123; ...; &#125;</span><br><span class="line"></span><br><span class="line">// instrumented (2)</span><br><span class="line">void b() &#123; printf(&quot;test_var: %d\n&quot;, test_var); ...; &#125;</span><br><span class="line">void a() &#123; printf(&quot;test_var: %d\n&quot;, test_var); ...; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol>
<li>插桩的对象通常都具有相同的属性或类别涉及所有的功能、所有的<strong>基本块</strong>，比较少针对单一目标。</li>
<li>插桩的程序代码通常只有几行汇编代码，并且不会做太复杂的操作</li>
<li>在<strong>模糊器</strong>中，插桩被用来进行<strong>覆盖</strong>，那么记录多少程序码被执行到。</li>
</ol>
<h1 id="AFL"><a href="#AFL" class="headerlink" title="AFL"></a>AFL</h1><p>以下是一些比较有名的开源模糊测试工具：</p>
<ol>
<li><strong>American Fuzzy Lop (AFL)</strong>: AFL 是一个高效的模糊测试工具</li>
<li><strong>libFuzzer</strong>: libFuzzer 是 LLVM&#x2F;Clang 提供的一个模糊测试引擎，它可以轻松地集成到现有的代码中</li>
<li><strong>Syzkaller</strong>: Syzkaller 是一个专注于系统调用接口的模糊测试工具，它可以自动生成各种系统调用序列，并对内核进行测试以发现漏洞和错误。</li>
<li><strong>OSS-Fuzz</strong>: OSS-Fuzz旨在通过自动化模糊测试发现开源软件中的安全漏洞和错误。</li>
</ol>
<h2 id="FUZZ方式"><a href="#FUZZ方式" class="headerlink" title="FUZZ方式"></a>FUZZ方式</h2><p>AFL有两种fuzz途径：</p>
<ol>
<li>开源软件：AFL软件进行编译的同时进行插桩，以方便fuzz</li>
<li>闭源软件：配合QEMU直接对闭源的二进制代码进行fuzz</li>
</ol>
<h2 id="AFL-安装"><a href="#AFL-安装" class="headerlink" title="AFL++安装"></a>AFL++安装</h2><h4 id="Linux包管理-deb-："><a href="#Linux包管理-deb-：" class="headerlink" title="Linux包管理(deb)："></a>Linux包管理(deb)：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install afl++</span><br></pre></td></tr></table></figure>

<h4 id="源码编译安装-："><a href="#源码编译安装-：" class="headerlink" title="源码编译安装 ："></a>源码编译安装 ：</h4><p>下载源码自行编译：(推荐安装AFL++，AFl的话如果开ASAN可能有问题)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AFLplusplus/AFLplusplus.git</span><br><span class="line">cd AFLplusplus</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="afl-gcc"><a href="#afl-gcc" class="headerlink" title="afl-gcc"></a>afl-gcc</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> AFL_USE_ASAN=1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">afl-gcc -fsanitize=address -o <span class="built_in">test</span> test.c</span></span><br></pre></td></tr></table></figure>

<ul>
<li>最后会我们的命令会变成这样</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fsanitize=address -o test test.c -B ~/fuzz/AFLplusplus -g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</span><br></pre></td></tr></table></figure>

<ul>
<li>有趣的是<code>-B ~/fuzz/AFL</code>，gcc 会尝试在这里寻找路径工具链中的<strong>汇编器</strong>来执行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~/fuzz/AFLplusplus/as</span><br><span class="line">lrwxrwxrwx 1 lidaxian lidaxian 6 Mar 29 14:53 as -&gt; afl-as</span><br></pre></td></tr></table></figure>

<h3 id="afl-as"><a href="#afl-as" class="headerlink" title="afl-as"></a>afl-as</h3><ul>
<li>afl-as首先会执行函数<code>add_instrumentation()</code>做插桩，最后执行as做汇编。</li>
<li>做完插桩后会执行调整后的参数来汇编新的asm文件，最后产生的执行文件test即是有插桩的版本，简单用objdump就可以看到许多以__afl为前缀的函数：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objdump -M intel -d test | grep afl</span><br><span class="line">    119d:       e8 1e 02 00 00          call   13c0 &lt;__afl_maybe_log&gt;</span><br><span class="line">    120d:       e8 ae 01 00 00          call   13c0 &lt;__afl_maybe_log&gt;</span><br><span class="line">    1255:       e8 66 01 00 00          call   13c0 &lt;__afl_maybe_log&gt;</span><br><span class="line">    12a1:       e8 1a 01 00 00          call   13c0 &lt;__afl_maybe_log&gt;</span><br></pre></td></tr></table></figure>

<h3 id="afl-fuzz"><a href="#afl-fuzz" class="headerlink" title="afl-fuzz"></a>afl-fuzz</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i seed-dir -o out-dir -m none ./test</span><br></pre></td></tr></table></figure>

<ul>
<li>-i - 存放测试用例的资料夹</li>
<li>-o - 搁置执行结果资料夹</li>
<li>-f - 从指定文件读取输入</li>
<li>-t - timeout，执行时间超过的话就会被kill掉</li>
<li>-m - 内存限制，执行时所能使用的内存体上限</li>
<li>-d - 跳过确定性，突变阶段跳过最初的处理</li>
<li>-n - 对没有插桩的目标进行模糊测试</li>
</ul>
<h3 id="Crash分析"><a href="#Crash分析" class="headerlink" title="Crash分析"></a>Crash分析</h3><p>out-dir&#x2F;crashes目录下的内容是引发崩溃的输入</p>
<h3 id="Sanitizer"><a href="#Sanitizer" class="headerlink" title="Sanitizer"></a>Sanitizer</h3><p>即使程序存在漏洞，也不一定会在执行到有漏洞的程式码时触发异常</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char buf[100];</span><br><span class="line">scanf(&quot;%d&quot;, &amp;idx);</span><br><span class="line">buf[idx] = &#x27;\0&#x27;; // (1)</span><br></pre></td></tr></table></figure>

<p>然而即便会有out-of-bound write 的漏洞发生，但如果<code>buf[101]</code>对应到的地址正好没被使用到，那么fuzzer也不会感兴趣</p>
<p>常见的Sanitizer有：</p>
<ol>
<li><strong>AddressSanitizer</strong> (+LeakSanitizer)</li>
<li>ThreadSanitizer</li>
<li>UndefinedBehaviorSanitizer</li>
<li>MemorySanitizer</li>
</ol>
<h4 id="AddressSanitizer原理简介"><a href="#AddressSanitizer原理简介" class="headerlink" title="AddressSanitizer原理简介"></a>AddressSanitizer原理简介</h4><p>这个内存检查是如何工作的？</p>
<p>左侧，蓝色区域是我们分配的内存在右侧</p>
<p>右侧，<code>Redzones</code>是中毒的内存</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281014574.png" alt="图片20200816120042864"></p>
<p>如果通过启用Address Sanitizer来编译可执行文件，则每次访问内存之前，都会有前缀指令来检查该内存是否为<code>poisoned</code>.如果是，Address Sanitizer 将生成如上所示的诊断报告。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281014091.png" alt="图片20200816120700174"></p>
<p>下图显示该进程正在尝试访问中毒内存，并触发<code>Crash</code>并生成诊断报告。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281015868.png" alt="图片20200816120921377"></p>
<h5 id="堆对象分配"><a href="#堆对象分配" class="headerlink" title="堆对象分配"></a>堆对象分配</h5><p>Address Sanitizer通过使用它自己的分配实现来替换默认的 Malloc 实现，该实现将对象彼此分开</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281015436.png" alt="图片20200816123141896"></p>
<h5 id="堆栈变量"><a href="#堆栈变量" class="headerlink" title="堆栈变量"></a>堆栈变量</h5><p>在两个堆栈变量之间插入一些红色区域，因此堆栈红色区域在运行时中毒</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281015705.png" alt="图片20200816150456865"></p>
<h5 id="额外的开销"><a href="#额外的开销" class="headerlink" title="额外的开销"></a>额外的开销</h5><ul>
<li>CPU 减速通常在 2 倍到 5 倍之间 正常情况下，CPU 速度减慢 2 倍至 3 倍。在某些极端情况下，他们的速度下降了 5 倍。</li>
<li>内存开销 2x–3x</li>
<li>AddressSanitizer 使用比本机运行更多的实际内存。确切的开销取决于分配大小。分配越小，开销就越大。</li>
<li>AddressSanitizer 使用更多的堆栈内存。我们看到增长高达 3 倍。</li>
</ul>
<h1 id="实战演示-libpng"><a href="#实战演示-libpng" class="headerlink" title="实战演示-libpng"></a>实战演示-libpng</h1><h2 id="编译fuzz目标"><a href="#编译fuzz目标" class="headerlink" title="编译fuzz目标"></a>编译fuzz目标</h2><p><a target="_blank" rel="noopener" href="https://libpng.sourceforge.io/">libpng</a>是开源的png解析库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://nchc.dl.sourceforge.net/project/libpng/libpng16/1.6.36/libpng-1.6.36.tar.xz</span><br><span class="line">$ tar xvf libpng-1.6.36.tar.xz</span><br><span class="line">$ cd libpng-1.6.36</span><br><span class="line">$ ./autogen.sh </span><br><span class="line">$ CC=afl-clang CXX=afl-g++ ./configure --enable-static</span><br><span class="line">$ make -j4</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>--enable-static</code> ： 用于生成静态库，fuzz开源库时会需要</p>
</blockquote>
<h2 id="准备环境-准备种子"><a href="#准备环境-准备种子" class="headerlink" title="准备环境(准备种子)"></a>准备环境(准备种子)</h2><p>获取官网提供的测试集作为输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir fuzz_in fuzz_out</span><br><span class="line">$ cd fuzz_in</span><br><span class="line">$ wget http://lcamtuf.coredump.cx/afl/demo/afl_testcases.tgz</span><br><span class="line">$ tar xvf afl_testcases.tgz</span><br></pre></td></tr></table></figure>

<h2 id="开始fuzz"><a href="#开始fuzz" class="headerlink" title="开始fuzz"></a>开始fuzz</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -i ../fuzz_in/png/full/images -o ../fuzz_out ../.libs/pngimage @@</span><br></pre></td></tr></table></figure>

<p><code>../fuzz_in/png/full/images</code>为afl测试集</p>
<p><code>../.libs/pngimage</code>是编译出来的被测试程序</p>
<p>@@代表测试输入样本</p>
<h2 id="报错处理-如果安装在系统上时"><a href="#报错处理-如果安装在系统上时" class="headerlink" title="报错处理(如果安装在系统上时)"></a>报错处理(如果安装在系统上时)</h2><p>AFL测试时用到功能需要还没有开启</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">echo core &gt;/proc/sys/kernel/core_pattern</span><br><span class="line">cd /sys/devices/system/cpu</span><br><span class="line">echo performance | tee cpu*/cpufreq/scaling_governor</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>使用AFL在linux上fuzz开源软件十分简单</li>
<li>大多数的lib&#x2F;开源软件的源代码都是可以获取的</li>
<li>在编译时插桩是可行的</li>
<li>在Fuzz时要用ASAN,MSAN,UBSAN</li>
<li>有时最需要花费时间的过程是项目编译<ul>
<li>缺失引用的第三方库（lib）</li>
<li>编译过程中的各种错误</li>
<li>不同项目不同的编译方法与各种选项</li>
</ul>
</li>
</ul>
<h1 id="Day-1-模糊测试概念总览"><a href="#Day-1-模糊测试概念总览" class="headerlink" title="[Day 1] 模糊测试概念总览"></a>[Day 1] 模糊测试概念总览</h1><blockquote>
<p>此系列文的主题为模糊测试，内容包含但不限于其概念、实作以及演进，对象设定在有一定程式基础的人。看完后至少会知道模糊测试怎么运作，如果能完整消化的话，应该就已经具备大部分的模糊测试知识。</p>
</blockquote>
<p>模糊测试又称作fuzzing，是一种<strong>软体测试</strong>技术。其核心概念为<strong>自动产生随机输入</strong>到一个程式中，并监视程式异常，如crash、assertion failed，以发现可能的程式错误。</p>
<p>简单举个例子，档案<strong>test.c</strong>是你要测试程式的原始码，从stdin 读取8 bytes 后印出，但印出前会比较输入( <code>input</code>)</p>
<p>(1) 的前两个bytes 是否为<code>AB</code>，如果是的话就会执行到写坏的程式码</p>
<p>(2)，并触发segmentation fault 结束程式。</p>
<p>在此(1) 对应到真实程式的某些执行条件，(2) 对应到有问题的烂code。</p>
<p>test.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -o test test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(STDIN_FILENO, input, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (input[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; input[<span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span>) <span class="comment">// (1)</span></span><br><span class="line">        *((<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>) = <span class="number">0xdeadbeef</span>; <span class="comment">// (2)</span></span><br><span class="line">    write(STDOUT_FILENO, input, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但实际上大型程式往往上百万行，中小型至少也会有数千数万行，一行一行找实在是太慢了，将这种测试自动化才是可行之举，因此才有模糊测试的出现。模糊测试就是自动去1. 执行目标程式、2. 喂入的input、3. 回报执行结果，而负责做这些事情的程式称为fuzzer，并且根据开发或是执行效率，会选择用不同的语言来实作。</p>
<p>对于test.c，我们用python 实作一个fuzzer <strong>fuzzer.py</strong>自动去对<strong>test</strong>进行模糊测试，尝试喂入<code>inps</code>的每个element，并由exit status (1) 判断<strong>test</strong>是否发生执行异常，最终会找到element<code>&#39;AB&#39;</code>会触发异常行为。</p>
<p>fuzzer.py：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">target = &#x27;./test&#x27;</span><br><span class="line">inps = [&#x27;AA&#x27;, &#x27;BB&#x27;, &#x27;BA&#x27;, &#x27;AB&#x27;]</span><br><span class="line"></span><br><span class="line">for inp in inps:</span><br><span class="line">    try:</span><br><span class="line">        subprocess.run([target], input=inp.encode(), capture_output=True, check=True)</span><br><span class="line">    except subprocess.CalledProcessError: # (1)</span><br><span class="line">        print(f&quot;bug found with input: &#x27;&#123;inp&#125;&#x27;&quot;)</span><br><span class="line"></span><br><span class="line"># (output)</span><br><span class="line"># bug found with input: &#x27;AB&#x27;</span><br></pre></td></tr></table></figure>

<p>在模糊测试之前，为了检测<strong>程式的功能</strong>是否正常运作，因此会写一些测试脚本或是<strong>Unit Test</strong>，这与模糊测试的方向不太一样，前者为找程式异常，后者单纯测试程式所提供的功能是否正常执行。</p>
<p>而这也跟模糊测试被归类在Security 有关系，在一般情况下使用者会照<strong>正常使用</strong>的方式去使用服务，因此Unit Test 通过后就代表服务能正常运作，满足使用者的需求。然而并不是所有使用者都会正常使用，如果程式并没有检查这些非预期的使用方式，让程式中存在一些漏洞，小则能让服务终止，大则让攻击者取得主机控制权。模糊测试的概念正好符合攻击者的角度，执行程式并喂入随机产生的input，并从执行结果检查当前input 是否让程式满足触发漏洞的条件。</p>
<p>简而言之，模糊测试被拿来找程式漏洞，让程式开发员能尽快修补，避免被攻击者所利用。</p>
<h1 id="Day-2-Fuzzing-内部架构"><a href="#Day-2-Fuzzing-内部架构" class="headerlink" title="[Day 2] Fuzzing 内部架构"></a>[Day 2] Fuzzing 内部架构</h1><p>简单介绍一下<strong>basic block</strong>。程式在执行时会因为不同的条件执行不同的程式码，而不同条件主要就是以 来<code>if</code>定义，以下方程式码为例子，当<code>a == 1 &amp;&amp; b == 2</code>条件满足时会印出<code>&quot;condition 1&quot;</code>，除此之外皆印出<code>&quot;condition 2&quot;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (a == 1 &amp;&amp; b == 2)</span><br><span class="line">	puts(&quot;condition 1&quot;);</span><br><span class="line">else</span><br><span class="line">    puts(&quot;condition 2&quot;);</span><br></pre></td></tr></table></figure>

<p>若将执行逻辑画成图会像下图，而通常这种表示程式执行流程的图就称作<strong>control flow graph</strong> (CFG)。每个方格都代表一个basic block，被划分成同块basic block 的程式码一定会<strong>从第一条instruction 开始执行</strong>，不会有其他程式码透过branch instruction 到达basic block 中第一条之外的instruction ，并且保证在同一块basic block 内的instruction 一定都会被执行到。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281045120.png" alt="img"></p>
<p>下图为使用工具(IDA) 产生出来的instruction level 的CFG，对照上述basic block 的说明即可了解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281046829.png" alt="img"></p>
<p>回归正题，整个fuzzing 流程大致可以拆成三个components，分别为： 1. seed selection、2. mutation、3. coverage。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281046664.png" alt="img"></p>
<blockquote>
<p>建立在Day1 上，<strong>fuzzer.py</strong>与<strong>test.c</strong>分别做了一些更新</p>
</blockquote>
<p><strong>corpus</strong>为过去曾经产生新coverage 的所有input，或是初始化时给定的seed，以<strong>fuzzer.py</strong>为例<code>inps = [&#39;A&#39;, &#39;B&#39;]</code>即是所有seed，可视为corpus。</p>
<p>不同的seed 会有<strong>不同的属性</strong>，像是seed 执行速度或是产生的coverage，而透过分析这些属性来挑seed 的演算法就称作<strong>seed selection</strong>。<strong>fuzzer.py</strong>的selection 演算法比较简单，使用最旧的seed 作为下个input (1)。</p>
<p>之后挑选出来的seed 会做<strong>mutate</strong>来增加随机性，<strong>fuzzer.py</strong>的mutation 演算法会将挑出来的seed 会加上一个随机字元(2) 作为最终的<strong>input</strong>。</p>
<p>将input 喂入target program 后，<strong>fuzzer.py</strong>使用输出结果作为依据来判断执行好坏。<strong>test.c</strong>当输入满足特定条件时会分别输出<code>&quot;AAA&quot;</code>与<code>&quot;BBB&quot;</code>，这也代表当程式有输出时，执行流程会更接近bug，因此将其加到corpus (变数<code>inps[]</code>) 当中(3)，在此可以将<strong>输出结果的多寡</strong>视为<strong>coverage</strong>，如果有输出的话代表此input 为<strong>interesting</strong>。</p>
<p>虽然coverage 的形式可以自己定义，但在大多情况下，执行越多程式码代表越有可能执行到漏洞，因此通常coverage 指的是<strong>执行了多少程式码</strong>，而程式码本身又以basic block 所组成，所以需要透过某些方式在basic block 执行前插入一段用来记录的程式码，此技术称作**插桩(instrumentation)**。</p>
<p>为了避免mutate 效果不好导致input 无法取得新的coverage，因此有时候在fuzzer 中会让corpus 有剧烈的变化(4)，或是定期打乱corpus，这样可能会有意想不到的效果。</p>
<p>test.c:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// gcc -o test test.c</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char input[8] = &#123;0&#125;;</span><br><span class="line">    read(STDIN_FILENO, input, 8);</span><br><span class="line"></span><br><span class="line">    if (input[0] == &#x27;A&#x27;) &#123;</span><br><span class="line">        puts(&quot;AAA&quot;);</span><br><span class="line">        if (input[1] == &#x27;B&#x27;) &#123;</span><br><span class="line">            puts(&quot;BBB&quot;);</span><br><span class="line">            if (input[2] == &#x27;C&#x27;) &#123;</span><br><span class="line">                *((unsigned int *)0) = 0xdeadbeef; // bug</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fuzzer.py:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">target = &#x27;./test&#x27;</span><br><span class="line">inps = [&#x27;A&#x27;, &#x27;B&#x27;]</span><br><span class="line">count = 1</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    inp = inps[0] # (1)</span><br><span class="line">    inp += random.choice([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]) # (2)</span><br><span class="line">    del inps[0]</span><br><span class="line">    count += 1</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        comp = subprocess.run([target], input=inp.encode(), capture_output=True, check=True)</span><br><span class="line">        if comp.stdout != b&#x27;&#x27;:</span><br><span class="line">            inps.append(inp) # (3)</span><br><span class="line">    except subprocess.CalledProcessError:</span><br><span class="line">        print(f&quot;bug found with input: &#x27;&#123;inp&#125;&#x27;&quot;)</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">    if count % 100 == 0 or len(inps) == 0: # (4)</span><br><span class="line">        inps = [&#x27;A&#x27;, &#x27;B&#x27;]</span><br></pre></td></tr></table></figure>

<p>因此一个fuzzer 的好坏，通常是以： </p>
<ol>
<li><strong>seed selection</strong>是否能挑出真正有意义的seed</li>
<li><strong>mutate</strong>的随机是否有效率</li>
<li><strong>coverage</strong>取得的方式是否会造成大量的overhead。</li>
</ol>
<h1 id="Day-3-透过Sanitizer-侦测程式异常"><a href="#Day-3-透过Sanitizer-侦测程式异常" class="headerlink" title="[Day 3] 透过Sanitizer 侦测程式异常"></a>[Day 3] 透过Sanitizer 侦测程式异常</h1><p>即使程式存在漏洞，也不一定会在执行到有漏洞的程式码时触发异常，以下面的程式码为例子，如果使用者输入的<code>idx</code>落在0~99 之间则属于正常范围，超过100 或是小于0 才有可能造成执行异常。然而即便会有out-of-bound write 的漏洞发生，但如果<code>buf[idx]</code>对应到的位址正好没被使用到(1)，即使执行到含有漏洞的程式码片段，也不会产生回报给fuzzer，因此fuzzer就会对这个部分的程式码不感兴趣，导致漏失了一个漏洞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char buf[100];</span><br><span class="line">scanf(&quot;%d&quot;, &amp;idx);</span><br><span class="line">buf[idx] = &#x27;\0&#x27;; // (1)</span><br></pre></td></tr></table></figure>

<p>为了能精准且快速的找出漏洞，compiler 的编译参数中就多了<strong>Sanitizer</strong>的选项。透过Sanitizer 可以在编译时加上一些程式码来追踪程式runtime 的执行状况，提早侦测出程式异常并回报。不过因为会多加程式码，所以执行效率会有明显的影响，通常在production 的版本中不会出现sanitizer，fuzzing 时也不太会使用所有的sanitizer，毕竟执行效率会直接影响coverage。</p>
<p>常见的有AddressSanitizer (+LeakSanitizer)、ThreadSanitizer、UndefinedBehaviorSanitizer 以及MemorySanitizer，并且目前都由google 的<a target="_blank" rel="noopener" href="https://github.com/google/sanitizers/wiki">sanitizers</a> project 来maintain，下面会参考project 内容，分别介绍这四种sanitizer 的功能与使用方法。</p>
<hr>
<h3 id="AddressSanitizer"><a href="#AddressSanitizer" class="headerlink" title="AddressSanitizer"></a>AddressSanitizer</h3><p>AddressSanitizer 又称作<strong>ASAN</strong>，整合了LeakSanitizer ( <strong>LSAN</strong> )，被用在C&#x2F;C++ 中侦测记忆体错误。因为能侦测到out-of-bounds、use-after-free 与memory leak 的发生，在大多数的fuzzing 时都会使用，大概会造成2x 的slowdown。 AddressSanitizer 有发表论文<a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-TW//pubs/archive/37752.pdf">AddressSanitizer: A Fast Address Sanity Checker</a>，较为简洁的说明可以参考<a target="_blank" rel="noopener" href="https://suelan.github.io/2020/08/18/20200817-address-sanitizer/">此网站</a>的介绍，而下方只会做简单的介绍。</p>
<p>变数会有自己的一块记忆体空间储存value，也就是下方图示<code>var&#123;1,2,3,4&#125;</code>各自的方格，而这些记忆体有个重要的特性：都是<strong>连续分配</strong>，因此如果变数<code>var1</code>有out-of-bounds 的漏洞发生，有可能会影响到<code>var&#123;2,3,4&#125;</code>的value，借此改变原本程式的执行流程。</p>
<p>然而ASAN 会在原本的连续记忆体中间插入<strong>red zone</strong>，代表这些是不该被存取的记忆体区块，如果<code>var1</code>会影响到<code>var&#123;2,3,4&#125;</code>，那有很大的机会也会动到中间的red zone，于是我们能透过检查red zone 被污染来判断漏洞的发生。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281047324.png" alt="img"></p>
<p>因此在每次做memory 存取前，会需要对存取位址做检查，如果目标位址落在red zone 就触发asan report，将错误原因dump 出来。</p>
<p>实际会使用<strong>shadow memory</strong>的技术来做存取速度的优化，假设存取的记忆体位址为0x87870000，首先会对位址右移三个3 bits (1)，加上一个固定的offset (2) 得到的记忆体位址即是shadow memory。</p>
<p>而shadow memory 里面存放的值即是要存取的记忆体的型态，如果值为00 的话就是正常的范围， 01~07 代表记忆体本来就不对齐，因此还要考虑到记忆体被存取时的偏移(4)。而&lt; 0 的值代表漏洞发生(3)，并且不同的值代表不同的意义，举例来说发生<strong>Freed heap region</strong> (UAF) 漏洞时，值就会是fd。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void *a;</span><br><span class="line">char magic;</span><br><span class="line">long unsigned shadow_mem_addr;</span><br><span class="line"></span><br><span class="line">a = (void *)0x87870000;</span><br><span class="line">shadow_mem_addr = (long unsigned)a &gt;&gt; 3; // (1)</span><br><span class="line">shadow_mem_addr += 0x7fff8000; // (2)</span><br><span class="line">magic = *(char *)shadow_mem_addr;</span><br><span class="line"></span><br><span class="line">if (magic &lt; 0) // (3)</span><br><span class="line">    dump_and_abort();</span><br><span class="line"></span><br><span class="line">if ( ((long unsigned)a &amp; 7) &gt; magic) // (4)</span><br><span class="line">    dump_and_abort();</span><br></pre></td></tr></table></figure>

<p>一开始用<code>var&#123;1,2,3,4&#125;</code>做介绍，在此用<code>var&#123;1,2&#125;</code>示范shadow memory 的应用：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281048326.png" alt="img"></p>
<p>而<strong>leak checker</strong> (LSAN) 会在程式结束执行前执行另一个process，并透过ptrace 来attach 当前的process。接下来会去分析： 1. 全域变数、2. 正在执行thread 的stacks、3. 正在执行thread 的register、4. TLS 中存放的资料，这些记忆体位址中存放的值会形成root set。之后LSAN 会看root set 的值是否有指向heap block 的pointer，并且block 仍为live memory，代表仍在被使用。</p>
<p>memory leak 范例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// gcc -fsanitize=address -o memory-leak memory-leak.c</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line">void *p;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    p = malloc(7);</span><br><span class="line">    p = 0;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==1164786==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 7 byte(s) in 1 object(s) allocated from:</span><br><span class="line">    #0 0x7fb1207c3867 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145</span><br><span class="line">    #1 0x55f8539bc1da in main (/tmp/memory-leak+0x11da)</span><br><span class="line">    #2 0x7fb120510d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: 7 byte(s) leaked in 1 allocation(s).</span><br></pre></td></tr></table></figure>

<p>UAF 范例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// gcc -fsanitizer=address -o use-after-free use-after-free.c</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char *x = (char*)malloc(10 * sizeof(char*));</span><br><span class="line">    free(x);</span><br><span class="line">    return x[5];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==1165010==ERROR: AddressSanitizer: heap-use-after-free on address 0x607000000105 at pc 0x5653d22d922b bp 0x7ffef65c3610 sp 0x7ffef65c3600</span><br><span class="line">READ of size 1 at 0x607000000105 thread T0</span><br><span class="line">    #0 0x5653d22d922a in main (/tmp/use-after-free+0x122a)</span><br><span class="line">    #1 0x7f9bf2931d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span><br><span class="line">    #2 0x7f9bf2931e3f in __libc_start_main_impl ../csu/libc-start.c:392</span><br><span class="line">    #3 0x5653d22d9104 in _start (/tmp/use-after-free+0x1104)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-use-after-free (/tmp/use-after-free+0x122a) in main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  ...</span><br><span class="line">  0x0c0e7fff8010: fa fa 00 00 00 00 00 00 00 00 05 fa fa fa fa fa</span><br><span class="line">=&gt;0x0c0e7fff8020:[fd]fd fd fd fd fd fd fd fd fd fa fa fa fa fa fa</span><br><span class="line">  ....</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07</span><br><span class="line">  ...</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  ...</span><br><span class="line">==1165010==ABORTING</span><br></pre></td></tr></table></figure>

<h3 id="浅谈「内存调试技术」"><a href="#浅谈「内存调试技术」" class="headerlink" title="浅谈「内存调试技术」"></a>浅谈「内存调试技术」</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44555968/article/details/89879854#shadow_memory_12">一、影子内存(shadow memory)</a></li>
<li><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44555968/article/details/89879854#_27">比例+偏移的映射算法</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44555968/article/details/89879854#instrumentation_59">二、插桩（instrumentation)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44555968/article/details/89879854#_147">三、专用版内存函数</a></li>
</ul>
<p>内存问题在 C&#x2F;C++ 程序中十分常见，比如缓冲区溢出，使用已经释放的堆内存，内存泄露等。</p>
<p>程序大了以后，查找起来又特别的难。即使我们在写程序时非常的仔细小心，代码一多，还是难以保证没有问题。</p>
<p>内存问题除了造成程序崩溃引发意外，也很容易被当做漏洞利用，给程序安全带来隐患。诸多工具尝试通过静态代码分析或运行时动态检测来发现内存问题。</p>
<p>Mozilla 甚至因为内存问题专门发明了一个新的编程语言 Rust，一定程度上回避了程序员的失误，但不能完全解决。</p>
<p>无意间看到一篇讲解 <strong>AddressSanitizer</strong> 的论文 1，介绍了几种动态检测技术，分析了多种工具的原理和优缺点，在此整理分享。</p>
<h4 id="一、影子内存-shadow-memory"><a href="#一、影子内存-shadow-memory" class="headerlink" title="一、影子内存(shadow memory)"></a>一、影子内存(shadow memory)</h4><p>Shadow Memory 姑且直译为影子内存。</p>
<p>为了说明影子内存，我们把程序正常运行使用的内存叫做 <strong>常规内存</strong>。</p>
<p>影子内存技术，就是使用额外的内存来存管理常规内存的分配和使用，这些额外的内存对于被检测程序不可见，因此叫影子内存。</p>
<p><strong>每块常规内存都有对应的影子内存</strong>。</p>
<p>常规内存分配和释放的时候，在对应的影子内存里记录该常规内存的属性信息，比如是否可访问，是否已经被释放。在每次访问常规内存之前，都先检查对应的影子内存，看看该常规内存是否可访问。</p>
<p>为了快速找到常规内存对应的影子内存，通常使用某种映射算法，实现常规内存地址到影子内存地址的映射。</p>
<p>一种是查表，一种是用比例+偏移来直接映射。查表就是事先设置一个表，里面保存者常规内存和影子内存的对应关系。不多叙述。以下介绍一下比例+偏移的方式。</p>
<h5 id="比例-偏移的映射算法"><a href="#比例-偏移的映射算法" class="headerlink" title="比例+偏移的映射算法"></a>比例+偏移的映射算法</h5><p>Malloc() 函数返回的地址通常至少 8 字节对齐。</p>
<p>这就意味着任何 8 字节对齐的堆内存可以有 9 种状态：全部可访问，或全部不可访问，或者是剩下 7 种的一种，前面的k字节 (0 &lt;k &lt; 8) 是可访问的，后面剩下的 8-k 字节是不可访问。这 8 个字节的常规内存的可否访问的状态，可以用一个字节的影子内存来编码保存。</p>
<p>也就是说，一个字节的影子内存，可以记录多个字节的常规内存的可访问信息，这样就可以按照一定的比例，使用较少的影子内存，记录较多的常规内存的信息。适当的设置一个偏移值 Offset，把影子内存放在合适的位置。</p>
<p>假设使用 8:1 的比例来映射，常规内存的地址是 Addr，那么影子内存的地址就是 (Addr&gt;&gt;3+Offset) 。</p>
<p>假设常规内存的最大地址是 Max-1， 选取的 Offset 应该满足如下约束：影子内存的地址段， 也就是 Offset 到 (Offset+Max)&#x2F;8 的地址段，不能被应用程序用到。</p>
<p>比如在 32bit 的 linux 或 macOS 上， 虚拟地址空间为 0x00000000-0xffffffff，可以选取 Offset &#x3D; 0x20000000(2^29)。</p>
<p>影子内存在整个地址空间的中间区域。影子内存自己的地址不可被程序当做常规内存访问，通过映射，落到 Bad 区域，访问它将出错。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410282052173.png" alt="==图=="></p>
<p>之前说了，按照 8:1 的比例来编码。</p>
<p>8 个字节的常规内存，可使用一个字节的影子内存来记录可访问信息。</p>
<p>影子内存里 9 种状态的编码如下：</p>
<ul>
<li>0， 表示所有 8 个字节都可以访问</li>
<li>k， (1&lt;&#x3D;k&lt;&#x3D;7) 表示前 k 个字节可以访问</li>
<li>负数， 表示整个的 8 个字节都不可访问。可以使用不同的负数，表示不同的内存区域，比如堆内存，栈内存，全局变量的内存，已经释放的内存</li>
</ul>
<p>直接映射的代表性的例子是 TaintTrace 和 LIFT。TaintTrace 按照 1:1 映射。缺点就是无法处理内存需求特别大的被检测程序 ，如果被检测程序使用了一半以上的地址空间，那就没有足够的地址空间来容纳影子内存了。相比来说，LIFT 使用 8:1 的比例设置影子内存。</p>
<p>间接映射的代表是 valgrind 和 Dr.Memory。他们设置多个影子内存段，然后配合查表法来完成映射。</p>
<h4 id="二、插桩（instrumentation"><a href="#二、插桩（instrumentation" class="headerlink" title="二、插桩（instrumentation)"></a>二、插桩（instrumentation)</h4><p>Instrumentation，指用仪器在系统的某些节点进行测量或干预。</p>
<p>这里指在程序的代码里，插入一些测量或是控制用的额外代码。这些额外代码，通常用于 shadow memory 的管理和检测。</p>
<p>Instrumentation 可以编译时完成，编译器生成代码时直接在原来的程序代码里插入一些额外的代码，也可以在编译后完成，修改程序的二进制代码，在里面插入一些额外代码。</p>
<p>在 8 字节对齐的环境里，程序访问一个 8 字节的常规内存时，可以插入以下代码来完成 shadow memory 的检测：</p>
<p>回顾影子内存的编码：0 表示可访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ShadowAddr = (Addr &gt;&gt; <span class="number">3</span>) + Offset;</span><br><span class="line"><span class="keyword">if</span> (*ShadowAddr != <span class="number">0</span>)</span><br><span class="line">ReportAndCrash(Addr);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>如果程序访问的是长度为 1 或 2 或 4 字节的常规内存，稍微复杂一点，需要比较影子内存里的 k 值和常规内存地址的后 3 位：</p>
<p>（回顾影子内存的编码：0 表示可访问，k 表示前 k 字节可访问，负数表示 8 个字节都不能访问）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ShadowAddr = (Addr &gt;&gt; <span class="number">3</span>) + Offset;</span><br><span class="line">k = *ShadowAddr;</span><br><span class="line"><span class="keyword">if</span> (k != <span class="number">0</span> &amp;&amp; ((Addr &amp; <span class="number">7</span>) + AccessSize &gt; k))</span><br><span class="line">ReportAndCrash(Addr);</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>以下用 AddressSanitizer 的例子来说明 instrumentation。分别是 x64 环境里的 8 字节和 4 字节访问。</p>
<p>原本的函数是这样——</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(T *a)</span> &#123;</span><br><span class="line">*a = <span class="number">0x1234</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8 字节访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O2 -faddress-sanitizer a.c -c -DT=<span class="type">long</span></span><br></pre></td></tr></table></figure>

<p>插入代码以后是这样——</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">push %rax</span><br><span class="line">mov %rdi,%rax # %rdx是指针a</span><br><span class="line">shr $<span class="number">0x3</span>,%rax </span><br><span class="line">mov $<span class="number">0x100000000000</span>,%rcx</span><br><span class="line">or %rax,%rcx  # 取得a的影子内存地址</span><br><span class="line">cmpb $<span class="number">0x0</span>,(%rcx) # 判断影子内存的值是否为<span class="number">0</span>(<span class="number">0</span>表示可访问）</span><br><span class="line">jne <span class="number">23</span> &lt;foo+<span class="number">0x23</span>&gt; # 不可访问，报错</span><br><span class="line">movq $<span class="number">0x1234</span>,(%rdi) # 否则，可访问，执行原赋值语句 *a = <span class="number">0x1234</span>;</span><br><span class="line">pop %rax</span><br><span class="line">retq</span><br><span class="line">callq __asan_report_store8 # Error</span><br></pre></td></tr></table></figure>

<p>4 字节访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O2 -faddress-sanitizer a.c -c -DT=<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>插入代码以后是这样——</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">push %rax</span><br><span class="line">mov %rdi,%rax # %rdx是指针a</span><br><span class="line">shr $<span class="number">0x3</span>,%rax</span><br><span class="line">mov $<span class="number">0x100000000000</span>,%rcx</span><br><span class="line">or %rax,%rcx</span><br><span class="line"><span class="title function_">mov</span> <span class="params">(%rcx)</span>,%al # 取得影子内存的值</span><br><span class="line">test %al,%al</span><br><span class="line">je <span class="number">27</span> &lt;foo+<span class="number">0x27</span>&gt; # 值为<span class="number">0</span>，跳到原来的赋值语句</span><br><span class="line">mov %edi,%ecx </span><br><span class="line">and $<span class="number">0x7</span>,%ecx </span><br><span class="line">add $<span class="number">0x3</span>,%ecx # 取得被访问的常规内存的最后一字节相对于<span class="number">8</span>字节对齐的偏移， 即(Addr &amp; <span class="number">7</span>) + AccessSize</span><br><span class="line">cmp %al,%cl # 和影子内存的值k比较</span><br><span class="line">jge <span class="number">2f</span> &lt;foo+<span class="number">0x2f</span>&gt; # 不可访问，报错</span><br><span class="line">movl $<span class="number">0x1234</span>,(%rdi) # 可访问，执行原赋值语句</span><br><span class="line">pop %rax</span><br><span class="line">retq</span><br><span class="line">callq __asan_report_store4 # Error</span><br></pre></td></tr></table></figure>

<h4 id="三、专用版内存函数"><a href="#三、专用版内存函数" class="headerlink" title="三、专用版内存函数"></a>三、专用版内存函数</h4><p>使用专用版本的内存分配和释放函数，替换系统的内存分配和释放函数，由此提供额外的内存管理功能，检测内存的异常使用，同时又不改变原来程序的流程。</p>
<p>这里又分两类：</p>
<blockquote>
<ul>
<li><strong>利用 CPU 的内存页保护功能</strong><br>以 Electric Fence, Duma, GuardMalloc, Page Heap 为代表的工具，使用 CPU 的内存页保护功能：CPU 访问一个不可访问的内存页的时候，会触发异常。该类工具实现的内存分配函数，除了正常的分配内存，还在后面紧接着分配一个不可访问的内存页。程序如果访问内存越界，就访问到了后面的内存页，触发异常。这种办法的缺点是，如果程序需要分配很多的内存，会导致分配很多后面的不可访问的内存页，分配内存次数多，就会运行的很慢。并且这种方式无法检测到轻微的越界，比如分配了 5 个字节的内存，访问了第 6 个字节，因为内存对齐的原因，访问第 6 个字节的内存不会触发异常。</li>
<li><strong>使用填充区和填充标记</strong><br>DieHarder， Dmalloc 为代表，分配内存时，在被分配内存的前后，额外分配内存，并填充特殊的值，释放内存的时候，在被释放的内存里也填充特殊值。如果程序读到了这些特殊值，就表示程序访问内存越界了。这种方法的缺点是，无法及时检测到越界访问行为，只能在运行结束时分析特殊值是否被读取或改写来计算总结，这会导致一定的概率检测不到错误。</li>
</ul>
</blockquote>
<p>上面两者方法都只能用来检测堆内存上的问题。StackGuard 和 Propolice 利用同样的原理，在栈上面也填充一些特殊值，在程序返回的时候检测是否被改写，来发现问题。</p>
<p>实际的内存检测工具，往往多种技术并用，在细节上，算法上有所差异，导致工具的性能和准确度各有千秋。通常检测质量高的，效率比较低；效率高的，质量又会低。有的工具，会吃掉数倍甚至数十倍的内存，cpu 效率也降低到 1&#x2F;10 的量级。AddressSanitizer 在多种工具的基础上，各取所长，显著提高质量和效率，综合只有 73% 的降低。</p>
<p>在 clang 和 gcc 中都实现了 AddressSanitizer。只需要编译的时候添加上 -fsanitize&#x3D;address -fno-omit-frame-pointer 即可。该论文中提到，利用 AddressSanitizer 在 Chromium 浏览器中找到了 300 多个之前没有发现的 bug。效果拔群，值得推荐。</p>
<h3 id="ThreadSanitizer"><a href="#ThreadSanitizer" class="headerlink" title="ThreadSanitizer"></a>ThreadSanitizer</h3><p>ThreadSanitizer 又称作<strong>TSAN</strong>，主要用来侦测data race，造成的slowdown 大概为5x-15x。 TSAN 关心两种行为： 1. 记忆体存取事件、2. 同步事件，前者为存取记忆体的操作，像是读写记忆体，后者为locking 与happens-before。而TSAN 会内部维持一个<strong>状态机</strong>来监控这些行为，并根据状态机的更新来检测data race 的发生，更多的细节可以参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38687826">此篇文章</a>。</p>
<p>data race 范例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// g++ -fsanitizer=thread -o race race.cpp</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">typedef std::map&lt;std::string, std::string&gt; map_t;</span><br><span class="line"></span><br><span class="line">void *threadfunc(void *p) &#123;</span><br><span class="line">    map_t&amp; m = *(map_t*)p;</span><br><span class="line">    m[&quot;foo&quot;] = &quot;bar&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    map_t m;</span><br><span class="line">    pthread_t t;</span><br><span class="line">    pthread_create(&amp;t, 0, threadfunc, &amp;m);</span><br><span class="line">    printf(&quot;foo=%s\n&quot;, m[&quot;foo&quot;].c_str());</span><br><span class="line">    pthread_join(t, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="MemorySanitizer"><a href="#MemorySanitizer" class="headerlink" title="MemorySanitizer"></a>MemorySanitizer</h3><p>MemorySanitizer 又称作<strong>MSAN</strong>，用来侦测未初始化记忆体的使用，有2.5x 的slowdown。未初始化代表在写入某块记忆体之前就做读取，而MSAN 会在compile time 执行<strong>shadow propagation</strong>，也就是在compiler optimization pass 的过程中就对IR instruction 使用的记忆体建立一个<strong>1-1 的shadow memory</strong>，如果instruction 会存取到某块记忆体，就会新增”更新对应的shadow memory 的instruction”。 shadow memory 是bit-precise，因此<strong>bit</strong>有在使用的话，对应的shadow bit 就会设为0，否则初始值为1，代表没有被初始化。</p>
<p>由于会需要透过LLVM pass 做instrumentation，因此需要用clang&#x2F;clang++ 来编译。</p>
<p>未初始化范例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// clang++ -fsanitize=memory -o umr umr.cpp</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    int* a = new int[10];</span><br><span class="line">    a[5] = 0;</span><br><span class="line">    if (a[argc])</span><br><span class="line">        printf(&quot;xx\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">==1174287==WARNING: MemorySanitizer: use-of-uninitialized-value</span><br><span class="line">    #0 0x557751251550 in main /tmp/test.cpp:7:9</span><br><span class="line">    #1 0x7fafa013dd8f in __libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16</span><br><span class="line">    #2 0x7fafa013de3f in __libc_start_main csu/../csu/libc-start.c:392:3</span><br><span class="line">    #3 0x5577511c92a4 in _start (/tmp/umr+0x1e2a4) (BuildId: dd66654b82c0a369200de8e3f89642a1d07872f6)</span><br><span class="line"></span><br><span class="line">SUMMARY: MemorySanitizer: use-of-uninitialized-value /tmp/test.cpp:7:9 in main</span><br><span class="line">Exiting</span><br></pre></td></tr></table></figure>

<h1 id="Day-4-近代fuzzer-始祖-AFL-总览-amp-编译"><a href="#Day-4-近代fuzzer-始祖-AFL-总览-amp-编译" class="headerlink" title="[Day 4] 近代fuzzer 始祖- AFL - 总览&amp; 编译"></a>[Day 4] 近代fuzzer 始祖- AFL - 总览&amp; 编译</h1><p>Fuzzing 的概念也许已经存在一阵子，不过近期最有影响性的fuzzer 应该公认为<a target="_blank" rel="noopener" href="https://github.com/google/AFL">AFL</a>，实作直观并且具有完整的框架，code base 不大之外程式码也很好看懂，因此接下来的几天会介绍AFL 的实作，让读者对完整Fuzzer 的实作有更深入的了解。</p>
<p>整个过程可以拆分成两个部分： 1. 对于target source code 的处理、2. 执行过程中fuzzer 与target 的互动。首先预计会花两天的时间介绍第一个部分，而在之后花三、四天介绍第二部分。</p>
<p>AFL 对于target source code 的处理又可以拆成： 1. compile、2. assemble 两个部分，今天会着重在<strong>compile</strong>的处理。</p>
<h3 id="建立执行环境"><a href="#建立执行环境" class="headerlink" title="建立执行环境"></a>建立执行环境</h3><p>首先需要clone 并且编译AFL 相关档案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">git clone https://github.com/google/AFL</span><br><span class="line">cd ~/AFL</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>编译后会在~&#x2F;AFL 路径底下产生多个执行档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|-- afl-as</span><br><span class="line">|-- afl-clang -&gt; afl-gcc</span><br><span class="line">|-- afl-clang++ -&gt; afl-gcc</span><br><span class="line">|-- afl-fuzz</span><br><span class="line">|-- afl-g++ -&gt; afl-gcc</span><br><span class="line">|-- afl-gcc</span><br></pre></td></tr></table></figure>

<p>之后要跑AFL 之前需要先编译你的target file，在此以test.c 为例，参考注解说明执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># compile source code</span><br><span class="line">~/AFL/afl-gcc -o test test.c</span><br><span class="line"></span><br><span class="line"># generate seed</span><br><span class="line">mkdir in &amp;&amp; echo &quot;seed&quot; &gt; in/seed</span><br><span class="line"></span><br><span class="line"># setup environment</span><br><span class="line">echo core | sudo tee /proc/sys/kernel/core_pattern</span><br><span class="line">echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor</span><br><span class="line"></span><br><span class="line"># run fuzzer</span><br><span class="line">~/AFL/afl-fuzz -i in -o out ./test</span><br></pre></td></tr></table></figure>

<p>test.c：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    read(0, &amp;a, 0x2);</span><br><span class="line">    if (a == 0xdead)</span><br><span class="line">        *(int *)0 = 0xdeadbeef;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>~/AFL/afl-fuzz -i in -o out ./test</code>后如果有看到以下画面，就代表AFL 有成功跑起来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281049014.png" alt="img"></p>
<h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><p>建置环境时我们有使用到 来<code>~/AFL/afl-gcc -o test test.c</code>编译test.c，实际上程式afl-gcc 只是一般使用的C compile <strong>gcc</strong>的包装，目的是要方便使用者使用，也就是最终<code>~/AFL/afl-gcc XXX YYY</code>会转成<code>gcc XXX YYY ZZZ ...</code>去做执行，接下来从程式码的逻辑来了解这个机制。</p>
<p>在afl-gcc 的原始码afl-gcc.c 当中，最重要的是function <code>edit_params()</code>，就如同他的名字，实际上是用来更新使用者传进来的参数，其中一些相较不重要的程式码片段已经删剪或修改，如果有兴趣可以找完整的code 来看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">static void edit_params(u32 argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    u8 asan_set = 0;</span><br><span class="line">    u8 *name;</span><br><span class="line">    </span><br><span class="line">    // cc_params array 會儲存要被執行指令的參數</span><br><span class="line">    cc_params = ck_alloc((argc + 128) * sizeof(u8*));</span><br><span class="line"></span><br><span class="line">    // 取得執行檔名稱，最後會得到 &quot;afl-gcc&quot;</span><br><span class="line">    name = strrchr(argv[0], &#x27;/&#x27;);</span><br><span class="line">    if (!name) name = argv[0]; else name++;</span><br><span class="line"></span><br><span class="line">    if (!strncmp(name, &quot;afl-clang&quot;, 9)) &#123;</span><br><span class="line">        // clang 為另一個 C compiler，在此不討論</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // ...</span><br><span class="line">        else &#123;</span><br><span class="line">            // 這邊會把 gcc 加到要被執行指令的參數中</span><br><span class="line">            u8* alt_cc = getenv(&quot;AFL_CC&quot;);</span><br><span class="line">            cc_params[0] = alt_cc ? alt_cc : (u8*)&quot;gcc&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (--argc) &#123;</span><br><span class="line">        // 取出每個執行參數做處理</span><br><span class="line">        u8* cur = *(++argv);</span><br><span class="line">        // 如果使用 sanitizer，會透過變數做紀錄</span><br><span class="line">        if (!strcmp(cur, &quot;-fsanitize=address&quot;) ||</span><br><span class="line">            !strcmp(cur, &quot;-fsanitize=memory&quot;)) asan_set = 1;</span><br><span class="line">        cc_params[cc_par_cnt++] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    // -B &lt;path&gt; 可以將 path 加到搜尋 compiler/assembler 的路徑當中</span><br><span class="line">    cc_params[cc_par_cnt++] = &quot;-B&quot;;</span><br><span class="line">    cc_params[cc_par_cnt++] = as_path; // AFL 的路徑</span><br><span class="line">	</span><br><span class="line">    // 設置環境變數 AFL_USE_ASAN，代表有使用 sanitizer</span><br><span class="line">    if (asan_set) &#123;</span><br><span class="line">        setenv(&quot;AFL_USE_ASAN&quot;, &quot;1&quot;, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加上額外的優化參數</span><br><span class="line">    cc_params[cc_par_cnt++] = &quot;-g&quot;;</span><br><span class="line">    cc_params[cc_par_cnt++] = &quot;-O3&quot;;</span><br><span class="line">    cc_params[cc_par_cnt++] = &quot;-funroll-loops&quot;;</span><br><span class="line">    cc_params[cc_par_cnt++] = &quot;-D__AFL_COMPILER=1&quot;;</span><br><span class="line">    cc_params[cc_par_cnt++] = &quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;;</span><br><span class="line">    cc_params[cc_par_cnt] = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后变数<code>cc_params[]</code>会作为function<code>execvp()</code>的参数，执行以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c -B /home/user/AFL -g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</span><br></pre></td></tr></table></figure>

<ul>
<li>-g: 为产生的执行档加上debug info</li>
<li>-D: 定义macro</li>
<li>-O3: level3 的optimization</li>
</ul>
<h1 id="Day-5-近代fuzzer-始祖-AFL-插桩-amp-组译"><a href="#Day-5-近代fuzzer-始祖-AFL-插桩-amp-组译" class="headerlink" title="[Day 5] 近代fuzzer 始祖- AFL - 插桩&amp; 组译"></a>[Day 5] 近代fuzzer 始祖- AFL - 插桩&amp; 组译</h1><h3 id="插桩介绍"><a href="#插桩介绍" class="headerlink" title="插桩介绍"></a>插桩介绍</h3><p>插桩(instrumentation) 的核心概念为： 在保证原程式逻辑的完整性下，在程式中插入一些程式码来搜集runtime 期间的执行状态。以下方程式码为例子，假设在执行期间变数<code>test_var</code>的值会持续更新，并且原本的程式码(1) 不会将此变数值印出。若想要观察<code>test_var</code>在每个function 呼叫时的值，就能透过插桩(2)，让function 在执行原程式逻辑前先将变数值印出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int test_var = 0;</span><br><span class="line"></span><br><span class="line">// original (1)</span><br><span class="line">void b() &#123; ...; &#125;</span><br><span class="line">void a() &#123; ...; &#125;</span><br><span class="line"></span><br><span class="line">// instrumented (2)</span><br><span class="line">void b() &#123; printf(&quot;test_var: %d\n&quot;, test_var); ...; &#125;</span><br><span class="line">void a() &#123; printf(&quot;test_var: %d\n&quot;, test_var); ...; &#125;</span><br></pre></td></tr></table></figure>

<p>插桩的对象通常都具有相同属性或类别，像是所有的function、所有的basic block，比较少针对单一目标。而插桩的程式码通常只有几行assembly code，并不会做太复杂的操作，否则会有效能上的疑虑。</p>
<p>在fuzzer 中，插桩被来用来搜集coverage，也就是纪录多少程式码被执行到。举以下程式码为例，function<code>a</code>执行原程式逻辑前，会先执行插桩程式码，记录执行状态到变数<code>had_exec[]</code>(1)。在原程式逻辑执行结束后，就能分析这次执行所使用的input 走到多少function (2)，评估此input 的价值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int had_exec[100] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void a()</span><br><span class="line">&#123;</span><br><span class="line">    had_exec[0] = 1; // (1)</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">void b() &#123; had_exec[1] = 1; ...; &#125;</span><br><span class="line">void c() &#123; had_exec[2] = 1; ...; &#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    if (had_exec[0]) // (2)</span><br><span class="line">        puts(&quot;function a had been called&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Assemble"><a href="#Assemble" class="headerlink" title="Assemble"></a>Assemble</h3><p>昨天介绍到透过afl-gcc 编译时，底层其实会呼叫到gcc 执行，执行指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c -B /home/user/AFL -g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</span><br></pre></td></tr></table></figure>

<p>有趣的是<code>-B /home/user/AFL</code>，这个option 能够使得gcc 在找编译相关的执行档时，会将&#x2F;home&#x2F;user&#x2F;AFL 加到搜寻的路径，也就是说gcc 会尝试在此路径找toolchain 中的assembler <strong>as</strong>来执行，简单用<code>ls</code>看一下会发现&#x2F;home&#x2F;user&#x2F;AFL&#x2F;as 实际上softlink 到&#x2F;home&#x2F;user&#x2F;AFL&#x2F;afl-as，也就是AFL 自己的执行档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~/AFL/as</span><br><span class="line">lrwxrwxrwx 1 user user 6 Sep  6 14:55 /home/user/AFL/as -&gt; afl-as</span><br></pre></td></tr></table></figure>

<p>以下为最后执行到afl-as 时的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/user/AFL/as --gdwarf-5 --64 -o /tmp/ccKUZ8k0.o /tmp/cc9cCq4m.s</span><br></pre></td></tr></table></figure>

<p>afl-as 的原始码为afl-as.c，实际上行为与afl-gcc 大致相似，也是包装执行参数以方便使用。除此之外afl-as 还会做插桩，用来搜集执行期间的coverage。</p>
<p>afl-as 首先会先执行function<code>edit_params()</code>来调整参数，而后会执行function<code>add_instrumentation()</code>做插桩，最后执行as 做组译。</p>
<h4 id="调整参数"><a href="#调整参数" class="headerlink" title="调整参数"></a>调整参数</h4><p>因为最终还是需要透过as 去组译，因此这边会分析原本的执行参数，并转成之后要执行as 所使用到的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static void edit_params(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    u8 *tmp_dir = getenv(&quot;TMPDIR&quot;), *afl_as = getenv(&quot;AFL_AS&quot;);</span><br><span class="line">    u32 i;</span><br><span class="line">    </span><br><span class="line">    // 用來放 as 參數，由此可知最後會呼叫到原生的 assembler &quot;as&quot;</span><br><span class="line">    as_params = ck_alloc((argc + 32) * sizeof(u8*));</span><br><span class="line">    as_params[0] = afl_as ? afl_as : (u8*)&quot;as&quot;;</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; argc - 1; i++) &#123;</span><br><span class="line">        // 目標檔案為 32-bit or 64-bit</span><br><span class="line">        if (!strcmp(argv[i], &quot;--64&quot;)) use_64bit = 1;</span><br><span class="line">        else if (!strcmp(argv[i], &quot;--32&quot;)) use_64bit = 0;</span><br><span class="line">        as_params[as_par_cnt++] = argv[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 原本的 assembly filename</span><br><span class="line">    input_file = argv[argc - 1];</span><br><span class="line">    // 之後做插樁的 assembly filename</span><br><span class="line">    modified_file = alloc_printf(&quot;%s/.afl-%u-%u.s&quot;, tmp_dir, getpid(),</span><br><span class="line">                                 (u32)time(NULL));</span><br><span class="line">    as_params[as_par_cnt++] = modified_file;</span><br><span class="line">    as_params[as_par_cnt]   = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调整后的参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as --gdwarf-5 --64 -o /tmp/ccKUZ8k0.o /tmp/.afl-2863431-1662523292.s</span><br></pre></td></tr></table></figure>

<h4 id="afl-as-插桩"><a href="#afl-as-插桩" class="headerlink" title="afl-as 插桩"></a>afl-as 插桩</h4><p>在<code>add_instrumentation()</code>较为重要的逻辑是判断哪些asm code 需要被插桩以及哪些不需要，不过判断的逻辑相较复杂，因此在这边只介绍实际上插桩要怎么做，而判断插桩的对象就简单用注解带过，至于插桩程式码做了哪些事情会在下次说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static void add_instrumentation(void)</span><br><span class="line">&#123;</span><br><span class="line">    static u8 line[MAX_LINE];</span><br><span class="line"></span><br><span class="line">    FILE* inf;</span><br><span class="line">    FILE* outf;</span><br><span class="line">    s32 outfd;</span><br><span class="line"></span><br><span class="line">    inf = fopen(input_file, &quot;r&quot;); // 開啟原本的 asm file</span><br><span class="line">    // 建立新的 asm file 並開啟</span><br><span class="line">    outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, 0600);</span><br><span class="line">    outf = fdopen(outfd, &quot;w&quot;);</span><br><span class="line"></span><br><span class="line">    // 將原本 asm file 的檔案一行行讀出來</span><br><span class="line">    while (fgets(line, MAX_LINE, inf)) &#123;</span><br><span class="line">        /* </span><br><span class="line">         以下 asm code 會做插樁：</span><br><span class="line">         ^main:      - function entry point (always instrumented)</span><br><span class="line">         ^.L0:       - GCC branch label</span><br><span class="line">         ^.LBB0_0:   - clang branch label (but only in clang mode)</span><br><span class="line">         ^\tjnz foo  - conditional branches</span><br><span class="line"></span><br><span class="line">		 以下不會：</span><br><span class="line">         ^# BB#0:    - clang comments</span><br><span class="line">         ^ # BB#0:   - ditto</span><br><span class="line">         ^.Ltmp0:    - clang non-branch labels</span><br><span class="line">         ^.LC0       - GCC non-branch labels</span><br><span class="line">         ^.LBB0_0:   - ditto (when in GCC mode)</span><br><span class="line">         ^\tjmp foo  - non-conditional jumps</span><br><span class="line">     	*/</span><br><span class="line">        if (no_need_instrument(line)) continue;</span><br><span class="line">        </span><br><span class="line">        // 在寫到新 asm file 前先將插樁程式碼 (trampoline_fmt_64) 寫進去</span><br><span class="line">        fprintf(outf, trampoline_fmt_64, R(MAP_SIZE));</span><br><span class="line">        // 最後在寫原本的 asm code</span><br><span class="line">        fputs(line, outf);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    // 加上其他 instrumentation code (main_payload_64)</span><br><span class="line">    fputs(main_payload_64, outf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做完插桩后会执行调整后的参数来编译新的asm file，最后产生出的执行档test 即是有插桩的版本，简单用objdump 就能看到许多以**__afl**为prefix 的function：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281051281.png" alt="img"></p>
<h1 id="Day-6-近代fuzzer-始祖-AFL-插桩程式码"><a href="#Day-6-近代fuzzer-始祖-AFL-插桩程式码" class="headerlink" title="[Day 6] 近代fuzzer 始祖- AFL - 插桩程式码"></a>[Day 6] 近代fuzzer 始祖- AFL - 插桩程式码</h1><p>在Day 4, 5 已经了解afl 是如何包装编译的过程，并且在组译时插入程式码，在此做个小结论：</p>
<ul>
<li>afl-gcc 包装了gcc 的执行参数来compile 原始码</li>
<li>afl-as 包装了as 的执行参数，插桩在compile 出来的asm file，而插桩的位置大致涵盖所有basic block 以及<strong>main function 的开头</strong></li>
<li>最后as 组译asm file 产生执行档</li>
</ul>
<p>今天会介绍插了哪些程式码，以及这些程式码是怎么跟fuzzer 做互动。</p>
<h3 id="插桩程式码"><a href="#插桩程式码" class="headerlink" title="插桩程式码"></a>插桩程式码</h3><p>在afl-as.c 的function<code>add_instrumentation()</code>中对会对每个basic block 做插桩，内容包含变数<code>main_payload_64</code>与<code>trampoline_fmt_64</code>，而这两个变数定义在afl-as.h，不过<code>main_payload_64</code>主要是定义afl 相关的function，因此先看<code>trampoline_fmt_64</code>就好：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static const u8* trampoline_fmt_64 =</span><br><span class="line">    // 更新 stack (1)</span><br><span class="line">    &quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span><br><span class="line">    // 保存 register value (2)</span><br><span class="line">    &quot;movq %%rdx,  0(%%rsp)\n&quot;</span><br><span class="line">    &quot;movq %%rcx,  8(%%rsp)\n&quot;</span><br><span class="line">    &quot;movq %%rax, 16(%%rsp)\n&quot;</span><br><span class="line">    &quot;movq $0x%08x, %%rcx\n&quot; // (5)</span><br><span class="line">    </span><br><span class="line">    // 呼叫 afl function (3)</span><br><span class="line">    &quot;call __afl_maybe_log\n&quot;</span><br><span class="line"></span><br><span class="line">    // 恢復 register value 以及更新 stack (4)</span><br><span class="line">    &quot;movq 16(%%rsp), %%rax\n&quot;</span><br><span class="line">    &quot;movq  8(%%rsp), %%rcx\n&quot;</span><br><span class="line">    &quot;movq  0(%%rsp), %%rdx\n&quot;</span><br><span class="line">    &quot;leaq (128+24)(%%rsp), %%rsp\n&quot;;</span><br></pre></td></tr></table></figure>

<p>为了避免影响到目前的执行流程，因此要先建立新的stack frame (1)，并保存执行期间会使用到的register (2)，而后呼叫处理coverage 的afl function <code>__afl_maybe_log()</code>(3)，最后恢复register 与stack (4)。在插桩过程中，会随机产生一组代表当前basic block 的id (5)，透过RCX 传入<code>__afl_maybe_log()</code>，待会就能知道这组id 有什么功能。</p>
<p>因为对于每个basic block 都会执行这段asm code，因此执行效率会与native 的有差，并且当input 所覆盖的coverage 越高，执行速度就越慢。</p>
<p><code>__afl_maybe_log()</code>定义在变数<code>main_payload_64</code>当中，用来初始化fuzzing 环境以及搜集coverage。因为asm 不好看出程式逻辑，因此用下方的C pseudo code 来介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 與 fuzzer 溝通用的 pipe (1)</span><br><span class="line">#define READ_PIPE_FD 198</span><br><span class="line">#define WRITE_PIPE_FD 199</span><br><span class="line"></span><br><span class="line">char _afl_maybe_log(__int64 a1, __int64 a2, __int64 a3, __int64 bbid)</span><br><span class="line">&#123;</span><br><span class="line">    // 是否需要初始化 (2)</span><br><span class="line">    if ( !_afl_area_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">        // 取得 shared memory (3)</span><br><span class="line">        shmid_str = getenv(&quot;__AFL_SHM_ID&quot;);</span><br><span class="line">        shmid_int = atoi(shmid_str);</span><br><span class="line">        shm = shmat(shmid_int, NULL, 0);</span><br><span class="line">        _afl_area_ptr = shm;</span><br><span class="line"></span><br><span class="line">        // handshake (4)</span><br><span class="line">        if ( write(WRITE_PIPE_FD, &amp;_afl_temp, 4) == 4 )</span><br><span class="line">        &#123;</span><br><span class="line">// --------------- fork server (5) ---------------</span><br><span class="line">            while ( 1 )</span><br><span class="line">            &#123;</span><br><span class="line">                if ( read(READ_PIPE_FD, &amp;_afl_temp, 4) != 4 ) // (6)</span><br><span class="line">                    break;</span><br><span class="line">                pid = fork();</span><br><span class="line">                if ( !pid )</span><br><span class="line">                    goto __afl_fork_resume;</span><br><span class="line">                </span><br><span class="line">                write(WRITE_PIPE_FD, &amp;pid, 4);</span><br><span class="line">                waitpid(pid, &amp;_afl_temp, 0); // (7)</span><br><span class="line">                write(WRITE_PIPE_FD, &amp;_afl_temp, 4);</span><br><span class="line">            &#125;</span><br><span class="line">            _exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">__afl_fork_resume: // (8)</span><br><span class="line">    // 蒐集 coverage</span><br><span class="line">    edge = _afl_prev_loc ^ bbid;</span><br><span class="line">    _afl_prev_loc = (_afl_prev_loc ^ edge) &gt;&gt; 1;</span><br><span class="line">	++*(_afl_area_ptr + edge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Target 由fuzzer 透过<code>fork()</code>与<code>execve()</code>执行，而fuzzer 在执行target 前会建立一组pipe (fd 为198, 199)，这样两者就能透过读写pipe 来做沟通(1)。</p>
<p>在<code>main()</code>会第一次呼叫<code>__afl_maybe_log()</code>并做初始化，而function 本身是透过全域变数<code>_afl_area_ptr</code>来判断是否为第一次执行(2)。一开始会先取得fuzzer 建立的shared memory address (3)，用来搜集目标在执行时的coverage。再来会与fuzzer 做handshake (4) 来确保fuzzer 存活，类似于TCP 的三项交握。确定能够与fuzzer 的沟通后准备要开始fuzzing，在(5) 之后的行为会被称作<strong>fork server</strong>，行为如下：</p>
<ul>
<li><p>等待fuzzer 发出指令(6)</p>
</li>
<li><p>&#96;&#96;&#96;<br>fork()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  出一个child process</span><br><span class="line"></span><br><span class="line">  - child process 会继续执行后续的程式码(8)</span><br><span class="line">  - parent process 会等待child process 的结束(7)，并在结束后告知fuzzer</span><br><span class="line"></span><br><span class="line">- child 在之后呼叫`_afl_maybe_log()`只会执行(8) 之后的行为</span><br><span class="line"></span><br><span class="line">而(8) 之后做的就是在**搜集coverage**。实际上AFL 纪录coverage 时是以**edge**为单位，而edge 是由两个basic block 所组成。举个简单的例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A –&gt; B<br>B –&gt; A</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果是以basic block 为单位，则两者对于B coverage 的定义只在于有没有执行到，因此coverage 相同；但以edge 为单位，(A, B) 与(B, A) 会被分别视为两个不同执行单位，因此会产生出不同的coverage，这样的好处在于coverage 本身能考虑到上下文，而不是只考虑执行多少程式码。</span><br><span class="line"></span><br><span class="line">AFL 将当前basic block id (变数`bbid`) 与前一次的basic block id 做运算，取得edge value 后记录在shared memory 当中。当child 执行结束，parent 会从`waitpid()`离开(7)，并通知fuzzer 这次执行已经结束，而fuzzer 就能透过shared memory 的纪录来分析这次执行的效果。</span><br><span class="line"></span><br><span class="line"># [Day 7] 近代fuzzer 始祖- AFL - Fuzzer - 初始化&amp; Fuzzing loop</span><br><span class="line"></span><br><span class="line">前几天已经介绍afl 在编译时会对target 做怎样的处理，并且了解fuzzing 时target 是如何与fuzzer 做互动。接下来要讲afl fuzzer 本身的行为，包含初始化环境、做mutation、分析coverage、产生下个input 等等，由于afl-fuzz 的原始码afl-fuzz.c 行数高达八千多行，不可能将每个部分的细节都说明的很清楚，因此请有兴趣者在自己追追看。</span><br><span class="line"></span><br><span class="line">下方介绍皆以Day4 执行fuzzer 时使用的指令为例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>~&#x2F;AFL&#x2F;afl-fuzz -i in -o out .&#x2F;test</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 支援参数</span><br><span class="line"></span><br><span class="line">在`main()`的一开始afl-fuzz 就会处理使用者传入的参数，较重要的options 有：</span><br><span class="line"></span><br><span class="line">- -i - 存放test case 的资料夹</span><br><span class="line">- -o - 存放执行结果资料夹</span><br><span class="line">- -f - 从指定档案读input</span><br><span class="line">- -t - timeout，执行时间超过的话会被kill 掉</span><br><span class="line">- -m - memory limit，执行时所能使用记忆体上限</span><br><span class="line">- -d - skip deterministic，也就是mutation 阶段跳过预设的处理</span><br><span class="line">- -n - 对没有插桩的target 做fuzzing</span><br><span class="line"></span><br><span class="line">### 初始化</span><br><span class="line"></span><br><span class="line">处理完传入的参数后，会初始化fuzzing 时的环境，呼叫的function 以及其行为可以参考注解，后续对于重要的function 会在拿出来讲：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>int main(int argc, char** argv)<br>{<br>  &#x2F;&#x2F; 除了註冊收到終止請求的 signal 時會執行的 handler，因為介面是 TUI，<br>  &#x2F;&#x2F; 因此也會註冊關於調整 window 大小的 signal。<br>  &#x2F;&#x2F; handler 一共分成 stop, timeout, resize, skip<br>  setup_signal_handlers();<br>  &#x2F;&#x2F; 保存執行指令，也就是 “&#x2F;home&#x2F;user&#x2F;AFL&#x2F;afl-fuzz -i in -o out .&#x2F;test”<br>  save_cmdline(argc, argv);<br>  &#x2F;&#x2F; 透過 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern 調整 dump 形式<br>  &#x2F;&#x2F; 確保不會額外執行其他 program<br>  check_crash_handling();<br>  &#x2F;&#x2F; 預設 CPU 會動態根據執行狀況來分配 frequency，可能會有其他影響，因此改成 performance<br>  &#x2F;&#x2F; performance - Run the CPU at the maximum frequency<br>  check_cpu_governor();<br>  &#x2F;&#x2F; 設置與 target 共享的 shared memory，<br>  &#x2F;&#x2F; 在 fuzzer 中對應的變數為 “trace_bits”，<br>  &#x2F;&#x2F; 也代表該次執行的 coverage 會存在此變數當中<br>  setup_shm();<br>  &#x2F;&#x2F; 建立 output 資料夾<br>  setup_dirs_fds();<br>  &#x2F;&#x2F; 從 input 資料夾取得 test case 並加到 queue 當中<br>  &#x2F;&#x2F; 每個 seed file 對應到一個 queue entry<br>  &#x2F;&#x2F; 指向第一個 entry 的變數為 “queue_top”<br>  read_testcases();<br>  &#x2F;&#x2F; 為所有 queue entry 對應的檔案建立一個 hardlink<br>  pivot_inputs();<br>  &#x2F;&#x2F; 預設 fuzzer 會餵 input 到 target 的 stdin<br>  &#x2F;&#x2F; 這邊可以設置將 input 以檔案的形式傳給 target<br>  &#x2F;&#x2F; 將參數名稱設為 @@ 即可<br>  detect_file_args(argv + optind + 1);<br>  &#x2F;&#x2F; 建立指定 “<output_dir>&#x2F;.cur_input” 作為目前 fuzzing 的 input file<br>  &#x2F;&#x2F; fd 對應到的變數名稱為 “out_fd”<br>  setup_stdio_file();<br>  &#x2F;&#x2F; 檢查 target binary 有無插樁<br>  check_binary(argv[optind]);<br>  &#x2F;&#x2F; 將所有 seed 作為 input 執行 target<br>  &#x2F;&#x2F; 確保程式原本的 seed 不會讓程式一執行就出現異常<br>  use_argv &#x3D; argv + optind;<br>  perform_dry_run(use_argv);<br>  &#x2F;&#x2F; 印出初始化的 TUI 統計畫面，準備開始 fuzzing<br>  show_init_stats();<br>  …<br>}</output_dir></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Fuzzing Loop</span><br><span class="line"></span><br><span class="line">当环境初始化后，就会进入fuzzing 无穷回圈：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>while (1) {<br>  &#x2F;&#x2F; 選出在 queue 當中 “favor” 的 entry，<br>  &#x2F;&#x2F; 並標示其他 entry 為 “redundant”<br>  cull_queue();</p>
<p>  &#x2F;&#x2F; 如果目前已經將 queue entry 都執行過一次，<br>  &#x2F;&#x2F; 則進入下一個 queue cycle<br>  if (!queue_cur)<br>  {<br>  queue_cycle++;<br>  queue_cur &#x3D; queue;<br><br>  &#x2F;&#x2F; 變數 seek_to 紀錄下一個 cycle 需要 skip 的 entry 數量<br>  while (seek_to) {<br>      seek_to–;<br>      queue_cur &#x3D; queue_cur-&gt;next;<br>  }<br>  &#x2F;&#x2F; 印出 TUI 畫面<br>  show_stats();<br>  &#x2F;&#x2F; 這次 queue entry 的數量跟上個 cycle 相同，<br>  &#x2F;&#x2F; 就會在 mutation 時使用 splicing<br>  if (queued_paths &#x3D;&#x3D; prev_queued) {<br>      use_splicing &#x3D; 1;<br>  }<br><br>  prev_queued &#x3D; queued_paths;<br>  }</p>
<pre><code> // 執行一次 fuzzing
</code></pre>
<p>  fuzz_one(use_argv);<br>  &#x2F;&#x2F; 如果執行過程中，fuzzer 本身出現狀況，或是 target 有奇怪的問題，<br>  &#x2F;&#x2F; 就會跳出 while loop 停止 fuzzing<br>  if (stop_soon) break;</p>
<p>  &#x2F;&#x2F; 取得下一個 queue entry 來執行<br>  queue_cur &#x3D; queue_cur-&gt;next;</p>
</li>
</ul>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">到此就是afl-fuzz.c 的`main()`所做的行为，再来会需要关心`fuzz_one()`是怎么将当前的queue entry，从取得档案内容喂入target binary，到对content 做mutation，最后判断执行结果好坏。</span><br><span class="line"></span><br><span class="line"># [Day 8] 近代fuzzer 始祖- AFL - Fuzzer - 校正&amp; Fork server</span><br><span class="line"></span><br><span class="line">由于所有处理的逻辑都写在function `fuzz_one()`，导致此function 多达1600 行，因此会拆成多个部分介绍，其中有些处理会包含机率，通常是以if-else condition 如`UR(100) &lt; 99`(1% 的机率会发生)的形式出现，不过有些行为掺杂机率只是为了增加随机性，并不影响核心概念，因此会斟酌删减程式码，方便读者阅读。</span><br><span class="line"></span><br><span class="line">### 开档与校正</span><br><span class="line"></span><br><span class="line">`fuzz_one()`在一开始会对要执行的input 做校正(calibrate)，确保input 本身没有什么问题：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static u8 fuzz_one(char** argv)<br>{<br>    &#x2F;&#x2F; 變數 “pending_favored” 儲存了走到新 coverage 的 input 個數，<br>    &#x2F;&#x2F; 代表還有比較好的 seed 可以用來執行，因此先略過 “被 fuzz 過” 或<br>    &#x2F;&#x2F; “非 favored” 的 seed<br>    if (pending_favored &amp;&amp; (queue_cur-&gt;was_fuzzed || !queue_cur-&gt;favored))<br>        return 1;</p>
<pre><code>// 取出 queue entry 對應到的檔案內容，並且使用 memory 的方式存取
fd = open(queue_cur-&gt;fname, O_RDONLY);
len = queue_cur-&gt;len;
orig_in = in_buf = mmap(0, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
close(fd);

   // 如果過去有發生 calibrate 沒有成功的情況，在此會執行一次
if (queue_cur-&gt;cal_failed) &#123;
    res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - 1, 0);
    // 如果發生錯誤，代表此 seed 有問題
    if (res == FAULT_ERROR)
        FATAL(&quot;Unable to execute target application&quot;);
&#125;
...
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`calibrate_case()`的功能一共有两个： 1. 执行target 建立fork server、2. 测试新的input 是否有问题。昨天有介绍在`main()`时会呼叫`perform_dry_run()`检查程式是否存在明显问题，一执行就出现异常，而背后就是呼叫`calibrate_case()`来检测input 的执行结果，并且同时也唤起fork server。</span><br><span class="line"></span><br><span class="line">`calibrate_case()`的程式码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static u8 calibrate_case(char** argv, struct queue_entry* q, u8* use_mem,<br>                         u32 handicap, u8 from_queue)<br>{<br>    &#x2F;&#x2F; 如果 TUI 顯示在 calibration mode，就代表正在執行此 function<br>    stage_name &#x3D; “calibration”;</p>
<pre><code>// fork server 還沒被喚起，因此先初始化 fork server
if (!forksrv_pid)
    init_forkserver(argv);

// 校正次數預設為 8 次
for (stage_cur = 0; stage_cur &lt; 8; stage_cur++) &#123;
    show_stats();
    // 將資料寫到檔案 &quot;&lt;output_dir&gt;/.cur_input&quot; 當中
    write_to_testcase(use_mem, q-&gt;len);
    // 執行 target binary
    fault = run_target(argv, use_tmout);
    
    // 如果初次執行 (!stage_cur) 就沒有任何 coverage (!count_bytes(trace_bits))，
    // 代表程式本身有問題
    if (!stage_cur &amp;&amp; !count_bytes(trace_bits))
        goto abort_calibration;

    // 藉由 checksum 能迅速得知執行結果是否相同
    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);
    
    // 如果同個 input 走到的 coverage 與第一次不相同
    if (q-&gt;exec_cksum != cksum) &#123;
        // 變數 &quot;virgin_bits&quot; 紀錄執行到現在還沒走到的 coverage，
        // has_new_bits() 會回傳是否這次執行是否產生新的結果
        // return value == 1 代表只改變某 edge 走到的次數
        // return value == 2 代表有走到新的 edge
        hnb = has_new_bits(virgin_bits);
        if (hnb &gt; new_bits) new_bits = hnb; // 只存最好的結果
                
        // 如果並非第一次執行，則會檢查過去第一次跟這次執行結果是否有差
        // 變數 &quot;var_bytes&quot; 會紀錄哪些 coverage 可能是包含隨機性，
        // 像是根據執行時間會有不同的結果，因此如果有差的話，
        // 則會將對應的位址設為 1，代表是 variable (多變的)
        if (q-&gt;exec_cksum) &#123;
            for (u32 i = 0; i &lt; MAP_SIZE; i++) &#123;
                if (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i])
                    var_bytes[i] = 1;
            &#125;
            var_detected = 1;
        &#125; else &#123;
            // 如果是第一次執行，儲存到 queue entry 的結構當中，
            // 並且將 bitmap 的結果存到變數 &quot;first_trace&quot;
            q-&gt;exec_cksum = cksum;
            memcpy(first_trace, trace_bits, MAP_SIZE);
        &#125;
    &#125;
&#125;

// 蒐集 performace 相關的資料
q-&gt;exec_us     = (stop_us - start_us) / 8; // 平均執行時間
q-&gt;bitmap_size = count_bytes(trace_bits); // 走到的 coverage 大小
q-&gt;cal_failed  = 0; // 標記成校正成功

// 藉由統計資料產生分數，代表此 input 的價值
// 如果第 i 個 edge 同時有兩個 queue entry 能走到，
// 則變數 top_rated[i] 就會紀錄 &quot;執行時間*檔案大小&quot; 比較小的 entry
update_bitmap_score(q);
</code></pre>
<p>abort_calibration:<br>    &#x2F;&#x2F; 有走到新的 edge，並且過去沒有紀錄有新 coverage 過<br>    &#x2F;&#x2F; 更新 q-&gt;has_new_cov 為 1，代表此 entry 會走到新的 edge<br>    if (new_bits &#x3D;&#x3D; 2)<br>        q-&gt;has_new_cov &#x3D; 1;</p>
<pre><code>// 標註此 entry 執行的 edge 具有隨機性
if (var_detected)
    mark_as_variable(q);
    
return fault;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">虽然目前还不知道function`run_target()`的行为以及回传值，不过可以猜测function 本身在执行target，而回传值则是执行结果。</span><br><span class="line"></span><br><span class="line">### 唤起fork server</span><br><span class="line"></span><br><span class="line">`init_forkserver()`在`main()`初始化时会被间接呼叫到。首先会建立用于跟child 沟通的pipe，然后由child 执行target，再来就如同Day6 所介绍，target 会先在插桩产生的程式码中执行fork server，并且等待fuzzer 下指令。</span><br><span class="line"></span><br><span class="line">`init_forkserver()`的程式码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>void init_forkserver(char** argv)<br>{<br>    int st_pipe[2]; &#x2F;&#x2F; status pipe<br>       int ctl_pipe[2]; &#x2F;&#x2F; control pipe</p>
<pre><code>// 建立 status pipe 與 control pipe
pipe(st_pipe);
pipe(ctl_pipe);
forksrv_pid = fork();

if (!forksrv_pid) &#123; // child process
    // 將 stdout 與 stderr 導向 /dev/null，代表不接收任何輸出
    dup2(dev_null_fd, 1);
    dup2(dev_null_fd, 2);
    // 將 input file 導向 stdin，代表輸入資料為檔案內容
    dup2(out_fd, 0);

    dup2(ctl_pipe[0], 198); // 只留 control read
    dup2(st_pipe[1], 199); // 只留 status write

    // 執行 target binary
    execv(target_path, argv);
&#125;

fsrv_ctl_fd = ctl_pipe[1]; // 只留 control write
fsrv_st_fd  = st_pipe[0]; // 只留 status read

// 等待來自 target 的 handshake
// 如果能成功收到 4 bytes value，代表正常啟動
rlen = read(fsrv_st_fd, &amp;status, 4);
if (rlen == 4)
    return;

// error handle
...
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在已经知道fuzzer 是在什么时间点执行target 来唤起fork server，并且也知道了fuzzer 是如何检测初次执行的input。再来会介绍校正input 后的fuzzer 会做什么行为，并揭开校正时执行的function`run_target()`其神秘面纱。</span><br><span class="line"></span><br><span class="line"># [Day 9] 近代fuzzer 始祖- AFL - Fuzzer - Trimming &amp; Mutation</span><br><span class="line"></span><br><span class="line">今天主要会介绍trimming 以及mutation，并了解function`run_target()`的执行过程，而`run_target()`其实是用来通知fork server 执行target 的重要function。</span><br><span class="line"></span><br><span class="line">### 执行target</span><br><span class="line"></span><br><span class="line">Function`run_target()`在多个档案中都有定义(afl-fuzz.c, afl-analyze.c ...)，不过在afl-fuzz 使用的是afl-fuzz.c 当中的`run_target()`，因此如果读者在自己追code 时请注意不要看错地方。</span><br><span class="line"></span><br><span class="line">`run_target()`会传递指令给fork server 执行target，并且等待执行结束，再来用结束的状态来判断是否发生异常，最后回传状态结果，程式码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static u8 run_target(char** argv, u32 timeout)<br>{<br>    &#x2F;&#x2F; 初始化紀錄 coverage 的 memory<br>    memset(trace_bits, 0, MAP_SIZE);<br>    MEM_BARRIER();</p>
<pre><code>// 發送指令給 fork server，而 fork server 在收到指令後會
// fork 一個 child 來執行原本的程式邏輯
write(fsrv_ctl_fd, &amp;prev_timed_out, 4);
read(fsrv_st_fd, &amp;child_pid, 4);

// 設置 timer，如果 timeout 就會收到 SIGALRM，
it.it_value.tv_sec = (timeout / 1000);
it.it_value.tv_usec = (timeout % 1000) * 1000;
setitimer(ITIMER_REAL, &amp;it, NULL);

// 等待執行結束
read(fsrv_st_fd, &amp;status, 4));

// 分類各個 edge 走到的次數，簡單化運算操作
// 0 -&gt; class1, ..., 3 -&gt; class4, 4~7 -&gt; class5, ...
// 同個 class 的 edge 數會被設為相同，
// 舉例來說分類到 class5 的 edge 次數都會被設為 8
classify_counts((u64*)trace_bits);

// 如果 target 是因為 signal 所終止，
// 有可能就是觸發 segfault，或者是 ASAN 發現異常
if (WIFSIGNALED(status)) &#123;
    kill_signal = WTERMSIG(status);
    // 如果不是因為 timeout 而被 kill，就代表發生 crash
    if (child_timed_out &amp;&amp; kill_signal == SIGKILL) return FAULT_TMOUT;
    return FAULT_CRASH;
&#125;

// MSAN 發現異常
if (uses_asan &amp;&amp; WEXITSTATUS(status) == MSAN_ERROR) &#123;
    kill_signal = 0;
    return FAULT_CRASH;
&#125;

return FAULT_NONE;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Trimming</span><br><span class="line"></span><br><span class="line">`fuzz_one()`在校正完input 后，会准备开始执行mutation，不过在此之前还会先将input 做修剪(trim)，删除input 当中不必要的部分：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 如果該 input 過去沒有做修剪<br>if (!queue_cur-&gt;trim_done) {<br>    u8 res &#x3D; trim_case(argv, queue_cur, in_buf);<br>    queue_cur-&gt;trim_done &#x3D; 1;<br>}</p>
<p>&#x2F;&#x2F; 將修剪後的 input 複製到 <output_dir>&#x2F;.cur_input 當中<br>memcpy(out_buf, in_buf, queue_cur-&gt;len);</output_dir></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Trimming 的目的为在不影响coverage 的情况下，将input 大小缩小以减少overhead，举例来说，如果input &quot;AAAABBBBCCCC&quot; 与&quot;AAAACCCC&quot; 所产生的coverage 相同，则会将&quot;AAAABBBBCCCC&quot; trim 成&quot;AAAACCCC&quot; 。</span><br><span class="line"></span><br><span class="line">`trim_case()`负责处理trimming，程式码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static u8 trim_case(char** argv, struct queue_entry* q, u8* in_buf)<br>{<br>    &#x2F;&#x2F; 如果 input 本身資料就不多，則不需要刪減<br>    if (q-&gt;len &lt; 5) return 0;</p>
<pre><code>// 求得 input len 的 pow of 2
len_p2 = next_p2(q-&gt;len);

// 移除的大小至少要為 4，也就是 trim 的最小單位
// 而後以 input len 的 pow of 2 將 input 拆成 16 份，
// 每份的長度則是 &quot;remove_len&quot;
remove_len = MAX(len_p2 / 16, 4);

while (remove_len &gt;= MAX(len_p2 / 16, 4)) &#123;
    // 初始的刪除位置為 &quot;remove_len&quot;
    u32 remove_pos = remove_len;
    
    while (remove_pos &lt; q-&gt;len) &#123;
        // 因為當初長度有做 pow of 2 ceiling，
        // 因此有可能最後一個部分的大小不足 &quot;remove_len&quot;
        u32 trim_avail = MIN(remove_len, q-&gt;len - remove_pos);
        u32 cksum;

        // 將 input 內容根據要刪除的位置與大小，將資料複製到
        // &lt;output_dir&gt;/.cur_input 對應到的 fd 當中
        write_with_gap(in_buf, q-&gt;len, remove_pos, trim_avail);
        
        // 執行 target 並取得 bitmap 的 checksum
        fault = run_target(argv, exec_tmout);
        cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);

        // 兩次的 coverage 相同，代表 input 可以做修剪
        if (cksum == q-&gt;exec_cksum) &#123;
            // 變數 &quot;move_tail&quot; 計算出來後為後面沒有更新的資料的大小
            u32 move_tail = q-&gt;len - remove_pos - trim_avail;
            // 更新 input 內容與長度
            q-&gt;len -= trim_avail;
            // 將沒更新到的資料複製到前面，覆蓋掉已經被 trim 的資料
            memmove(in_buf + remove_pos, in_buf + remove_pos + trim_avail, 
                    move_tail);
            // 更新 pow of 2 長度
            len_p2  = next_p2(q-&gt;len);
            // 需要更新至檔案當中
            needs_write = 1;
        &#125; else
            // 不相同的話則嘗試刪除下一個部分
            remove_pos += remove_len;
    &#125;
    // 降低粒度，做更細緻的 trim
    remove_len &gt;&gt;= 1;
&#125;

// 如果 input 已經被修剪，則同步至檔案當中
if (needs_write) &#123;
    s32 fd;
    unlink(q-&gt;fname);
    fd = open(q-&gt;fname, O_WRONLY | O_CREAT | O_EXCL, 0600);
    ck_write(fd, in_buf, q-&gt;len, q-&gt;fname);
    close(fd);
&#125;

return fault;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`trim_case()`的程式码相较复杂，不过核心概念就是尝试将input 每固定长度删除，如果coverage 相同就可以将其移除，借此减少input 大小。</span><br><span class="line"></span><br><span class="line">### Mutation</span><br><span class="line"></span><br><span class="line">当trimming 确保input 只留下重要的部分后，会进入到mutation stage，也就是反覆执行&quot;更新input、执行target、评估结果&quot; 的循环。 AFL 的mutation strategy 会先让新的input 执行固定的变异，之后才会做真正随机化的更新，因此又被称作**deterministic** step。</span><br><span class="line"></span><br><span class="line">各变异的名称与行为如下：</span><br><span class="line"></span><br><span class="line">- bitflip1/1：一次翻1 bit</span><br><span class="line">- bitflip2/1：一次翻2 bits</span><br><span class="line">- bitflip4/1：一次翻4 bits</span><br><span class="line">- bitflip8/8：一次翻1 byte</span><br><span class="line">- bitflip16/8：一次翻2 bytes</span><br><span class="line">- bitflip32/8：一次翻4 bytes</span><br><span class="line">- Arith8/8：对每byte 做+-1, +-2, +-3, ..., +-35</span><br><span class="line">- Arith16/8：对每2 bytes 做+-1, +-2, +-3, ..., +-35</span><br><span class="line">- Arith32/8：对每4 bytes 做+-1, +-2, +-3, ..., +-35</span><br><span class="line">- interest8/8：将某byte 替换成interest value 的值，而interest value 是edge case 的value，如MAX_INT、0</span><br><span class="line">- interest16/8：将某2bytes 替换成interest value 的值</span><br><span class="line">- interest32/8：将某4bytes 替换成interest value 的值</span><br><span class="line"></span><br><span class="line">最后一组的变异是将随机执行上述介绍的方法，因此很有可能产生差异很大的input：</span><br><span class="line"></span><br><span class="line">- havoc：会对input 做许多次随机mutation</span><br><span class="line"></span><br><span class="line">而因为变异很多，因此`fuzz_one()`的程式码大部分都在处理mutation，不过基本上概念大同小异，只需要知道其中一个怎么做就好，以下为执行操作&quot;bitflip2/1&quot; 的程式码片段：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; queued_path 為所有 queued testcases 的數量<br>&#x2F;&#x2F; unique_crashes 為獨立的 crash 數量<br>new_hit_cnt &#x3D; queued_paths + unique_crashes;<br>&#x2F;&#x2F; stage 名稱<br>stage_name  &#x3D; “bitflip 2&#x2F;1”;<br>&#x2F;&#x2F; 每 2 bits 為一組，一共有幾組<br>stage_max   &#x3D; (len &lt;&lt; 3) - 1;<br>&#x2F;&#x2F; 紀錄原先的 fuzzing 狀態 (testcases 數量 + crash 數量)<br>orig_hit_cnt &#x3D; new_hit_cnt;</p>
<p>for (stage_cur &#x3D; 0; stage_cur &lt; stage_max; stage_cur++) {<br>    &#x2F;&#x2F; 翻過去<br>    FLIP_BIT(out_buf, stage_cur);<br>    FLIP_BIT(out_buf, stage_cur + 1);</p>
<pre><code>// 執行 target
common_fuzz_stuff(argv, out_buf, len);

// 翻回來
FLIP_BIT(out_buf, stage_cur);
FLIP_BIT(out_buf, stage_cur + 1);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 更新在 bitflip 2&#x2F;1 的過程中是否有新的 crash，<br>&#x2F;&#x2F; 或是新增了新的 testcases<br>new_hit_cnt &#x3D; queued_paths + unique_crashes;</p>
<p>&#x2F;&#x2F; 更新此 stage 的成效 (new - old)<br>stage_finds[STAGE_FLIP2]  +&#x3D; new_hit_cnt - orig_hit_cnt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mutation 的程式码非常直观且好懂，不过仍有些变异需要比较复杂的处理，在此就不多做说明，至于`common_fuzz_stuff()`是怎么执行的，会在明天做介绍。</span><br><span class="line"></span><br><span class="line"># [Day 10] 近代fuzzer 始祖- AFL - Fuzzer - Interesting input</span><br><span class="line"></span><br><span class="line">每次做完mutation 都会执行`common_fuzz_stuff()`，而此function 会呼叫`run_target()`以及`save_if_interesting()`来执行target 并分析，程式码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>EXP_ST u8 common_fuzz_stuff(char** argv, u8* out_buf, u32 len)<br>{<br>    u8 fault;<br>    &#x2F;&#x2F; 將 mutated 的 input data 寫入 <output_dir>&#x2F;.cur_input<br>    &#x2F;&#x2F; 所對應到的 fd<br>    write_to_testcase(out_buf, len);<br>    &#x2F;&#x2F; 執行 target<br>    fault &#x3D; run_target(argv, exec_tmout);<br>    &#x2F;&#x2F; 執行 save_if_interesting() 分析此次 input data<br>    save_if_interesting(argv, out_buf, len, fault);<br>    return 0;<br>}</output_dir></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Interesting input</span><br><span class="line"></span><br><span class="line">先前已经介绍过`run_target()`，在此我们关注的是`save_if_interesting()`，其功能是用来保存interesting input，并做更深入的分析，程式码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static u8 save_if_interesting(char** argv, void* mem, u32 len, u8 fault)<br>{<br>    &#x2F;&#x2F; 如果此 input 有走到新的 coverage，或是走到<br>    &#x2F;&#x2F; 更多次 edge，就表示為 interesting，否則直接<br>    &#x2F;&#x2F; return<br>    if (!(hnb &#x3D; has_new_bits(virgin_bits)))<br>      return 0;</p>
<pre><code>// 為其產生檔案名稱並加到 queue 當中
fn = alloc_printf(&quot;%s/queue/id:%06u,%s&quot;, out_dir, queued_paths,
                  describe_op(hnb));
add_to_queue(fn, len, 0);
// 新進來的 queue entry 會是 queue_top，更新
// 其 checksum
queue_top-&gt;exec_cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);
// 校正此 input，檢測是否正常
res = calibrate_case(argv, queue_top, mem, queue_cycle - 1, 0);
// 保存至檔案當中
fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, 0600);
ck_write(fd, mem, len, fn);
close(fd);
keeping = 1;

// 檢查是否發生 fault
switch (fault) &#123;
    // 執行期間出現 timeout
    case FAULT_TMOUT:
        // timeout 異常發生太多次，直接不理會
        if (unique_hangs &gt;= 500) return keeping;
        
        // 簡化 coverage
        // 如果過去有相同 coverage 造成 timeout，
        // 則不額外保存 timeout input
        simplify_trace((u64*)trace_bits);
        if (!has_new_bits(virgin_tmout))
            return keeping;
        
        // 重新執行一次，確保 timeout 確實會發生
        write_to_testcase(mem, len);
        new_fault = run_target(argv, hang_tmout);
        
        // 重新執行的結果是 crash
        if (new_fault == FAULT_CRASH) goto keep_as_crash;
        // 重新執行後什麼也不是
        if (new_fault != FAULT_TMOUT) return keeping;
        // 產生檔案名字
        fn = alloc_printf(&quot;%s/hangs/id:%06llu,%s&quot;, out_dir,
                          unique_hangs, describe_op(0));
        unique_hangs++;
        break;

    case FAULT_CRASH:
    keep_as_crash:
        total_crashes++;
        // crash 異常發生太多次，直接不理會
        if (unique_crashes &gt;= 5000) return keeping;
        // 簡化 coverage
        simplify_trace((u64*)trace_bits);
        // 如果過去有相同 coverage 造成 crash，
        // 則不額外保存 crash input
        if (!has_new_bits(virgin_crash))
            return keeping;

        // 產生檔案名字
        fn = alloc_printf(&quot;%s/crashes/id:%06llu,sig:%02u,%s&quot;, out_dir,
                          unique_crashes, kill_signal, describe_op(0));
        unique_crashes++;
        break;

    default: return keeping;
&#125;

// 保存 crash input 到 output directory 當中
fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, 0600);
ck_write(fd, mem, len, fn);
close(fd);
ck_free(fn);

return keeping;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281052231.png)</span><br><span class="line"></span><br><span class="line">到此已经介绍完整个AFL fuzzer 的架构，这里可以做个总结：</span><br><span class="line"></span><br><span class="line">- 编译时afl-gcc 以及afl-as 会为target 的原始码做插桩，插桩的内容为fork server 以及搜集coverage 的程式码</span><br><span class="line">- afl-fuzzer 在初始环境后会先唤醒fork server，并检测target 在一般input 中是否能正常执行</span><br><span class="line">- 进入fuzzing loop，重复将每个input 取出，并透过trimming 阶段取出input 最重要的部分</span><br><span class="line">- 对input 做一系列的变异，并从中找出interesing input，如果有造成crash 则另外存成档案</span><br><span class="line"></span><br><span class="line">### Conclusion</span><br><span class="line"></span><br><span class="line">虽然做法直观，但其中存在许多可以优化的地方，像是对于不同的程式来说，各个变异所造成的效果可能不相同，因此可以变异本身也可以有优先顺序。 Fuzzing 相关的论文皆在提出诸如此类的优化，毕竟fuzzing 都会跑很久，并且每秒执行的次数也很多，即使只能增加一些效率，但累积下来的差异还是很可观的。</span><br><span class="line"></span><br><span class="line">在后续的文章中，会带读者了解除了userspace 之外的fuzzer，像是kernel fuzzer 或是hypervisor，同时也包含一些经典的fuzzer 优化方式。</span><br><span class="line"></span><br><span class="line"># [Day 11] Coverage-guided fuzzer - 对source-code 程式做模糊测试</span><br><span class="line"></span><br><span class="line">俗称的feedback-driven fuzzer 是指fuzzer 并非漫无目的的随机输入与mutation，而是透过执行结果的好坏来引导下次产生或挑选的输出。根据feedback 的来源大概可以分成两种：</span><br><span class="line"></span><br><span class="line">- Coverage-guided - 由程式码覆盖率作为引导，执行到越多程式码越好</span><br><span class="line">- Data-driven (?) - 让特定资料或是变数的状态变化越多越好</span><br><span class="line"></span><br><span class="line">大部分fuzzer 都是coverage-guided fuzzer，目的是要想办法在一定时间内执行越多次、走到越多程式码，而目前较有代表性的为：</span><br><span class="line"></span><br><span class="line">- [AFLplusplus](https://github.com/AFLplusplus/AFLplusplus) - 基于AFL 的fuzzing 框架，综合了各个论文的研究结果，拥有不同的mutator、scheduling algorithm 可以选择。此外也提供较好的整合介面，让研究人员可以测试自己的优化方法</span><br><span class="line"></span><br><span class="line">反之Data-driven fuzzer 会观察程式在执行过程中的资料变化、不同输入所造成的更动，而具体的资料会因为实作的不同而有所不同，像是变数值的变化、或者是记忆体的使用状况，举例来说：</span><br><span class="line"></span><br><span class="line">- [INVSCOV](https://www.usenix.org/conference/usenixsecurity21/presentation/fioraldi) - 程式执行中总是会有一些Invariant (不变量) 基本上不大会变动，而这篇论文提出的方法就是以让这些不变量变动为目标做fuzzing</span><br><span class="line"></span><br><span class="line">后续有可能会介绍到data-driven 的fuzzer，不过在此还是著重在介绍较为主流的coverage-guided fuzzer。</span><br><span class="line"></span><br><span class="line">### Source-code program</span><br><span class="line"></span><br><span class="line">前几天介绍到的AFL 是对有原始码的程式做插桩，借此搜集coverage，这种有原始码的程式称作**source-code program**。但现实中没有原始码的程式其实占了大多数，因为基本上程式都算是企业的资产，包含实作方法以及使用技术，因此不太可能开放原始码，而这种只有执行档，没有原始码的程式就称作**binary-only program**。</span><br><span class="line"></span><br><span class="line">#### llvm pass</span><br><span class="line"></span><br><span class="line">对于source-code program 是使用插桩来搜集coverage，最直观的方式就是在组译前加上一段程式码来纪录执行状态，不过如果使用llvm toolchain 来编译程式，则可以使用**llvm pass**来做更细粒度的插桩。 LLVM 在编译一支程式会经过以下步骤：</span><br><span class="line"></span><br><span class="line">![img](https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281053476.png)</span><br><span class="line"></span><br><span class="line">- Frontend (前端) - 会将C source code 转成llvm IR，比较熟悉的llvm 前端为**clang**</span><br><span class="line">- Midend - 将llvm IR 做各种优化与操作，这些处理被称作llvm pass。结束后会再把llvm IR 转成assembly code</span><br><span class="line">- Backend (后端) - 将assembly code 组译成executable，也就是可以用来执行的格式</span><br><span class="line"></span><br><span class="line">llvm pass 可以做到的插桩粒度从function level 到instruction level 都可以，也可以针对一些条件来决定插桩程式码的执行与否。自己定义的llvm pass 会在第一轮的最后一个被执行，在上图即为&quot;Pass.so&quot;，也就代表传入自定义的llvm pass 是已经被优化完的IR，实际上如果想要在优化前先执行自己的pass 也可以。</span><br><span class="line"></span><br><span class="line">llvm pass 因为容易上手，因此当今fuzzer 虽然会支援gcc，不过推荐使用llvm compiler 来编译。接下来会简单介绍一下llvm pass 的使用方法与说明，使用的环境为llvm-14。</span><br><span class="line"></span><br><span class="line">hello.cpp 的内容用于定义llvm pass，内容参考[官方文件](https://llvm.org/docs/WritingAnLLVMPass.html)：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; include llvm pass 相關的 header file<br>#include “llvm&#x2F;Pass.h”<br>#include “llvm&#x2F;IR&#x2F;Function.h”<br>#include “llvm&#x2F;Support&#x2F;raw_ostream.h”<br>#include “llvm&#x2F;IR&#x2F;LegacyPassManager.h”<br>#include “llvm&#x2F;Transforms&#x2F;IPO&#x2F;PassManagerBuilder.h”</p>
<p>&#x2F;&#x2F; include 的 function 都在 llvm namespace<br>using namespace llvm;</p>
<p>&#x2F;&#x2F; 定義一個 anonymous namespace<br>&#x2F;&#x2F; 讓所有 declaration 只會在目前的 file 中被看到<br>namespace {<br>    &#x2F;&#x2F; 定義 FunctionPass 的 subclass<br>    struct Hello : public FunctionPass {<br>        &#x2F;&#x2F; 屬於 Pass 的 ID<br>        static char ID;<br>        Hello() : FunctionPass(ID) {}<br>        &#x2F;&#x2F; override 原本 FunctionPass 的抽象 method，<br>        &#x2F;&#x2F; 可以定義要做插樁的行為<br>        virtual bool runOnFunction(Function &amp;F) {<br>            errs() &lt;&lt; “Hello: “;<br>            errs() &lt;&lt; F.getName() &lt;&lt; ‘\n’;<br>            return false;<br>        }<br>    };<br>}</p>
<p>&#x2F;&#x2F; 初始化 pass ID<br>char Hello::ID &#x3D; 0;<br>&#x2F;&#x2F; 註冊 pass，參數定義如下：<br>&#x2F;&#x2F; 傳入 command argument 時使用 “hello” 來辨識<br>&#x2F;&#x2F; 此 pass 的名稱為 “Hello World Pass”<br>static RegisterPass<Hello> X(“hello”, “Hello World Pass”);</Hello></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">编译shared library 的指令：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>llvm-config-14 --bindir</code>&#x2F;clang -c hello.cpp -o hello.o <code>llvm-config-14 --cppflags</code> -fPIC -fno-rtti<br><code>llvm-config-14 --bindir</code>&#x2F;clang -shared hello.o -o hello.so <code>llvm-config-14 --ldflags</code> -fPIC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 会产生shared library hello.so</span><br><span class="line"></span><br><span class="line">test.c 为目标程式：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;stdio.h&gt;</p>
<p>int main ()<br>{<br>    printf(“Hello LLVM!\n”);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">编译target 指令：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="產生-llvm-IR"><a href="#產生-llvm-IR" class="headerlink" title="產生 llvm IR"></a>產生 llvm IR</h1><p>clang -c -emit-llvm -o test.bc test.c</p>
<h1 id="將-IR-餵入-optimizer-並執行-pass，"><a href="#將-IR-餵入-optimizer-並執行-pass，" class="headerlink" title="將 IR 餵入 optimizer 並執行 pass，"></a>將 IR 餵入 optimizer 並執行 pass，</h1><h1 id="執行的過程中就會印出-“Hello-main”-的字串，代表"><a href="#執行的過程中就會印出-“Hello-main”-的字串，代表" class="headerlink" title="執行的過程中就會印出 “Hello: main” 的字串，代表"></a>執行的過程中就會印出 “Hello: main” 的字串，代表</h1><h1 id="llvm-正在處理當前的-hello-pass"><a href="#llvm-正在處理當前的-hello-pass" class="headerlink" title="llvm 正在處理當前的 hello pass"></a>llvm 正在處理當前的 hello pass</h1><h1 id="處理完的-IR-會輸出到-hello-ll"><a href="#處理完的-IR-會輸出到-hello-ll" class="headerlink" title="處理完的 IR 會輸出到 hello.ll"></a>處理完的 IR 會輸出到 hello.ll</h1><p>opt-14  -enable-new-pm&#x3D;0 -load .&#x2F;hello.so -hello -o hello.ll &lt; test.bc</p>
<h1 id="產生執行檔"><a href="#產生執行檔" class="headerlink" title="產生執行檔"></a>產生執行檔</h1><p>clang -o hello hello.ll</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果有兴趣的读者可以参考[AFL 的llvm pass](https://github.com/google/AFL/blob/master/llvm_mode/afl-llvm-pass.so.cc)，能更了解如何实际运用在fuzzer 上。</span><br><span class="line"></span><br><span class="line">#### gcc</span><br><span class="line"></span><br><span class="line">除了最原本的做法，gcc 似乎在instrumentation 也提供了许多可以使用的选项，这方面我不是很熟，可以参考[官方文件](https://gcc.gnu.org/onlinedocs/gcc-8.1.0/gcc/Instrumentation-Options.html)的说明，不过如果是对每个basic block 做插桩，在编译时可以使用option `-fsanitize-coverage=trace-pc`，此option 能允许程式当中的每个basic block 在执行前会呼叫function `__sanitizer_cov_trace_pc()`，因此在此function 当中定义搜集coverage 的行为，就能做到插桩的效果。不过不仅是gcc 可以使用，这个选项llvm 也有支援，所以不能够算专属于gcc。</span><br><span class="line"></span><br><span class="line">下面以简单的范例介绍此option 要怎么使用，以及使用时可能会遇到的问题。 test.c 为要被插桩的target，trace.c 则定义function`__sanitizer_cov_trace_pc()`的内容。</span><br><span class="line"></span><br><span class="line">test.c 的程式码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;stdio.h&gt;</p>
<p>&#x2F;&#x2F; 實際定義會在 trace.c<br>&#x2F;&#x2F; 如果在此宣告，則 __sanitizer_cov_trace_pc() 本身又會呼叫<br>&#x2F;&#x2F; __sanitizer_cov_trace_pc()，會造成無窮遞迴而 crash<br>void __sanitizer_cov_trace_pc(void);</p>
<p>static void fun1(int a)<br>{<br>    printf(“call fun1, and a &#x3D; %d\n”, a);<br>}</p>
<p>int main(int argc, char **argv)<br>{<br>    if (argc &#x3D;&#x3D; 1) {<br>        puts(“argc &#x3D;&#x3D; 1”);<br>        fun1(1);<br>    } else {<br>        puts(“argc !&#x3D; 1”);<br>        fun1(0);<br>    }<br>    return 0;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">trace.c 的程式码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;stdio.h&gt;</p>
<p>&#x2F;&#x2F; 插樁會呼叫到的 function，透過 compiler 的<br>&#x2F;&#x2F; built-in function 取得 return address 並印出<br>void __sanitizer_cov_trace_pc(void)<br>{<br>    printf(“call from %p\n”, __builtin_extract_return_addr (__builtin_return_address (0)));<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">编译指令：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>gcc -c -fsanitize-coverage&#x3D;trace-pc -o test.o test.c<br>gcc -c -o trace.o trace.c<br>gcc -o test test.o trace.o</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$ .&#x2F;test<br>call from 0x5555555551b2<br>call from 0x5555555551bd<br>argc &#x3D;&#x3D; 1<br>call from 0x55555555517d<br>call fun1, and a &#x3D; 1<br>call from 0x5555555551fb<br>call from 0x555555555205</p>
<p>$ .&#x2F;test 2<br>call from 0x5555555551b2<br>call from 0x5555555551dd<br>argc !&#x3D; 1<br>call from 0x55555555517d<br>call fun1, and a &#x3D; 0<br>call from 0x5555555551fb<br>call from 0x555555555205</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">唯一有差别的是当参数只有一个时，`if (argc == 1)`会成立，因此`0x5555555551bd`执行第一段程式码，对应到的位址为；参数不只一个时，会执行第二段程式码，对到的位址为`0x5555555551dd`。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">今天介绍了source-code fuzzing 能够利用什么方法来搜集coverage，而明天会介绍在没有source code 的情况下，binary-only fuzzing 是如何取得coverage 的。</span><br><span class="line"></span><br><span class="line">### 参考资源</span><br><span class="line"></span><br><span class="line">- [Understanding kcov – play with -fsanitize-coverage=trace-pc from the user space](https://davejingtian.org/2017/06/01/understanding-kcov-play-with-fsanitize-coveragetrace-pc-from-the-user-space/)</span><br><span class="line">- [LLVM 写一个pass - 教学入门篇](https://kitoslab.blogspot.com/2012/10/llvm-pass.html)</span><br><span class="line">- [Writing an LLVM Pass](https://llvm.org/docs/WritingAnLLVMPass.html)</span><br><span class="line"></span><br><span class="line"># [Day 12] Coverage-guided fuzzer - 对binary-only 程式做模糊测试- Static binary rewriting</span><br><span class="line"></span><br><span class="line">### Binary-only program</span><br><span class="line"></span><br><span class="line">在没有source code 的情况下，binary-only fuzzing 是取得coverage 的方法大概可以分成三种，并且每种做法并不完全等于下方所介绍的，根据实作还是会有些许差异：</span><br><span class="line"></span><br><span class="line">- **Static binary rewriting** - 静态对binary 做更新</span><br><span class="line"></span><br><span class="line">  - Trampoline (detouring) - 将basic block 开头的instruction 改成</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>&#123;call,jmp&#125; XXXX
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">跳到指定位址，而在位址</span><br><span class="line"></span><br></pre></td></tr></table></figure>
XXXX
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    会放搜集coverage 的instruction，同时也还会执行/修补原本的程式片段，最后在跳回去</span><br><span class="line"></span><br><span class="line">    - 代表性的论文/作法有：[以执行档改写支援涵盖率导引之模糊测试](https://ndltd.ncl.edu.tw/cgi-bin/gs32/gsweb.cgi/login?o=dnclcdr&amp;s=id=&quot;106NCTU5726039&quot;.&amp;searchmode=basic)</span><br><span class="line"></span><br><span class="line">  - Reassemble - 想办法把要新增的instruction 加到原本的basic block 当中，难处在于要怎么重组原本的指令，使其可以做到原程式逻辑，并且instruction 的增加不会影响程式执行</span><br><span class="line"></span><br><span class="line">    - 代表性的论文/作法有： Uroboros、Ramblr 以及[RetroWrite](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9152762) (由旧到新)</span><br><span class="line"></span><br><span class="line">- **Dynamic binary instrumentation (DBI)** - 透过emulator 可以模拟程式执行的功能，特别在把basic block 转成IR 之前，先多插一段搜集coverage 的IR，之后动态做模拟执行时就能知道执行了哪些basic block</span><br><span class="line"></span><br><span class="line">  - 代表性的论文/作法有： Intel Pin、DynamoRIO、QEMU</span><br><span class="line"></span><br><span class="line">- **Other** - 使用一些较为特别的技巧做插桩</span><br><span class="line"></span><br><span class="line">  - Hardware support - 指令集支援，例如Intel-PT</span><br><span class="line">  - ptrace - 能单步执行process 并取得执行状态</span><br><span class="line">  - signal handler - 可以在程式中注册接受到interrupt 时会做的行为</span><br><span class="line"></span><br><span class="line">动态与静态各自的优点(对方的缺点) 在于：</span><br><span class="line"></span><br><span class="line">- 动态： 可以得知资料的状态，像是结构或是型态，结果较为准确</span><br><span class="line">- 静态： 只做一次分析与修正，就能省下后续执行所造成的overhead</span><br><span class="line"></span><br><span class="line">这几天的文章会详细介绍各机制与其实作方法，而今天会先介绍**Static binary rewriting**。</span><br><span class="line"></span><br><span class="line">### Static binary rewriting - Trampoline</span><br><span class="line"></span><br><span class="line">Trampoline 的中文意思为弹跳床，而在资讯术语中通常是指：改变原本的程式流程，让程式在执行到一半时先跳去做其他的subroutine，而subroutine 除了会执行使用者指定的程式码外，也可能会将原程式要做的事给做完，最后subroutine 执行完后在跳回去。</span><br><span class="line"></span><br><span class="line">举个简单的例子，原本程式的执行流程为`orig`，而`1`就是使用`C`这个trampoline 来搜集coverage，并在执行结束后回到原先的执行流程；`2`的做法会直接替代掉原程式流程，直接在`C`当中做完`B`的行为。</span><br><span class="line"></span><br><span class="line">![img](https://github.com/u1f383/fuzzing-learning-in-30-days/raw/main/images/12-0.png)</span><br><span class="line"></span><br><span class="line">如果是以程式码为例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<p>A:<br>    mov rax, 1<br>    mov rbx, 2<br>    mov rcx, 3<br>    ret</p>
<p>B:<br>    mov rax, 4<br>    mov rbx, 5<br>    mov rcx, 6<br>    ret</p>
<p>C:<br>    mov rdx, qword ptr [rip + test_counter]<br>    inc rdx<br>    mov qword ptr [rip + test_counter], rdx<br>    ret</p>
<p>test_counter: .long 0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在不考虑`call C`与`mov rax, &#123;1,4&#125;`instruction 长度，以及呼叫function 所造成的side-effect 的情况下，作法`1`会长得像：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A:<br>    call C<br>    mov rbx, 2<br>    mov rcx, 3<br>    ret</p>
<p>B:<br>    call C<br>    mov rbx, 5<br>    mov rcx, 6<br>    ret</p>
<p>C:<br>    mov rdx, qword ptr [rip + test_counter]<br>    inc rdx<br>    mov qword ptr [rip + test_counter], rdx<br>    ret</p>
<p>test_counter: .long 0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">做法`2`则是：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A:<br>    jmp C_1</p>
<p>B:<br>    jmp C_2</p>
<p>C_1:<br>    mov rdx, qword ptr [rip + test_counter]<br>    inc rdx<br>    mov qword ptr [rip + test_counter], rdx<br>    mov rax, 1<br>    mov rbx, 2<br>    mov rcx, 3<br>    ret</p>
<p>C_2:<br>    mov rdx, qword ptr [rip + test_counter]<br>    inc rdx<br>    mov qword ptr [rip + test_counter], rdx<br>    mov rax, 4<br>    mov rbx, 5<br>    mov rcx, 6<br>    ret</p>
<p>test_counter: .long 0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">而其中的难点也十分明显，像是：</span><br><span class="line"></span><br><span class="line">- 当instruction`call`或`jmp`超过原本function 的长度时该怎么处理？</span><br><span class="line">- 如果function 中执行记忆体存取，那trampoline 中的记忆体offset 要怎么算？</span><br><span class="line">- trampoline 的程式码要放在哪？</span><br><span class="line">- 要怎么执行到被patch 掉的instruction，像是作法`1`当中的`mov rax, &#123;1,4&#125;`？</span><br><span class="line"></span><br><span class="line">诸如此类的问题还有很多，因此这部分也是有许多人在做相关的研究。</span><br><span class="line"></span><br><span class="line">### Static binary rewriting - Reassemble</span><br><span class="line"></span><br><span class="line">Reassemble 的核心概念在：把原本的assembly code 做修改后，还能重新组译回可执行档，并且程式执行的流程仍与原本相同。</span><br><span class="line"></span><br><span class="line">![img](https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281059819.png)</span><br><span class="line"></span><br><span class="line">图片取自RetroWrite 的论文，大致代表整个ressembly 的处理过程，下面会以RetroWrite 的执行流程为例，并额外做一些补充：</span><br><span class="line"></span><br><span class="line">1. **Preprocessing** - 从assembly code 当中取出text 与data section，RetroWrite 额外需要取得symbol 与relocation 的资讯</span><br><span class="line"></span><br><span class="line">2. Symbolization</span><br><span class="line"></span><br><span class="line">    \- 利用relocation 资讯，将text 与data 中的一些资料转换成</span><br><span class="line"></span><br><span class="line">   label</span><br><span class="line"></span><br><span class="line">   纪录起来，藉由label 能够在做完插桩后重新计算label 的value。资料的种类可以大致分成以下几种：</span><br><span class="line"></span><br><span class="line">   - Control Flow - 像是call 或jump 相关的instruction，会被转成是&quot;code-to-code&quot; 的label</span><br><span class="line">   - PC-relative addresses - 一些instruction 会以当前执行到的记忆体位址作为基础，加上一个offset 来取得指定记忆体并作存取，会被label 成&quot;code-to-code&quot; 或是&quot;code-to -data&quot;</span><br><span class="line">   - Data relocation - 在执行期间才会得知资料存放的记忆体位址，这种资料会被label 为&quot;data-to-data&quot; 或&quot;data-to-code&quot;</span><br><span class="line"></span><br><span class="line">3. Instrumentation</span><br><span class="line"></span><br><span class="line">    \- 插桩在原本的assembly code 当中</span><br><span class="line"></span><br><span class="line">   - 有些方法会把assembly code 转换成更高阶的IR 在做插桩与优化，像是[ZAFL](https://www.usenix.org/system/files/sec21fall-nagy.pdf)</span><br><span class="line"></span><br><span class="line">4. Optimization</span><br><span class="line"></span><br><span class="line">    \- 分析插桩结果是否会有side-effects，如果有的话尝试解决</span><br><span class="line"></span><br><span class="line">   - 通常判断提出的方法可不可行，取决于能不能有效处理side-effects</span><br><span class="line"></span><br><span class="line">5. **Reassembly** - 产生插桩完的binary</span><br><span class="line"></span><br><span class="line">如果想知道更详细的RetroWrite 实作方式，可以参考发表者在演讲时所做的简报[连结](https://hexhive.epfl.ch/publications/files/19CCC-presentation.pdf)。</span><br><span class="line"></span><br><span class="line"># [Day 13] Coverage-guided fuzzer - 对binary-only 程式做模糊测试- Dynamic binary instrumentation (上)</span><br><span class="line"></span><br><span class="line">今天会介绍使用fuzzer 如何使用Intel Pin 与QEMU 在动态期间做插桩，借此取得程式执行的coverage。</span><br><span class="line"></span><br><span class="line">### Dynamic binary instrumentation</span><br><span class="line"></span><br><span class="line">#### QEMU</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QEMU 是一个用来模拟程式执行的程式，大多应用在测试程式执行，或者是执行不同指令集的程式，实际上又分成full system emulation 跟user-mode emulation，前者为包含作业系统执行的模拟，后者只是单纯模拟程式的执行。 QEMU 的codebase 很大，并且由多个components 所组成，因此没办法做很详细的介绍，不过大致上的流程为：</span><br><span class="line"></span><br><span class="line">1. 初始化- 像是记忆体管理等等一定会使用到的服务，必须在执行程式之前就做初始化</span><br><span class="line">2. 处理执行档- 读入使用者指定的执行档、parse metadata</span><br><span class="line">3. 模拟执行- QEMU 提供多种模拟方式，不过基本上都很复杂。最直观的模拟方法为：一行行抓出instruction，看instruction 的mnemonic 为何(eg `add`, `sub`)，执行对应的handler，记录执行结果，执行下一个instruction</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">AFL 的binary-only 模式底层就是用QEMU emulator 实作，不过QEMU 预设是不会纪录coverage，因此会需要修改QEMU 的原始码来做到这件事，patch 的diff 在[AFL repo qemu_mode/patches](https://github.com/google/AFL/tree/master/qemu_mode/patches)底下，这边会简单介绍patch 更动了哪些地方。</span><br><span class="line"></span><br><span class="line">有一些diff 档案的内容就只是做一些初始化与设定而已，用简单的文字来叙述即可：</span><br><span class="line"></span><br><span class="line">- syscall.diff - 更新在kill 时的处理，确保送`SIGABRT`时forkserver thread 会接收到</span><br><span class="line">- configure.diff / memfd.diff - 使用memory mapping 而不是memory fd</span><br><span class="line">- elfload.diff - 在parsing 执行档的metadata 时，会初始化`afl_start_code`以及`afl_end_code`，代表要被搜集coverage 的程式码位址的开头与结尾，`afl_entry_point`则是纪录程式的第一个入口</span><br><span class="line"></span><br><span class="line">**cpu-exec.diff**：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>— qemu-2.10.0-rc3-clean&#x2F;accel&#x2F;tcg&#x2F;cpu-exec.c	2017-08-15 11:39:41.000000000 -0700<br>+++ qemu-2.10.0-rc3&#x2F;accel&#x2F;tcg&#x2F;cpu-exec.c	2017-08-22 14:34:55.868730680 -0700<br>@@ -36,6 +36,8 @@<br> #include “sysemu&#x2F;cpus.h”<br> #include “sysemu&#x2F;replay.h”</p>
<p>+#include “..&#x2F;patches&#x2F;afl-qemu-cpu-inl.h”</p>
<p> typedef struct SyncClocks {<br>@@ -144,6 +146,8 @@<br>     int tb_exit;<br>     uint8_t *tb_ptr &#x3D; itb-&gt;tc_ptr;</p>
<ul>
<li>AFL_QEMU_CPU_SNIPPET2;</li>
<li><pre><code>qemu_log_mask_and_addr(CPU_LOG_EXEC, itb-&gt;pc,
                       &quot;Trace %p [%d: &quot; TARGET_FMT_lx &quot;] %s\n&quot;,
                       itb-&gt;tc_ptr, cpu-&gt;cpu_index, itb-&gt;pc,
</code></pre>
</li>
</ul>
<p>@@ -365,6 +369,7 @@<br>             if (!tb) {<br>                 tb &#x3D; tb_gen_code(cpu, pc, cs_base, flags, 0);</p>
<ul>
<li><pre><code>           AFL_QEMU_CPU_SNIPPET1;
       &#125;
</code></pre>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `AFL_QEMU_CPU_SNIPPET2`macro 会在执行到程式码位址等同于`afl_entry_point`时唤醒fork server，此外还用来记录新的coverage</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  AFL_QEMU_CPU_SNIPPET1</span><br></pre></td></tr></table></figure>

<p>  macro 会提前通知QEMU 做translation，避免fork 后还要做一次，产生额外的overhead</p>
<ul>
<li>QEMU translation 会把原本程式的assembly code 转为QEMU 看得懂的形式(IR)，之后模拟执行时就会比较快</li>
</ul>
<p><strong>afl-qemu-cpu-inl.h</strong>定义fuzzing 相关的处理，以下撷取比较重要的部分做介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 通知 tsl (translation handler) 要對指定 basic block 做 translate</span><br><span class="line">#define AFL_QEMU_CPU_SNIPPET1 do &#123; \</span><br><span class="line">    afl_request_tsl(pc, cs_base, flags); \</span><br><span class="line">  &#125; while (0)</span><br><span class="line"></span><br><span class="line">// 如果執行到 entry point 就喚起 fork server，</span><br><span class="line">// 並且紀錄 coverage</span><br><span class="line">#define AFL_QEMU_CPU_SNIPPET2 do &#123; \</span><br><span class="line">    if(itb-&gt;pc == afl_entry_point) &#123; \</span><br><span class="line">      afl_setup(); \</span><br><span class="line">      afl_forkserver(cpu); \</span><br><span class="line">    &#125; \</span><br><span class="line">    afl_maybe_log(itb-&gt;pc); \</span><br><span class="line">  &#125; while (0)</span><br><span class="line"></span><br><span class="line">static inline void afl_maybe_log(abi_ulong cur_loc) &#123;</span><br><span class="line"></span><br><span class="line">    static __thread abi_ulong prev_loc;</span><br><span class="line">    // 避免紀錄不在 start ~ end 範圍的 coverage</span><br><span class="line">    if (cur_loc &gt; afl_end_code || cur_loc &lt; afl_start_code || !afl_area_ptr)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    cur_loc  = (cur_loc &gt;&gt; 4) ^ (cur_loc &lt;&lt; 8);</span><br><span class="line">    cur_loc &amp;= MAP_SIZE - 1;</span><br><span class="line"></span><br><span class="line">	// 透過 probabilistic instrumentation 做優化</span><br><span class="line">    if (cur_loc &gt;= afl_inst_rms) return;</span><br><span class="line">    afl_area_ptr[cur_loc ^ prev_loc]++;</span><br><span class="line">    prev_loc = cur_loc &gt;&gt; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS 由于当初开发时使用的QEMU 已经过旧，因此在编译时会遇到一些错误，所以读者想尝试将afl qemu mode 跑起来，可以参考这个<a target="_blank" rel="noopener" href="https://github.com/google/AFL/issues/41">issue</a>，底下的留言有附上修改过的patch。</p>
<h4 id="Intel-Pin"><a href="#Intel-Pin" class="headerlink" title="Intel Pin"></a>Intel Pin</h4><p>Intel Pin 是Intel 自己推出的DBI framework，支援Linux 与Windows 底下的x86、x86_64、IA-64 指令集的执行档。官方已经将其包装成可以简单使用的interface，因此让开发人员能迅速开发出客制化的动态分析。 Intel Pin 使用了JIT compiler，动态在原本的程式码中新增插桩程式码，并在最后执行，整个执行的流程如下(图片撷取自文章底部所推荐的投影片)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281101656.png" alt="img"></p>
<p>其架构就像一个小型的VM，将喂入的执行档做处理，并在程式码中做插桩，最后丢给JIT compiler 编译并执行。</p>
<blockquote>
<p>JIT compiler 为Just-In-Time compiler，程式内本身会执行类似compiler 的行为，能够在执行期间产生assembly code 并执行。</p>
</blockquote>
<p>接下来会介绍实际上要怎么使用Intel Pin 这个工具。</p>
<hr>
<p>首先到<a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-binary-instrumentation-tool-downloads.html">官网</a>下载原始码，解压缩后根据档案README 执行以下指令做测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd source/tools/SimpleExamples</span><br><span class="line"># 官方文件是使用 opcodemix.so，</span><br><span class="line"># 不過我認為 malloctrace.so 的實作比較好懂</span><br><span class="line">make obj-intel64/malloctrace.so</span><br><span class="line"># 指定使用 malloctrace.so 此 library 作為工具來分析</span><br><span class="line">../../../pin -t obj-intel64/malloctrace.so -o output -- /bin/ls</span><br></pre></td></tr></table></figure>

<p>使用malloctrace 可以知道在执行到function<code>malloc()</code>或是<code>free()</code>时所传入的参数，并将分析结果存放在档案output，内容长得像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">malloc(0x1d8)</span><br><span class="line">  returns 0x56337a8422a0</span><br><span class="line">malloc(0x78)</span><br><span class="line">  returns 0x56337a842480</span><br><span class="line">malloc(0x400)</span><br><span class="line">  returns 0x56337a842500</span><br><span class="line">free(0x56337a842480)</span><br><span class="line">free(0x56337a842500)</span><br><span class="line">free(0x56337a8422a0)</span><br><span class="line">free(0)</span><br><span class="line">malloc(0x5)</span><br><span class="line">  returns 0x56337a842910</span><br><span class="line">free(0x56337a842910)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>而malloctrace.so 的原始码为malloctrace.cpp，程式做的事情十分直观，以下搭配注解做介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;pin.H&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">using std::cerr;</span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line">using std::hex;</span><br><span class="line">using std::ios;</span><br><span class="line">using std::string;</span><br><span class="line"></span><br><span class="line">// malloc 與 free 的 function name</span><br><span class="line">#define MALLOC &quot;malloc&quot;</span><br><span class="line">#define FREE &quot;free&quot;</span><br><span class="line"></span><br><span class="line">// 用於輸出的 file stream</span><br><span class="line">std::ofstream TraceFile;</span><br><span class="line"></span><br><span class="line">// 定義參數，格式為：</span><br><span class="line">// (參數模式, 類別名稱, 參數 option, default value, 說明)</span><br><span class="line">KNOB&lt; string &gt; KnobOutputFile(KNOB_MODE_WRITEONCE, &quot;pintool&quot;, &quot;o&quot;, &quot;malloctrace.out&quot;, &quot;specify trace file name&quot;);</span><br><span class="line"></span><br><span class="line">INT32 Usage()</span><br><span class="line">&#123;</span><br><span class="line">    cerr &lt;&lt; &quot;This tool produces a trace of calls to malloc.\n&quot;</span><br><span class="line">            &quot;\n&quot;;</span><br><span class="line">    cerr &lt;&lt; KNOB_BASE::StringKnobSummary();</span><br><span class="line">    cerr &lt;&lt; endl;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ==== 輸出結果時使用到的 function ====</span><br><span class="line">// 印出執行執行 function &quot;name&quot; 時所傳入的參數 &quot;size&quot;</span><br><span class="line">VOID Arg1Before(CHAR* name, ADDRINT size) &#123; TraceFile &lt;&lt; name &lt;&lt; &quot;(&quot; &lt;&lt; size &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">// 呼叫完後會回到哪個位址</span><br><span class="line">VOID MallocAfter(ADDRINT ret) &#123; TraceFile &lt;&lt; &quot;  returns &quot; &lt;&lt; ret &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">VOID Image(IMG img, VOID* v)</span><br><span class="line">&#123;</span><br><span class="line">    // 找到 &quot;malloc&quot; instruction Routine</span><br><span class="line">    RTN mallocRtn = RTN_FindByName(img, MALLOC);</span><br><span class="line">    if (RTN_Valid(mallocRtn))</span><br><span class="line">    &#123;</span><br><span class="line">        RTN_Open(mallocRtn); // 開啟 &quot;malloc&quot; routine</span><br><span class="line">        // 在 malloc 執行前 (IPOINT_BEFORE) 執行給定的 function pointer (Arg1Before)</span><br><span class="line">        // 參數傳遞的形式為： TYPE1, VALUE1, TYPE2, VALUE2, ..., IARG_END</span><br><span class="line">        RTN_InsertCall(mallocRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT, MALLOC, IARG_FUNCARG_ENTRYPOINT_VALUE, 0,</span><br><span class="line">                       IARG_END);</span><br><span class="line">        // 在 malloc 執行後 (IPOINT_AFTER) 執行 MallocAfter()</span><br><span class="line">        RTN_InsertCall(mallocRtn, IPOINT_AFTER, (AFUNPTR)MallocAfter, IARG_FUNCRET_EXITPOINT_VALUE, IARG_END);</span><br><span class="line">        RTN_Close(mallocRtn); // 關閉 &quot;malloc&quot; routine</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 找到 &quot;free&quot; instruction Routine</span><br><span class="line">    RTN freeRtn = RTN_FindByName(img, FREE);</span><br><span class="line">    if (RTN_Valid(freeRtn))</span><br><span class="line">    &#123;</span><br><span class="line">        RTN_Open(freeRtn); // 開啟 &quot;free&quot; routine</span><br><span class="line">        // 在 free 執行前執行 Arg1Before()</span><br><span class="line">        RTN_InsertCall(freeRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT, FREE, IARG_FUNCARG_ENTRYPOINT_VALUE, 0,</span><br><span class="line">                       IARG_END);</span><br><span class="line">        RTN_Close(freeRtn); // 關閉 &quot;free&quot; routine</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 將 file stream 關閉的 function</span><br><span class="line">// 在 main() 當中會呼叫 PIN_AddFiniFunction() 註冊此</span><br><span class="line">// function 為 fini function</span><br><span class="line">VOID Fini(INT32 code, VOID* v) &#123; TraceFile.close(); &#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化 Pin 的 symbol table</span><br><span class="line">    PIN_InitSymbols();</span><br><span class="line"></span><br><span class="line">    // 初始化 Pin system</span><br><span class="line">    if (PIN_Init(argc, argv))</span><br><span class="line">        return Usage();</span><br><span class="line"></span><br><span class="line">    // 初始化 file stream 與 output format</span><br><span class="line">    TraceFile.open(KnobOutputFile.Value().c_str());</span><br><span class="line">    TraceFile &lt;&lt; hex;</span><br><span class="line">    TraceFile.setf(ios::showbase);</span><br><span class="line">    cout &lt;&lt; hex;</span><br><span class="line">    cout.setf(ios::showbase);</span><br><span class="line"></span><br><span class="line">    // 註冊 callback 處理，當載入 image 時會被呼叫到</span><br><span class="line">    IMG_AddInstrumentFunction(Image, 0);</span><br><span class="line">    </span><br><span class="line">    // 註冊程式結束時會被呼叫的</span><br><span class="line">    PIN_AddFiniFunction(Fini, 0);</span><br><span class="line">    </span><br><span class="line">    // 開始執行指定的 binary</span><br><span class="line">    PIN_StartProgram();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>以上即是QEMU 以及Intel Pin，两者都能够做到在动态执行期间新增程式码，搜集coverage。如果对于Intel Pin 有兴趣，想深入了解的话，投影片<a target="_blank" rel="noopener" href="https://cs-uob.github.io/COMSM0049/slides/week4/intro-DynAnalysi-Pin-intro.pdf">Dynamic Analysis: Introduction to dynamic binary instrumentation and Intel Pin</a>讲得非常详细，读者可以参考看看。</p>
<h1 id="Day-14-Coverage-guided-fuzzer-对binary-only-程式做模糊测试-Dynamic-binary-instrumentation-下"><a href="#Day-14-Coverage-guided-fuzzer-对binary-only-程式做模糊测试-Dynamic-binary-instrumentation-下" class="headerlink" title="[Day 14] Coverage-guided fuzzer - 对binary-only 程式做模糊测试- Dynamic binary instrumentation (下)"></a>[Day 14] Coverage-guided fuzzer - 对binary-only 程式做模糊测试- Dynamic binary instrumentation (下)</h1><p>昨天介绍了AFL 的QEMU mode 以及Intel Pin，让使用者可以在没有原始码的情况下搜集coverage，今天要介绍的是Dynamorio，此工具可以说是目前动态插桩综合评价最好也是最复杂的。</p>
<p>执行环境为DynamoRIO-Linux-9.0.19244，可以从repo 上的<a target="_blank" rel="noopener" href="https://github.com/DynamoRIO/dynamorio/releases">release page</a>下载，部分资源参考官方的<a target="_blank" rel="noopener" href="https://dynamorio.org/page_slides.html">教学文件</a>。文章<a target="_blank" rel="noopener" href="https://jackkuo.org/post/dynamorio_introduction/">JackKuo’s Blog</a>对DynamoRIO 也有做详细的介绍，如果读者有兴趣可以参考看看。</p>
<h4 id="DynamoRIO"><a href="#DynamoRIO" class="headerlink" title="DynamoRIO"></a>DynamoRIO</h4><p>DynamoRIO 为支援Android、Linux 与Windows 三个平台的DBI framework，指令集则支援IA-32、AMD64、ARM 以及AArch64。 DynamoRIO 提供了一些interface 给开发人员使用，透过这些interface 可以做到：</p>
<ul>
<li>分析程式行为</li>
<li>测量效能</li>
<li>插桩</li>
<li>优化程式</li>
</ul>
<p>在Windows 上并没有办法很好的实作插桩与forkserver 等*nix-specific 设计，因此<a target="_blank" rel="noopener" href="https://github.com/googleprojectzero/winafl">WinAFL</a> (AFL in Windows) 使用了DynamoRIO 做动态插桩来搜集coverage，并且成效很好，也证明了DynamoRIO 能同时兼具效能与实用。</p>
<p>整个DynamoRIO 系统与一般的dynamic binary translation (DBT) 系统相同，读入target binary 后做处理，包含translation、optimization 等等，最后模拟执行。官方提供的运作流程大致如下，：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281102990.png" alt="img"></p>
<ul>
<li>DynamoRIO 将原本的程式码(application code) 作为input，分成一个个basic block 来处理( <code>A</code>, <code>C</code>, …)</li>
<li>每个basic block 会透过执行顺序串起来，像是<code>A</code>会呼叫到<code>C</code>，因此执行完<code>A</code>后就直接跳到<code>C</code>执行</li>
<li>最后透过一些优化技巧，例如将basic block cache 起来，常执行到的程式码就能迅速被取出执行</li>
</ul>
<p>因为提供的工具与参数太多，以下只会介绍DynamoRIO 的其中一个工具：**drrun **的使用方法与机制，不过目前其无法在ubuntu22.04 上执行，细节可以参考此<a target="_blank" rel="noopener" href="https://github.com/DynamoRIO/dynamorio/issues/5437">issue</a>。</p>
<hr>
<p><strong>drrun</strong>可以对执行档(application) 做模拟执行，除此之外也能指定执行期间使用特定的插桩处理(client)，执行流程大致如下：</p>
<ul>
<li>Stage 1 - 对原本的程式码做修改</li>
<li>Stage 2 - 分析Stage1 产生出来的程式码，并将分析结果传给Stage3，又称作application analysis</li>
<li>Stage 3 - 基于Stage2 传来的分析结果，在先前注册component 做插桩，又称作instrumentation insertion</li>
</ul>
<p>用来测试的执行档test.c 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// gcc -g -o test test.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	puts(&quot;OWO&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，在DynamoRIO 的目录底下执行下列指令，即可透过预设提供的inscount client 观察程式执行总共使用到的instruction 数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -c: 註冊一個 client</span><br><span class="line"># libinscount.so: 計算總共執行 instruction 數量的 client</span><br><span class="line">./bin64/drrun -c samples/bin64/libinscount.so -- ./test</span><br></pre></td></tr></table></figure>

<p>libinscount.so 的原始码档名为inscount.cpp，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;dr_api.h&quot;</span><br><span class="line">#include &quot;drmgr.h&quot;</span><br><span class="line">#include &quot;droption.h&quot;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 提供額外的參數，舉例來說如果要使用參數 &quot;only_from_app&quot; 的話，執行：</span><br><span class="line">// ./bin64/drrun -c samples/bin64/libinscount.so --only_from_app -- ./test</span><br><span class="line">// 就只會追蹤 application (執行檔) 本身的所執行到的程式碼</span><br><span class="line">static droption_t&lt;bool&gt; only_from_app(</span><br><span class="line">    DROPTION_SCOPE_CLIENT, &quot;only_from_app&quot;, false,</span><br><span class="line">    &quot;Only count app, not lib, instructions&quot;,</span><br><span class="line">    &quot;Count only instructions in the application itself, ignoring instructions in &quot;</span><br><span class="line">    &quot;shared libraries.&quot;);</span><br><span class="line"></span><br><span class="line">// counter 變數</span><br><span class="line">static uint64 global_count;</span><br><span class="line">// 此 function 用來增加總共執行的 instruction 次數</span><br><span class="line">static void inscount(uint num_instrs)</span><br><span class="line">&#123;</span><br><span class="line">    global_count += num_instrs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DR_EXPORT void</span><br><span class="line">dr_client_main(client_id_t id, int argc, const char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	// parse 到 &quot;--&quot; 之前的參數，作為 client 的參數</span><br><span class="line">	droption_parser_t::parse_argv(DROPTION_SCOPE_CLIENT, argc, argv, NULL, NULL);</span><br><span class="line">    // 初始化 dr manager</span><br><span class="line">    drmgr_init();</span><br><span class="line"></span><br><span class="line">	// 如果 &quot;only_from_app&quot; option 有設置，會另外處理，不過在此不討論</span><br><span class="line">    if (only_from_app.get_value()) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">	// 註冊執行結束會被呼叫的 callback function</span><br><span class="line">    dr_register_exit_event(event_exit);</span><br><span class="line">    // 註冊 stage2, 3 的 callback function</span><br><span class="line">    // 參數為：analysis_func, insertion_func, priority</span><br><span class="line">    // analsis_func 即為 application analysis (stage 2)</span><br><span class="line">    // insertion_func 即為 instrumentation insertion (stage 3)</span><br><span class="line">    drmgr_register_bb_instrumentation_event(event_bb_analysis, event_app_instruction, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 單純執行 dr manager 的 exit function</span><br><span class="line">static void event_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    drmgr_exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static dr_emit_flags_t</span><br><span class="line">event_bb_analysis(void *drcontext, void *tag, instrlist_t *bb, bool for_trace,</span><br><span class="line">                  bool translating, void **user_data)</span><br><span class="line">&#123;</span><br><span class="line">    // 計算 basic block 的 instruction 數量</span><br><span class="line">    bool is_emulation = false;</span><br><span class="line">    // 遍歷 basic block 當中的每個 instruction</span><br><span class="line">    for (instr = instrlist_first(bb), num_instrs = 0; instr != NULL;</span><br><span class="line">         instr = instr_get_next(instr)) &#123;</span><br><span class="line">        // instruction 數量++</span><br><span class="line">        num_instrs++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 將 basic block 當中的 instruction 數量存於 user_data 指向的記憶體位址當中</span><br><span class="line">    *user_data = num_instrs;</span><br><span class="line">    return DR_EMIT_DEFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static dr_emit_flags_t</span><br><span class="line">event_app_instruction(void *drcontext, void *tag, instrlist_t *bb, instr_t *instr,</span><br><span class="line">                      bool for_trace, bool translating, void *user_data)</span><br><span class="line">&#123;</span><br><span class="line">    // 此 basic block 的instruction 數量</span><br><span class="line">    num_instrs = user_data;</span><br><span class="line">    // function iscount() 的呼叫會被插樁在 basic block 的第一個 instruction</span><br><span class="line">    dr_insert_clean_call(..., instrlist_first_app(bb), inscount, ..., num_instrs);</span><br><span class="line">    return DR_EMIT_DEFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上述例子来说，流程会像是：</p>
<ul>
<li>Stage 1 - 其他client 需要更动原本的程式码</li>
<li>Stage 2 - 分析阶段的callback function<code>event_bb_analysis()</code>会计算每个basic block 的instruction 数量</li>
<li>Stage 3 - 插桩阶段的callback function<code>event_app_instruction()</code>会在每个basic block 执行之前呼叫<code>inscount(num_instrs)</code>，累加在全域变数<code>global_count</code>当中</li>
</ul>
<p>除此之外还有追踪syscall 执行的client、追踪记忆体使用状况的client 等等，都存在于目录samples&#x2F;bin64&#x2F;lib 底下。</p>
<hr>
<p>此外，<strong>drrun</strong>的参数<code>-t</code>则是可以使用内建的多种工具，各工具的object file 存放于tools&#x2F; 底下，以下列出常见的使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 需要先執行：apt-get install -y libsnappy-dev</span><br><span class="line"># cache simulator</span><br><span class="line">./bin64/drrun -t drcachesim  -- ./test</span><br><span class="line"></span><br><span class="line"># 偵測一些 memory 相關的問題，像是未初始化、oob read / write</span><br><span class="line">./bin64/drrun -t drmemory  -- ./test</span><br><span class="line"></span><br><span class="line"># 針對特定 function 不斷執行，並整合 drmemory 來偵測記憶體錯誤</span><br><span class="line">./bin64/drrun -t drmemory -batch -fuzz_function main -fuzz_num_iters 10  -- ./test</span><br><span class="line"></span><br><span class="line"># 模擬在比較老舊的 CPU 執行的情況</span><br><span class="line">./bin64/drrun -t drcpusim -cpu PentiumPro -- ./test</span><br><span class="line"></span><br><span class="line"># 蒐集程式執行的 code coverage 狀態，執行後會產生 .log file</span><br><span class="line">./bin64/drrun -t drcov -- ./test</span><br></pre></td></tr></table></figure>

<h1 id="Day-15-Coverage-guided-fuzzer-对binary-only-程式做模糊测试-Other"><a href="#Day-15-Coverage-guided-fuzzer-对binary-only-程式做模糊测试-Other" class="headerlink" title="[Day 15] Coverage-guided fuzzer - 对binary-only 程式做模糊测试- Other"></a>[Day 15] Coverage-guided fuzzer - 对binary-only 程式做模糊测试- Other</h1><p>前面几天介绍的几种对于binary-only program 做fuzzing 方法都能够做大方向的分类，而今天要介绍的方法都不太能分到前面两种，因此特别拿出来做介绍。</p>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><h4 id="Hardware-support"><a href="#Hardware-support" class="headerlink" title="Hardware support"></a>Hardware support</h4><p>一些指令集提供追踪程式特定行为的功能，其中也包含coverage 的资讯，最有名的即是**Intel Processor Trace (Intel-PT)**，linux 作业系统可以透过&#x2F;proc&#x2F;cpuinfo 检查是否支援，如果flags 的栏位中包含<code>intel_pt</code>字串就代表有。</p>
<p>Intel-PT 除了知道程式执行状态，还能指定要搜集的位址范围，<a target="_blank" rel="noopener" href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf">Intel 手册</a>当中有清楚描述Intel-PT 的使用方式以及原理，这里大概介绍一下。首先在使用Intel-PT 前会需要做设定，像是要追踪的instruction、追踪时使用的权限等等，而在执行期间Intel-PT 会将结果按照格式，放在指定的记忆体位址当中，这些资料被称作<strong>packet</strong>，分析这些资料的component 称作<strong>decoder</strong>。</p>
<p>目前Intel-PT 已经被整合到perf_events 的subsystem 当中( <a target="_blank" rel="noopener" href="https://lwn.net/Articles/648154/">Adding Processor Trace support to Linux</a> )，执行框架可以参考<a target="_blank" rel="noopener" href="https://talos-intelligence-site.s3.amazonaws.com/production/document_files/files/000/000/048/original/Go_Speed_Tracer.pdf">Go Speed Tracer</a>投影片的内容：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281103332.png" alt="img"></p>
<ul>
<li>Ring Agent - 透过perf interface 在kernel 设定Intel-PT</li>
<li>Intel CPU 0..n - 产生PT packet</li>
<li>Decoder - 分析PT packet，需要原始档才能知道正确的记忆体结构</li>
</ul>
<p>由于是指令集层的支援，因此如果fuzzer 需要使用Intel-PT，会将相关处理直接写在程式码里面，不像DBI 通常直接使用library 提供的API，不过Intel-PT 有一个官方维护的library，叫做<a target="_blank" rel="noopener" href="https://github.com/intel/libipt">libipt</a>，主要是提供一些<strong>范例使用方法、测试资料</strong>给开发人员参考，以下会由此library 提供的三个工具做介绍，分别为：</p>
<ul>
<li><strong>pttc</strong> - 用来测试trace 的执行结果</li>
<li><strong>ptdump</strong> - packet dumper，读入Intel PT file (.pt) 并产生human-readable 格式的output</li>
<li><strong>ptxed</strong> - trace disassembler，用于重建过去的执行流程</li>
</ul>
<hr>
<p>执行以下指令来建立环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line"># 下載並安裝 Intel X86 Encoder Decoder (Intel XED)</span><br><span class="line">git clone https://github.com/intelxed/xed.git xed</span><br><span class="line">git clone https://github.com/intelxed/mbuild.git mbuild</span><br><span class="line">cd xed</span><br><span class="line">./mfile.py --shared install</span><br><span class="line"></span><br><span class="line">cd ~</span><br><span class="line"># 下載 libipt 並建立輸出資料夾</span><br><span class="line">git clone https://github.com/intel/libipt</span><br><span class="line">cd libipt/ &amp;&amp; mkdir build &amp;&amp; cd build/</span><br><span class="line"># 產生 Makefile，以下需要注意：</span><br><span class="line"># /home/user: 記得改成自己使用者的加目錄</span><br><span class="line"># xed-install-base-2022-09-17-lin-x86-64: 會根據版本不同而有不同檔名</span><br><span class="line">cmake -DXED_INCLUDE=/home/user/xed/kits/xed-install-base-2022-09-17-lin-x86-64/include/xed -DXED_LIBDIR=/home/user/xed/kits/xed-install-base-2022-09-17-lin-x86-64/lib -DPTTC=ON -DPTDUMP=ON -DPTXED=ON ..</span><br><span class="line"># 產生執行檔</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>最后会在libipt&#x2F;build&#x2F;bin 目录底下产生三个执行档： pttc、ptdump 与ptxed。</p>
<p>pttc 能够根据.ptt (pt testing) 档来模拟执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pttc ~/libipt/test/src/loop-tnt.ptt</span><br></pre></td></tr></table></figure>

<p>loop-tnt.ptt 的档案内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">; Test a simple for loop</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">org 0x100000</span><br><span class="line">bits 64</span><br><span class="line"></span><br><span class="line">; @pt p1: psb()</span><br><span class="line">; @pt p2: fup(3: %l1)</span><br><span class="line">; @pt p3: mode.exec(64bit)</span><br><span class="line">; @pt p4: psbend()</span><br><span class="line"></span><br><span class="line">l1:     mov rax, 0x0</span><br><span class="line">l2:     jmp l4</span><br><span class="line">l3:     add rax, 0x1</span><br><span class="line">l4:     cmp rax, 0x1</span><br><span class="line">l5:     jle l3</span><br><span class="line">; @pt p5: tnt(t.t.n)</span><br><span class="line">; @pt p6: fup(3: %l6)</span><br><span class="line">; @pt p7: tip.pgd(0: 0)</span><br><span class="line">l6:     leave</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; @pt .exp(ptdump)</span><br><span class="line">;%0p1  psb</span><br><span class="line">;%0p2  fup        3: %0l1</span><br><span class="line">;%0p3  mode.exec  cs.l</span><br><span class="line">;%0p4  psbend</span><br><span class="line">;%0p5  tnt.8      !!.</span><br><span class="line">;%0p6  fup        3: %0l6</span><br><span class="line">;%0p7  tip.pgd    0: ????????????????</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; @pt .exp(ptxed)</span><br><span class="line">;%0l1 # mov rax, 0x0</span><br><span class="line">;%0l2 # jmp l4</span><br><span class="line">;%0l4 # cmp rax, 0x1</span><br><span class="line">;%0l5 # jle l3</span><br><span class="line">;%0l3 # add rax, 0x1</span><br><span class="line">;%0l4 # cmp rax, 0x1</span><br><span class="line">;%0l5 # jle l3</span><br><span class="line">;%0l3 # add rax, 0x1</span><br><span class="line">;%0l4 # cmp rax, 0x1</span><br><span class="line">;%0l5 # jle l3</span><br><span class="line">;[disabled]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>pttc 的parser 会处理包含</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@pt</span><br></pre></td></tr></table></figure>

<p>directive marker 的注解</p>
<ul>
<li>看到<code>@pt .exp(&lt;tool&gt;)</code>directive 就会尝试模拟tool 输出结果，并产生副档名为.exp 的档案</li>
<li>看到<code>@pt p&#123;1,2,3,...&#125;:</code>则代表要产生对应的trace packet，最终会储存到.pt 档</li>
</ul>
</li>
<li><p><code>%0&#123;p,l&#125;NUMBER</code>格式代表对应label 的address</p>
</li>
</ul>
<p>其中使用到的packet 一共有六种：</p>
<ul>
<li>psb (Packet Stream Boundary) - 每产生一定大小的资料就会产生的heartbeat packet</li>
<li>fup (Flow Update Packets) - 通知发生async event</li>
<li>mode.exec - 提供decoder 当前的执行模式</li>
<li>psbend - 作为一连串的psb 的终止通知</li>
<li>tnt - 纪录conditional branch 最后往哪边走</li>
<li>tip - 纪录更新后的target IP<ul>
<li>pgd (Packet Generation Disable) - 不再产生任何packet</li>
</ul>
</li>
</ul>
<p>由此可知，在执行程式前就已经接收到一些设定相关的packet (mode.exec, …)，而在执行的过程中会收到一个表示branch taken 两次与branch non-taken 一次的packet (tnt !!.)，最后接收到不再产生packet 的通知(tip.pgd)。</p>
<hr>
<p>执行结束后会输出下面档案：</p>
<ul>
<li>由yasm 产生的档案<ul>
<li>loop-tnt.lst - assembly listing file，能够精确地纪录assembler 怎么把assembly code 转成machine code</li>
<li>loop-tnt.bin - raw binary file</li>
</ul>
</li>
<li>loop-tnt.pt - Intel PT file</li>
<li>loop-tnt-ptxed.exp - 预期ptxed 输出</li>
<li>loop-tnt-ptdump.exp - 预期ptdump 输出</li>
</ul>
<p>工具ptdump 的重现结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./ptdump loop-tnt.pt</span><br><span class="line">0000000000000000  psb</span><br><span class="line">0000000000000010  fup        3: 0000000000100000</span><br><span class="line">0000000000000017  mode.exec  cs.l</span><br><span class="line">0000000000000019  psbend</span><br><span class="line">000000000000001b  tnt.8      !!.</span><br><span class="line">000000000000001c  fup        3: 0000000000100013</span><br><span class="line">0000000000000023  tip.pgd    0: ????????????????</span><br></pre></td></tr></table></figure>

<p>工具ptxed 的重现结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># --pt 指定 trace file</span><br><span class="line"># --raw 指定 binary file 以及載入的位址</span><br><span class="line">./ptxed --pt loop-tnt.pt --raw loop-tnt.bin:0x100000</span><br><span class="line">0000000000100000  mov rax, 0x0</span><br><span class="line">0000000000100007  jmp 0x10000d</span><br><span class="line">000000000010000d  cmp rax, 0x1</span><br><span class="line">0000000000100011  jle 0x100009</span><br><span class="line">0000000000100009  add rax, 0x1</span><br><span class="line">000000000010000d  cmp rax, 0x1</span><br><span class="line">0000000000100011  jle 0x100009</span><br><span class="line">0000000000100009  add rax, 0x1</span><br><span class="line">000000000010000d  cmp rax, 0x1</span><br><span class="line">0000000000100011  jle 0x100009</span><br></pre></td></tr></table></figure>

<p>基本上与预测的输出结果相同。</p>
<hr>
<p>如果要自己写Intel-PT 的处理，可以透过syscall <strong>perf_event_open</strong>注册Intel-PT event，并透过memory mapping 取得packet buffer 位址，buffer 根据需求可以为circular 或是linear，后续即可直接透过memory 做存取。 buffer 一共分成AUX 与DATA 两种：</p>
<ul>
<li>AUX - 唯读，存放trace 结果</li>
<li>DATA - 唯写，存放资料更动(?) 的资讯(sideband information)</li>
</ul>
<hr>
<p>投影片<a target="_blank" rel="noopener" href="https://talos-intelligence-site.s3.amazonaws.com/production/document_files/files/000/000/048/original/Go_Speed_Tracer.pdf">Go Speed Tracer</a>从P.47 开始会介绍Intel-PT，包含使用的资料结构与暂存器位址，而P.47 前也大概介绍了一些fuzzing 的相关知识，有兴趣的读者可以看看。</p>
<h4 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h4><p>ptrace 是linux 上的一个system call 名称，能让parent process 观察child process 的执行状态，并且能使用不同的参数来修改&#x2F;读取&#x2F;控制child process 的执行流程与记忆体资源，原生的gdb debugger 底层就是ptrace 实作。</p>
<p>在x64 上的ptrace 实作原理是透过加上instruction <strong>int3</strong>触发interrupt，在kernel 中会检查目前的程式(debuggee) 是否正在被其他的程式(debugger) debug，如果是就暂停执行，等待debugger 的处理。举例来说，下方为debuggee 会执行到的程式码片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">55         push   rbp</span><br><span class="line">48 89 e5   mov    rbp,rsp</span><br><span class="line">53         push   rbx</span><br></pre></td></tr></table></figure>

<p>如果希望观察执行instruction<code>push rbx</code>前的暂存器状态，就可以将该instruction 改成<code>int3</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">55         push   rbp</span><br><span class="line">48 89 e5   mov    rbp,rsp</span><br><span class="line">cc         int3</span><br></pre></td></tr></table></figure>

<p>而后debuggee 执行0xcc ( <code>int3</code>) 而触发interrupt，暂停执行并等待debugger 的命令。 Debugger 会在下次debuggee 执行前把<code>int3</code>改回<code>push rbx</code>，这样debuggee 就能正常执行。</p>
<p>如果透过ptrace 取得程式执行的coverage，就需要先将目标程式当中的每个basic block 开头改成<code>int3</code>，执行期间目标程式就是debuggee，原本fuzzer 就会多了一个debugger 的身份。当目标程式执行到<code>int3</code>触发interrupt，fuzzer 就能够知道目标程式目前执行到的位址，纪录coverage 后在通知目标程式继续执行。</p>
<h4 id="Signal-handler"><a href="#Signal-handler" class="headerlink" title="Signal handler"></a>Signal handler</h4><p>Signal handler 在处理<code>int3</code>时与ptrace 的机制十分相似，不过在收到interrupt 后，前者产生signal <code>SIGTRAP</code>，交给指定的signal handler 处理，后者则是暂停执行，等待debugger 处理。 Signal handler 能知道触发signal 时的program counter (PC)，纪录完在从signal handler 回到原本的执行流程。</p>
<p>虽然<code>SIGTRAP</code>之外的signal 也能处理，不过instruction<code>int3</code>的长度为1，不太会受到长度限制，因此为首选，如果要产生其他的signal 会需要多个instruction，在短一点function 可能就出问题。</p>
<p>Signal handler 的使用方式十分简单，下方提供基本的范例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void signal_handler(int signo, siginfo_t *si, void* arg)</span><br><span class="line">&#123;</span><br><span class="line">	greg_t *gregs = (greg_t *)&amp;((ucontext_t *) arg)-&gt;uc_mcontext.gregs;</span><br><span class="line">    // rip 即為發生 signal 時的記憶體位址</span><br><span class="line">    long rip = gregs[REG_RIP];</span><br><span class="line">	// 透過 rip 來紀錄 coverage</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__ ((constructor))</span><br><span class="line">void register()</span><br><span class="line">&#123;</span><br><span class="line">    // 註冊 SIGTRAP 的 signal handler</span><br><span class="line">	action.sa_flags = SA_SIGINFO;</span><br><span class="line">    action.sa_sigaction = signal_handler;</span><br><span class="line">    sigaction(SIGTRAP, &amp;action, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此种方法必须在执行目标程式前就注册好signal handler，因此通常会编译成shared library，并将注册的function 加上属性<code>__attribute__((constructor))</code>，再透过<code>LD_PRELOAD</code>载入此library，这样linker 在执行每个library 的constructor 时就会注册到signal handler。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这几天介绍了在有&#x2F;没有source code 的情况下取得程式coverage 的方法，包含了一般的插桩、静态分析改变执行流程、动态执行做额外处理，最后还介绍一些特殊的方法。当有了搜集coverage 的方法后，该如何让程式走到更多的coverage，或是增加coverage 的品质，这将会在接下来几天做介绍。</p>
<h1 id="Day-16-优化找coverage-的能力-污点分析Taint-analysis"><a href="#Day-16-优化找coverage-的能力-污点分析Taint-analysis" class="headerlink" title="[Day 16] 优化找coverage 的能力- 污点分析Taint analysis"></a>[Day 16] 优化找coverage 的能力- 污点分析Taint analysis</h1><p>这两天主要会介绍**污点分析(taint analysis)<strong>跟</strong>符号执行(symbolic execution)**，前者可以知道资料的走向并作分析，后者可以算出如果要走到特定的function，输入需要满足怎样的条件。当这两个技术运用在fuzzing 当中，fuzzer 就能走到条件比较严苛的function，借此增加程式coverage，或者就只需要针对输入中比较有兴趣的资料做mutation。</p>
<h3 id="Taint-analysis"><a href="#Taint-analysis" class="headerlink" title="Taint analysis"></a>Taint analysis</h3><p>Taint analysis 中文翻译为污点分析，是一种data flow tracking 的技巧，通常被用来检测恶意的资料流向，借此得知程式当中哪些地方可能会发生问题。</p>
<p>Taint analysis 会使用专有名词来描述资料的用途，以下为常见的名词：</p>
<ul>
<li>Source - 要追踪的资料与追踪的开始位置，资料像是使用者输入或是私人的资料，而位置像是某个function call 或是程式的入口点</li>
<li>Propagation - source 的流向，其他被影响(taint) 到的资料，又称作polluted</li>
<li>Sink - 检查taint 的地方，取决于开发人员的目的，像如果想看source data 是否会被印出来，也许会在呼叫write system call 时检查</li>
</ul>
<p>Instruction 也根据功能分成不同的type 与propagation rule (图片撷取自conference talk <a target="_blank" rel="noopener" href="https://www.atlantis-press.com/proceedings/jimec-18/55911377">A Review of Researching on Dynamic Taint Analysis Technique</a> )：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281104804.png" alt="img"></p>
<p>其中比较特别的是logical instruction 的rule <code>R(a) &lt;- False</code>，代表<code>a</code>因为被清空所以不再被taint，其他分类在logical instruction 也能做到类似的行为。</p>
<p>通常做taint analysis 会搭配DBT (dynamic binary translation)，因为需要在程式执行期间做额外的处理，其实也可以将其视为一种负责检查记忆体的插桩，不过当然也有静态做taint analysis 的方式，像是<a target="_blank" rel="noopener" href="https://www.usenix.org/conference/usenixsecurity21/presentation/chen-sanchuan">SelectiveTaint</a>就使用了static binary writing 的技巧。</p>
<p>Taint analysis 的用途很广泛，实作方法也很多种，举例来说<a target="_blank" rel="noopener" href="https://github.com/AngoraFuzzer/libdft64">libdft</a> (Dynamic data flow tracking, DFT) 就是建立在Intel Pin 上做插桩，并使用shadow memory 实作tracking 的DFT framework，此篇文章参考了主要维护者在<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ERJnLYn7M5I">conference 上的演讲</a>，以libdft 来介绍DFT 的实作。</p>
<hr>
<p>看过Day3 - AddressSanitizer 的读者应该会对shadow memeory 不陌生，而libdft 也使用了这个技巧，为主要的记忆体建立一个shadow memory 作为bitmap，而这个bitmap 就用来表示原本记忆体的使用状态，每个bit 的定义可以自行决定。</p>
<p>Conference 中举了三个例子，<code>xchg</code>代表资料的交换，因此状态00 跟01 的资料会互相交换；<code>mov</code>则会直接将资料的状态覆盖掉，也就把01 覆盖成02；<code>add</code>则会结合两个资料的状态，也就是01 + 02 &#x3D;&#x3D; 03。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281104386.png" alt="img"></p>
<p>这个做法的好处在不同的bit 可以自己决定意义，如果研究员希望能有更细粒度的分析，像是了解记忆体是在程式的哪个component 被修改，就可以使用不同的bit value 来表示不同的component ，举例来说，bitmap 若为0b0100 则代表在network 相关的操作被修改，若为0b1000 则在处理档案时被做修改，最后在sink 时就能根据这些值对应的意义做处理。</p>
<hr>
<p>建立执行libdft 的环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AngoraFuzzer/libdft64.git</span><br><span class="line"># Intel Pin 存放在 build</span><br><span class="line">cd libdft64 &amp;&amp; mkdir build</span><br><span class="line">PREFIX=/home/user/libdft64/build ./install_pin.sh</span><br><span class="line"># build libdft64</span><br><span class="line">make</span><br><span class="line"># 編譯完後，跑跑看測試執行檔</span><br><span class="line"># pin-3.20-98437-gf02b61307-gcc-linux 目錄名稱會根據你下載的版本與時間有差，</span><br><span class="line"># 因此要自行修改</span><br><span class="line">cd tools</span><br><span class="line">/home/user/libdft64/build/pin-3.20-98437-gf02b61307-gcc-linux/pin -t obj-intel64/track.so -- obj-intel64/mini_test.exe cur_input</span><br></pre></td></tr></table></figure>

<p>track.so 为libdft 根据Intel Pin 提供的API 所撰写的taint analysis library，mini_test.exe 是用来测试的执行档，是一个副档名为.exe的ELF。因为mini_test.exe 可以执行，因此可以藉由比对有&#x2F;没有使用工具track.so 的输出结果，来了解track.so 做了哪些事情：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ obj-intel64/mini_test.exe cur_input</span><br><span class="line">set: 0x7ffecd8c8c88, 8</span><br><span class="line">get: 0x7ffecd8c8c88</span><br><span class="line">getval: 0</span><br><span class="line">get: 0x7ffecd8c8c86</span><br><span class="line">get: 0x7ffecd8c8c86</span><br><span class="line">getval: 30496</span><br><span class="line">getval: 30498</span><br><span class="line"></span><br><span class="line">$ pin -t obj-intel64/track.so -- obj-intel64/mini_test.exe cur_input</span><br><span class="line">...</span><br><span class="line">[PIN][SET] addr: 0x7ffe299c8d00, lb: 17, taint: 8</span><br><span class="line">set: 0x7ffe299c8d00, 8</span><br><span class="line">[PIN][GET] addr: 0x7ffe299c8d00, v: 0, lb: 17, taint: &#123;(8, 9) &#125;</span><br><span class="line">get: 0x7ffe299c8d00</span><br><span class="line">[PIN][GETVAL] v: 0, lb: 17, taint: &#123;(8, 9) &#125;</span><br><span class="line">getval: 0</span><br><span class="line">[PIN][GET] addr: 0x7ffe299c8d08, v: 0, lb: 0, taint: &#123;&#125;</span><br><span class="line">get: 0x7ffe299c8d08</span><br><span class="line">[PIN][GET] addr: 0x7ffe299c8d08, v: 30496, lb: 110, taint: &#123;(5, 6) (6, 7) &#125;</span><br><span class="line">get: 0x7ffe299c8d08</span><br><span class="line">[PIN][GETVAL] v: 30496, lb: 110, taint: &#123;(5, 6) (6, 7) &#125;</span><br><span class="line">getval: 30496</span><br><span class="line">[PIN][GETVAL] v: 30498, lb: 110, taint: &#123;(5, 6) (6, 7) &#125;</span><br><span class="line">getval: 30498</span><br></pre></td></tr></table></figure>

<p>测试程式mini_test.cpp 将档案读入后，穿插了许多set&#x2F;get 的操作，我有稍微对<code>main()</code>做修改，避免输出的结果造成使用者混淆：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    void __attribute__((noinline)) __libdft_set_taint(void *p, unsigned int v) &#123;</span><br><span class="line">        printf(&quot;set: %p, %d\n&quot;, p, v);</span><br><span class="line">    &#125;</span><br><span class="line">    void __attribute__((noinline)) __libdft_get_taint(void *p) &#123;</span><br><span class="line">        printf(&quot;get: %p\n&quot;, p);</span><br><span class="line">    &#125;</span><br><span class="line">    void __attribute__((noinline)) __libdft_getval_taint(uint64_t v) &#123;</span><br><span class="line">        printf(&quot;getval: %lu\n&quot;, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    fp = fopen(argv[1], &quot;rb&quot;);</span><br><span class="line">    // 底層的 read syscall 會自動將 buf 做 taint</span><br><span class="line">    ret = fread(buf, sizeof *buf, 20, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    uint64_t m = 0;</span><br><span class="line">   	// 標記 &amp;m + 8 的位址為 taint</span><br><span class="line">    __libdft_set_taint(&amp;m, 8);</span><br><span class="line">    __libdft_get_taint(&amp;m);</span><br><span class="line">    __libdft_getval_taint(m);</span><br><span class="line">	</span><br><span class="line">    // *** 原本的 source code 中為 uint16_t，但我認為 uint64_t 比較清楚 ***</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    __libdft_get_taint(&amp;x);</span><br><span class="line">    // 由於 buf 為 taint，因此在複製後 x 也被 taint</span><br><span class="line">    memcpy(&amp;x, buf + 5, 2);</span><br><span class="line">    __libdft_get_taint(&amp;x);</span><br><span class="line">    __libdft_getval_taint(x);</span><br><span class="line">    </span><br><span class="line">    uint64_t y = x + 2;</span><br><span class="line">    __libdft_getval_taint(y); // y 也被 taint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工具track.cpp 会在指定的function 被呼叫时产生source &#x2F; sink：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 建立 sink</span><br><span class="line">VOID TestGetHandler(void *p) &#123;</span><br><span class="line">    uint64_t v = *((uint64_t *)p);</span><br><span class="line">    tag_t t = tagmap_getn(p, 8);</span><br><span class="line">    printf(&quot;[PIN][GET] addr: %p, v: %lu, lb: %d, taint: %s\n&quot;, p, v, t,</span><br><span class="line">           tag_sprint(t).c_str());</span><br><span class="line">&#125;</span><br><span class="line">VOID TestGetValHandler(THREADID tid, uint64_t v) &#123;</span><br><span class="line">    tag_t t = tagmap_getn_reg(tid, X64_ARG0_REG, 8);</span><br><span class="line">    printf(&quot;[PIN][GETVAL] v: %lu, lb: %d, taint: %s\n&quot;, v, t,</span><br><span class="line">           tag_sprint(t).c_str());</span><br><span class="line">&#125;</span><br><span class="line">// -------------------------------------------</span><br><span class="line">// 建立 sources</span><br><span class="line">VOID TestSetHandler(void *p, unsigned int v) &#123;</span><br><span class="line">    // tag 傳進來的參數，代表已經被 taint</span><br><span class="line">    tag_t t = tag_alloc&lt;tag_t&gt;(v);</span><br><span class="line">    tagmap_setb(p, t);</span><br><span class="line">    printf(&quot;[PIN][SET] addr: %p, lb: %d, taint: %d\n&quot;, p, t, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 以下省略 valid check 以及 open / close 操作</span><br><span class="line">VOID EntryPoint(VOID *v) &#123;</span><br><span class="line">    // traverse 所有 image (binary file)</span><br><span class="line">    for (IMG img = APP_ImgHead(); IMG_Valid(img); img = IMG_Next(img)) &#123;</span><br><span class="line">        // 以 function name 搜尋 routine object</span><br><span class="line">        </span><br><span class="line">        // 呼叫 __libdft_get_taint(p) 前會執行 TestGetHandler(p)</span><br><span class="line">        RTN test_get_rtn = RTN_FindByName(img, &quot;__libdft_get_taint&quot;);</span><br><span class="line">        RTN_InsertCall(test_get_rtn, IPOINT_BEFORE, (AFUNPTR)TestGetHandler, ...);</span><br><span class="line"></span><br><span class="line">        // 呼叫 __libdft_set_taint(p,v) 前會執行 TestSetHandler(p,v)</span><br><span class="line">        RTN test_set_rtn = RTN_FindByName(img, &quot;__libdft_set_taint&quot;);</span><br><span class="line">        RTN_InsertCall(test_set_rtn, IPOINT_BEFORE, (AFUNPTR)TestSetHandler, ...);</span><br><span class="line"></span><br><span class="line">        // 呼叫 __libdft_getval_taint(v) 前會執行 TestGetValHandler(thread_id,v)</span><br><span class="line">        RTN test_getval_rtn = RTN_FindByName(img, &quot;__libdft_getval_taint&quot;);</span><br><span class="line">        RTN_InsertCall(test_getval_rtn, IPOINT_BEFORE, (AFUNPTR)TestGetValHandler, ...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    PIN_InitSymbols(); // 初始化 symbol table</span><br><span class="line">    PIN_Init(argc, argv); // 初始化參數</span><br><span class="line">	libdft_init(); // 初始化 libdft library</span><br><span class="line">    // 在 pin 初始化後會執行 Entry</span><br><span class="line">    PIN_AddApplicationStartFunction(EntryPoint, 0);</span><br><span class="line">	// libdft 會 hook 在與 file 相關的 syscall，</span><br><span class="line">    // 並將 syscall 參數標記成 taint</span><br><span class="line">    hook_file_syscall();</span><br><span class="line">    PIN_StartProgram(); // 開始執行</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然libdft 并非主流的DFT framework，程式码中也没有良好的注解可以参考，不过单就介绍执行流程与使用方法来说已经绰绰有余。</p>
<hr>
<p>CMU 的课程投影片有介绍到taint analysis <a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~ckaestne/15313/2018/20181023-taint-analysis.pdf">Foundations of Software Engineering</a>，内容包含static 与dynamic taint analysis 的原理，有兴趣的读者可以参考看看。</p>
<h1 id="Day-17-优化找coverage-的能力-符号执行Symbolic-execution-amp-实际运用的困难"><a href="#Day-17-优化找coverage-的能力-符号执行Symbolic-execution-amp-实际运用的困难" class="headerlink" title="[Day 17] 优化找coverage 的能力- 符号执行Symbolic execution &amp; 实际运用的困难"></a>[Day 17] 优化找coverage 的能力- 符号执行Symbolic execution &amp; 实际运用的困难</h1><p>程式当中充斥许多if-else condition，这些条件判断使得程式在不同的情况下有不同的处理方式，而每个condition 都是将各个变数的比较做组合。如果将这些condition 转换成数学式子，则会发现有许多共通之处，像是静态期间变数的值无从得知，就对应到数学当中的未知数；大于、等于与小于的比较在数学中也有相同的行为，因此科学家尝试用<strong>符号</strong>表示<strong>变数</strong>，”模拟”变数的值来执行程式，借此通过特定路径，获得输出结果，而这样的处理也被称作**符号执行(symbolic execution)**。</p>
<p>概念就是把程式的变数视为符号，并且把走到特定function 的路径上所有if-else 条件组合起来，解出各个符号的值需要在什么范围当中，最后产生对应的input 来满足这些条件，不过具体数学是如何计算，以及解这些条件限制(constraint) 时使用什么演算法，这方面我不是很熟，因此这篇文章会着重在介绍实际应用。</p>
<p>目前常看见使用到symbolic execution 的工具有<a target="_blank" rel="noopener" href="https://github.com/Z3Prover/z3">z3</a>、<a target="_blank" rel="noopener" href="https://github.com/angr/angr">angr</a> (底层使用Claripy solver)，关于这两个工具的使用可以参考2016 HITCON 演讲<a target="_blank" rel="noopener" href="https://hitcon.org/2016/CMT/slide/day1-r1-a-1.pdf">Binary 自动分析的那些事</a>的投影片，内容详细之外还附上使用方法。在此介绍的是<a target="_blank" rel="noopener" href="https://github.com/S2E/s2e">S2E</a> ( <strong>S</strong> ymbolic <strong>E</strong> xecution <strong>E</strong> ngine)，一个提供符号执行与程式分析的平台。</p>
<p><strong>S2E</strong>提供了一步到位的interface，除了初始化复杂的环境只需要下一些命令之外，对程式中的资料解symbolic 也只需要呼叫一些library API，连VM 的执行都能够帮你做到。</p>
<p>S2E 底层使用了KVM 与QEMU，让使用者可以在VM 当中执行，并免污染到主机环境，同时S2E 也使用了<code>LD_PRELOAD</code>载入S2E 的library：libs2e.so，借此在QEMU 开始执行之前做S2E 的环境初始化，并且让QEMU 能呼叫到S2E 的function，而接下来会介绍这个成熟的symbolic execution engine 是如何包装与实作。</p>
<hr>
<p>S2E 的环境建置稍微复杂一点，要安装的东西也比较多，请参考以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">### (~500M)</span><br><span class="line"># 安裝 dependencies</span><br><span class="line">sudo apt install git gcc python3 python3-dev python3-venv</span><br><span class="line"># 先安裝 s2e 的 python environment</span><br><span class="line">git clone https://github.com/S2E/s2e-env.git</span><br><span class="line">cd s2e-env</span><br><span class="line">python3 -m venv venv</span><br><span class="line">. venv/bin/activate</span><br><span class="line">pip install .</span><br><span class="line"></span><br><span class="line">### (~20G)</span><br><span class="line"># 建立存放相關執行檔的目錄</span><br><span class="line">mkdir ~/s2e_build &amp;&amp; cd ~/s2e_build</span><br><span class="line"># 初始化，會安裝一大堆 dependencies (347M)</span><br><span class="line">s2e init .</span><br><span class="line">. ./s2e_activate</span><br><span class="line"># 編譯</span><br><span class="line">s2e build</span><br><span class="line"># 產生 ubuntu-22.04-x86_64 VM image</span><br><span class="line">s2e image_build ubuntu-22.04-x86_64</span><br></pre></td></tr></table></figure>

<p>参考官方文件<a target="_blank" rel="noopener" href="https://s2e.systems/docs/Tutorials/BasicLinuxSymbex/SourceCode.html">tutorial</a>的<strong>Introduction</strong> &amp; <strong>Compiling and running</strong>，在指定目录编译测试执行档(下方以&#x2F;home&#x2F;user&#x2F;s2e_build&#x2F;tests 为指定目录)，并且执行下方命令，在&#x2F;home&#x2F;user&#x2F;s2e_build&#x2F;projects&#x2F;tutorial1底下建立相关档案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s2e new_project ./tutorial1</span><br></pre></td></tr></table></figure>

<p>测试执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/user/s2e_build/projects/tutorial1 &amp;&amp; ./launch-s2e.sh</span><br><span class="line"># 或者是</span><br><span class="line">s2e run tutorial1</span><br></pre></td></tr></table></figure>

<p>最后在projects&#x2F;tutorial1 目录底下会有<code>s2e-out-</code>前缀的资料夹，里面存放执行结果。</p>
<hr>
<p>在初始化环境，并确保可以执行后，再来要修改tutorial1.c 的程式码，让S2E 知道哪些资料是要被symbolic。</p>
<p>方法虽然有很多种，但最直接的方式就是在程式码中指定变数为symbolic，S2E 提供了API<code>s2e_make_symbolic()</code>做到这件事情。原先在程式当中会等待使用者输入字串，在此呼叫<code>s2e_make_symbolic()</code>来模拟使用者输入，传入<code>(symbol 位址, symbol 大小, symbol 名稱)</code>，S2E 就会将位址填入symbol value 做分析。在程式的最后呼叫<code>s2e_get_example()</code>取得执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/** 原本的資料來源為使用者輸入</span><br><span class="line">printf(&quot;Enter two characters: &quot;);</span><br><span class="line">if (!fgets(str, sizeof(str), stdin)) &#123;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;**/</span><br><span class="line">s2e_make_symbolic(str, 2, &quot;str&quot;);</span><br><span class="line">str[3] = 0;</span><br><span class="line"></span><br><span class="line">if (str[0] == &#x27;\n&#x27; || str[1] == &#x27;\n&#x27;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2e_get_example(str, 2);</span><br><span class="line">printf(&quot;&#x27;%c%c&#x27; %02x %02x\n&quot;, str[0], str[1], (unsigned char) str[0], (unsigned char) str[1]);</span><br></pre></td></tr></table></figure>

<p>这边把更新过的tutorial1.c 重新命名为tutorial2.c 以方便区隔，并且因为使用到S2E library，因此先前编译的命令需要更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I/home/user/s2e_build/source/s2e/guest/common/include -O3 tutorial2.c -o tutorial2</span><br></pre></td></tr></table></figure>

<hr>
<p>S2E function<code>s2e_make_symbolic()</code>实际上会插入一段有格式的非法instruction，透过objdump 执行档tutorial2，能看到<code>s2e_make_symbolic()</code>产生的instruction 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1107:       0f 3f                   (bad)</span><br><span class="line">1109:       00 03                   add    BYTE PTR [rbx],al</span><br><span class="line">110b:       00 00                   add    BYTE PTR [rax],al</span><br><span class="line">110d:       00 00                   add    BYTE PTR [rax],al</span><br><span class="line">110f:       00 00                   add    BYTE PTR [rax],al</span><br></pre></td></tr></table></figure>

<p>当CPU 执行到非法instruction 时会送SIGILL，代表CPU 看不懂，而S2E library 则是透过SIGILL 来拦截VM 的执行，并且根据种类做对应的操作，instruction 的种类可以看s2e_build&#x2F;source&#x2F;s2e&#x2F;guest &#x2F;common&#x2F;include&#x2F;s2e&#x2F;opcodes.h：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define BASE_S2E_CHECK          0x00</span><br><span class="line">#define BASE_S2E_MAKE_SYMBOLIC  0x03</span><br><span class="line">#define BASE_S2E_IS_SYMBOLIC    0x04</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对照objdump 的结果，能知道0f 3f 为S2E 产生的非法instruction，00 03 则是代表种类为<code>BASE_S2E_MAKE_SYMBOLIC</code>。</p>
<p>再来会透过原始码介绍S2E library 是从哪边接收到<code>BASE_S2E_MAKE_SYMBOLIC</code>，这部分相较复杂，可以斟酌查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">// ========== libs2eplugins/src/s2e/Plugins/Core/BaseInstructions.cpp ==========</span><br><span class="line">// handleBuiltInOps() 有一個 switch case 負責處理各種 s2e opcode</span><br><span class="line">void BaseInstructions::handleBuiltInOps(..., uint64_t opcode) &#123;</span><br><span class="line">    switch ((opcode &gt;&gt; 8) &amp; 0xFF) &#123;</span><br><span class="line">        // 對於在程式中呼叫的 function s2e_make_symbolic() 做處理</span><br><span class="line">        case BASE_S2E_MAKE_SYMBOLIC: &#123;</span><br><span class="line">            makeSymbolic(state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// onCustomInstruction() 為 wrapper function，包了一層 range 的檢查</span><br><span class="line">void BaseInstructions::onCustomInstruction(..., uint64_t opcode) &#123;</span><br><span class="line">    uint8_t opc = (opcode &gt;&gt; 8) &amp; 0xFF;</span><br><span class="line">    if (opc &lt;= BASE_S2E_MAX_OPCODE) &#123;</span><br><span class="line">        handleBuiltInOps(state, opcode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BaseInstructions::initialize() &#123;</span><br><span class="line">    // onCustomInstruction 的呼叫與 onCustomInstruction member 綁在一起</span><br><span class="line">    s2e()-&gt;getCorePlugin()-&gt;onCustomInstruction.connect(sigc::mem_fun(*this, &amp;BaseInstructions::onCustomInstruction));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ========== libs2ecore/include/s2e/CorePlugin.h ==========</span><br><span class="line">// 而 CorePlugin 的 member &quot;onCustomInstruction&quot; 實際上會註冊</span><br><span class="line">// 在 guest 中執行到特定 opcode 時的會發出的 signal</span><br><span class="line">sigc::signal&lt;void, S2EExecutionState*, uint64_t&gt; onCustomInstruction;</span><br><span class="line"></span><br><span class="line">// ========== libs2ecore/src/CorePluginInterface.cpp ==========</span><br><span class="line">void s2e_tcg_custom_instruction_handler(uint64_t arg) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 在 tcg 中註冊客製 instruction 的處理</span><br><span class="line">        // 也就是 tcg 執行到非法 opcode 0f 3f 時就會轉給上面註冊的 handler 來處理</span><br><span class="line">        g_s2e-&gt;getCorePlugin()-&gt;onCustomInstruction.emit(g_s2e_state, arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ========== libs2ecore/src/S2EExecutor.cpp ==========</span><br><span class="line">// 註冊對應名稱的 helper function</span><br><span class="line">void s2e_initialize_execution(int execute_always_klee) &#123;</span><br><span class="line">    // &quot;s2e_tcg_custom_instruction_handler&quot; --&gt; s2e_tcg_custom_instruction_handler()</span><br><span class="line">    tcg_register_helper((void *) &amp;s2e_tcg_custom_instruction_handler, &quot;s2e_tcg_custom_instruction_handler&quot;, 1, sizeof(uint64_t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ========== libs2ecore/src/CorePluginInterface.cpp ==========</span><br><span class="line">// tcg 讓程式去執行 s2e_tcg_custom_instruction_handler()</span><br><span class="line">void s2e_tcg_emit_custom_instruction(uint64_t arg) &#123;</span><br><span class="line">    tcg_gen_callN((void *) s2e_tcg_custom_instruction_handler, nullptr, 1, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ========== libs2e/src/s2e-libcpu-interface.cpp ==========</span><br><span class="line">// 為 interface 註冊 function handler</span><br><span class="line">void init_s2e_libcpu_interface(struct se_libcpu_interface_t *sqi) &#123;</span><br><span class="line">    sqi-&gt;events.tcg_emit_custom_instruction = s2e_tcg_emit_custom_instruction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ========== libs2e/src/s2e-kvm.cpp ==========</span><br><span class="line">// 初始化 event handler</span><br><span class="line">void S2EKVM::init(void) &#123;</span><br><span class="line">    init_s2e_libcpu_interface(&amp;g_sqi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 建立 S2EKVM object 並做初始化</span><br><span class="line">IFilePtr S2EKVM::create() &#123;</span><br><span class="line">    auto ret = std::shared_ptr&lt;S2EKVM&gt;(new S2EKVM());</span><br><span class="line">    ret-&gt;init();</span><br><span class="line">    s_s2e_kvm = ret;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在呼叫原本的 open64 前，會先執行此 function 來建立 KVM object</span><br><span class="line">// 最後呼叫 g_original_open() 執行原本的 open64 syscall</span><br><span class="line">int open64(const char *pathname, int flags, ...) &#123;</span><br><span class="line">    if (!strcmp(pathname, &quot;/dev/kvm&quot;)) &#123;</span><br><span class="line">        // 建立</span><br><span class="line">        kvm = s2e::kvm::S2EKVM::create();</span><br><span class="line">    &#125;</span><br><span class="line">    g_original_open = (open_t) dlsym(RTLD_NEXT, &quot;open&quot;);</span><br><span class="line">    return g_original_open(pathname, flags, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当QEMU 送KVM request<code>KVM_CREATE_VM</code>时代表建立VM，一样会先在S2E 做处理，最后才会呼叫到原本的syscall，而这条路也会执行到<code>s2e_initialize_execution()</code>，注册helper function：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// ========== libs2ecore/src/S2EExecutor.cpp ==========</span><br><span class="line">std::shared_ptr&lt;VM&gt; VM::create(std::shared_ptr&lt;S2EKVM&gt; &amp;kvm) &#123;</span><br><span class="line">    auto ret = std::shared_ptr&lt;VM&gt;(new VM(kvm));</span><br><span class="line">    s2e_initialize_execution(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ========== libs2e/src/s2e-kvm.cpp ==========</span><br><span class="line">// 建立 VM</span><br><span class="line">int S2EKVM::createVM() &#123;</span><br><span class="line">    auto vm = VM::create(kvm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 為各種 kvm request 執行對應 s2e handler</span><br><span class="line">int S2EKVM::sys_ioctl(int fd, int request, uint64_t arg1) &#123;</span><br><span class="line">    switch ((uint32_t) request) &#123;</span><br><span class="line">        case KVM_CREATE_VM: &#123;</span><br><span class="line">            // 如果 KVM ioctl 的 request 是要建立 VM，</span><br><span class="line">            // 那對應的 s2e 環境也會需要建 VM</span><br><span class="line">            ret = createVM();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在呼叫原本的 ioctl 前，會先執行此 function 來初始化 s2e 的環境</span><br><span class="line">// 最後呼叫 g_original_ioctl() 執行原本的 ioctl syscall</span><br><span class="line">int ioctl(int fd, int request, uint64_t arg1) &#123;</span><br><span class="line">    // 呼叫 S2EKVM::sys_ioctl()</span><br><span class="line">	g_fdm-&gt;get(fd)-&gt;sys_ioctl(fd, request, arg1);</span><br><span class="line">    g_original_ioctl = (ioctl_t) dlsym(RTLD_NEXT, &quot;ioctl&quot;);</span><br><span class="line">    return g_original_ioctl(fd, request, arg1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>总结来说，QEMU 在呼叫KVM 前会先被S2E 给拦截，S2E 会根据request 的内容执行对应的handler，像是建立S2E VM。之后QEMU 会透过KVM 载入linux kernel，并执行使用者所撰写的程式(ie tutorial1, tutorial2)，当执行到程式当中0f 3f 此种非法instruction 时，会呼叫S2E 的handler，并且根据instruction 的种类做不同的处理，像是对某块记忆体建立symbolic。而后S2E 不断fork 当前执行状态来模拟输入与解constraint，如果条件可以解，则S2E 最终会产生一或多组满足这些条件的输入，借此走到特定路径。</p>
<h3 id="实际运用的困难"><a href="#实际运用的困难" class="headerlink" title="实际运用的困难"></a>实际运用的困难</h3><p>虽然符号执行(symbolic execution) 与污点分析(taint analysis) 的搭配能让fuzzer 走到更难走到的地方，但实际运用时却很容易造成大量的overhead。</p>
<p>以symbolic execution 来说，执行过程中的condition 越多，代表要处理的数学运算也越多，意即造成的overhead 越大，然而回圈在每次迭代时都会进行一次条件判断，程式当中又免不了回圈的处理，因此造成只要程式规模一大，使用回圈的次数增加，就会导致symbolic execution 的overhead 增加，此状况也称作<strong>path explosion</strong>。</p>
<p>而taint analysis 也会遇到相同的问题，只要程式规模变大，要做的propagation 就变多，间接造成的overhead 也越高。</p>
<p>考虑到上述的情况，这两个机制被整合到fuzzer 前都需要在时间与品质中取得平衡，这也产生了另一个新实作机制：<strong>Concolic execution</strong>。 Concolic execution 透过symbolic execution 解一部份的条件，得到较大的input 范围，剩下的就透过随机产生的input 来尝试。不过目前也不只有concolic execution 能够取得平衡，这部分也有许多研究正在进行。</p>
<h1 id="Day-18-优化找coverage-的能力-链结时期优化-LTO"><a href="#Day-18-优化找coverage-的能力-链结时期优化-LTO" class="headerlink" title="[Day 18] 优化找coverage 的能力- 链结时期优化(LTO)"></a>[Day 18] 优化找coverage 的能力- 链结时期优化(LTO)</h1><p>Link time optimization (LTO) 的功能如同他的名字(self-explanatory)，就是在将各个object file 链结起来前再做一次优化，而如果没有使用LTO 的话，编译器就只会对各个档案分别最佳化。</p>
<p>透过LTO 能加强fuzzer 的效率，举例来说fuzzer <a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus">AFL++</a>透过LTO 做到避免执行期间产生的edge value 出现碰撞的情况，也就是<strong>collision-free</strong> instrumentation (<a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.lto.md">文件</a>)，结果显示提升了10-25% 的执行效率。</p>
<p>文件<a target="_blank" rel="noopener" href="https://community.arm.com/arm-community-blogs/b/tools-software-ides-blog/posts/link-time-optimization-in-arm-compiler-6">Link Time Optimization in ARM Compiler 6</a>中有对LTO 做完整的说明，接下来的文章中也参考了此文件的资源，有兴趣的读者可以在自行阅读。</p>
<h3 id="LTO-workflow"><a href="#LTO-workflow" class="headerlink" title="LTO workflow"></a>LTO workflow</h3><p>LTO 在整个编译流程的哪个部分，能从下图清楚了解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281105051.png" alt="img"></p>
<ol>
<li>Souce code 会透过clang compiler 转成中间码(intermediate representation, IR)，也称作bitcode</li>
<li>链结器(linker) 会从产生的bitcode 与其他object file 分析出彼此的dependencies，并交给LTO 做优化</li>
<li>优化过程中会将没使用到的object file 或是程式码给移除，最后产生新的object file。如果需要有客制化的优化处理，可以额外写plugin</li>
<li>最后linker 会在将这些object file 组起来，产生可执行的ELF file</li>
</ol>
<p>以<a target="_blank" rel="noopener" href="https://llvm.org/docs/LinkTimeOptimization.html#example-of-link-time-optimization">llvm 官方文件</a>提供的范例程式码为例，能更了解LTO 实际上做了哪些优化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// --- a.h ---</span><br><span class="line">extern int foo1(void);</span><br><span class="line">extern void foo2(void);</span><br><span class="line">extern void foo4(void);</span><br><span class="line"></span><br><span class="line">// --- a.c ---</span><br><span class="line">#include &quot;a.h&quot;</span><br><span class="line"></span><br><span class="line">static signed int i = 0;</span><br><span class="line"></span><br><span class="line">void foo2(void) &#123;</span><br><span class="line">    i = -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int foo3() &#123;</span><br><span class="line">    foo4();</span><br><span class="line">    return 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int foo1(void) &#123;</span><br><span class="line">    int data = 0;</span><br><span class="line"></span><br><span class="line">    if (i &lt; 0)</span><br><span class="line">        data = foo3();</span><br><span class="line"></span><br><span class="line">    data = data + 42;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// --- main.c ---</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;a.h&quot;</span><br><span class="line"></span><br><span class="line">void foo4(void)&#123;</span><br><span class="line">    printf(&quot;Hi\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    return foo1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析这三个档案(main.c, ac, ah)，可以发现一些架构上的问题：</p>
<ul>
<li>main.c<ul>
<li>虽然include ah，但实际上外部function 只有使用<code>foo1()</code></li>
<li>定义的function<code>foo4()</code>没有被使用到</li>
</ul>
</li>
<li>ac<ul>
<li>变数<code>i</code>预设为0，虽然可以透过function<code>foo2()</code>赋值-1，不过程式并没有呼叫<code>foo2()</code>，因此<code>i</code>值恒为0</li>
<li>承接上一个问题的结果，function<code>foo3()</code>也不可能被呼叫到(需满足<code>i &lt; 0</code>)</li>
</ul>
</li>
<li>总结来说，实际使用的function 只有<code>foo1()</code>，并且<code>i</code>值为0，其他的function 与condition 都是多余的</li>
</ul>
<p>如果编译时使用LTO，就可以把这些没有使用到的function 移除，优化执行档的大小。下方为编译时使用LTO 所需要传入的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># -flto 會輸出 bitcode 格式的 object file</span><br><span class="line">clang -flto -c a.c -o a.o</span><br><span class="line"></span><br><span class="line"># 兩者擇一，如果不加 flto 就會產生 ELF format 的 object file</span><br><span class="line">clang -flto -c main.c -o main.o</span><br><span class="line">clang -c main.c -o main.o</span><br><span class="line"></span><br><span class="line"># 處理 bitcode / ELF 並做 LTO，最後產生 main 執行檔</span><br><span class="line">clang -flto a.o main.o -o main</span><br></pre></td></tr></table></figure>

<p>最后透过objdump 看执行档main，会发现使用者撰写的程式码只留下<code>main()</code>与<code>foo1()</code>，并且在<code>foo1()</code>对于<code>i</code>的检查也被优化掉了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0000000000001130 &lt;foo1&gt;:</span><br><span class="line">    1130:       55                      push   rbp</span><br><span class="line">    1131:       48 89 e5                mov    rbp,rsp</span><br><span class="line">    1134:       c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">    113b:       8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">    113e:       83 c0 2a                add    eax,0x2a</span><br><span class="line">    1141:       89 45 fc                mov    DWORD PTR [rbp-0x4],eax</span><br><span class="line">    1144:       8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">    1147:       5d                      pop    rbp</span><br><span class="line">    1148:       c3                      ret</span><br><span class="line"></span><br><span class="line">0000000000001150 &lt;main&gt;:</span><br><span class="line">    1150:       55                      push   rbp</span><br><span class="line">    1151:       48 89 e5                mov    rbp,rsp</span><br><span class="line">    1154:       48 83 ec 10             sub    rsp,0x10</span><br><span class="line">    1158:       c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">    115f:       e8 cc ff ff ff          call   1130 &lt;foo1&gt;</span><br><span class="line">    1164:       48 83 c4 10             add    rsp,0x10</span><br><span class="line">    1168:       5d                      pop    rbp</span><br><span class="line">    1169:       c3                      ret</span><br></pre></td></tr></table></figure>

<p>如果把参数<code>-flto</code>移除，代表不做LTO，则执行档main 会包含许多用不到的程式码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0000000000001140 &lt;foo4&gt;:</span><br><span class="line">    1140:       55                      push   rbp</span><br><span class="line">	...</span><br><span class="line">    114d:       e8 de fe ff ff          call   1030 &lt;printf@plt&gt;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">0000000000001160 &lt;main&gt;:</span><br><span class="line">	...</span><br><span class="line">    116f:       e8 1c 00 00 00          call   1190 &lt;foo1&gt;</span><br><span class="line">    ...</span><br><span class="line">    1179:       c3                      ret</span><br><span class="line"></span><br><span class="line">0000000000001180 &lt;foo2&gt;:</span><br><span class="line">    1180:       55                      push   rbp</span><br><span class="line">    ...</span><br><span class="line">    118f:       c3                      ret</span><br></pre></td></tr></table></figure>

<h3 id="LTO-in-fuzzing"><a href="#LTO-in-fuzzing" class="headerlink" title="LTO in fuzzing"></a>LTO in fuzzing</h3><p>Edge collision，又称作path collision，指的是不同的两组basic block 组合产生了相同的edge value，如果参考AFL 算edge value 的方法，可以想成发生<code>bb_id(bb_a) ^ bb_id(bb_b)</code>等同于<code>bb_id(bb_c) ^ bb_id(bb_d)</code>的情况(bb 为basic block 缩写) ，这样会让fuzzer 认为这两个不同的path 是同一个，以至于漏失许多走到新path 的情况。</p>
<p>Basic block ID 在编译时期就已经决定好，因此如果要避免这种情况发生，就必须在编译的流程中处理，因此论文<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/8418631">CollAFL: Path Sensitive Fuzzing</a>不仅发现这个情况发生的比想像中频繁，造成效能的下降，同时也提出透过在clang LTO pass 实作相关演算法来处理这个问题，而类似的机制后来在AFL++ 也有实作，不过我不确定两者之间的关联，AFL++ 的LTO 处理可以参考原始码<a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/SanitizerCoverageLTO.so.cc">SanitizerCoverageLTO.so.cc</a>。</p>
<h1 id="Day-19-优化找coverage-的能力-REDQUEEN"><a href="#Day-19-优化找coverage-的能力-REDQUEEN" class="headerlink" title="[Day 19] 优化找coverage 的能力- REDQUEEN"></a>[Day 19] 优化找coverage 的能力- REDQUEEN</h1><p>**校验码(checksum)<strong>被用来检测资料的完整性，</strong>魔术数字(magic number)**被用来侦测特定格式的资料，当这两种类型的检查出现在程式当中，会让总是产生随机资料的fuzzer 没办法走到更深的地方。举例来说，如果程式只支援ELF 档案格式，则在程式的一开始就会检查档案的合法性，否则就直接不处理，因此fuzzer 产生的input 必须含有ELF magic number，才能走到检查之后的程式逻辑，例如以下范例程式，当档案开头不为ELF magic number 时，永远只能走到程式的开头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fd = open(&quot;./input&quot;, O_RDONLY);</span><br><span class="line">read(fd, buf, 0x4);</span><br><span class="line">// 7f &#x27;E&#x27; &#x27;L&#x27; &#x27;F&#x27; 是 ELF file 的 magic number</span><br><span class="line">if (buf[0] != 0x7f || buf[1] != 0x45 || buf[2] != 0x4c || buf[3] == 0x46)</span><br><span class="line">    exit(1);</span><br><span class="line">// 幾千幾萬行的程式碼</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<p>Checksum 则是用来看资料在传输的过程中是否有遗失，经常被用在网路传输，而通常这部分的程式码在一开始就会先确保资料完整，才会执行后面的操作，例如以下范例程式，如果求出来的checksum 与封包中所记录的不相同，程式就会直接终止：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">recv(sock_fd, &amp;pkt, 0x100, ...);</span><br><span class="line">calc_checksum = crc32(&amp;pkt.data);</span><br><span class="line">if (calc_checksum != pkt.checksum)</span><br><span class="line">    exit(1);</span><br><span class="line">// 幾千幾萬行的程式碼</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<hr>
<p><a target="_blank" rel="noopener" href="https://www.ndss-symposium.org/ndss-paper/redqueen-fuzzing-with-input-to-state-correspondence/">Redqueen: Fuzzing with Input-to-State Correspondence</a>发表于NDSS 2019，提出了直观的做法解决当时fuzzer 无法处理checksum 与magic number 的问题，并且在没有使用symbolic execution 与taint analysis 的情况下做到部分的执行流程分析，成功让优化coverage 的领域往前了一大步。</p>
<p>这篇在近期fuzzing 相关的论文中应该算是很经典的，不少论文的优化方法都是从REDQUEEN 取得灵感，同时他提出的方法也跟Day16 Day17 介绍的优化方法有关系。相关资源都存放在<a target="_blank" rel="noopener" href="https://github.com/RUB-SysSec/redqueen">REDQUEEN github repo</a>，包含演讲影片、投影片与论文连结等等，有兴趣的读者可以自行阅读，接下来会介绍论文所提出的问题以及解决方法，同时也会跟先前介绍的方法做个比较。</p>
<h2 id="REDQUEEN"><a href="#REDQUEEN" class="headerlink" title="REDQUEEN"></a>REDQUEEN</h2><p>透过观察，研究人员发现fuzzer 执行不到的程式码大多具有magic number 或是checksum 的检查，下方的程式码清楚说明这两种情况的发生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 魔術數字的比對，magic number</span><br><span class="line">if(u64(input) == u64(&quot;MAGICHDR&quot;))</span><br><span class="line">    bug(1);</span><br><span class="line"></span><br><span class="line">// 校驗碼的檢查，checksum</span><br><span class="line">if(u64(input) == sum(input+8, len-8))</span><br><span class="line">    if(u64(input+8) == sum(input+16, len-16))</span><br><span class="line">        if(input[16] == &#x27;R&#x27; &amp;&amp; input[17] == &#x27;Q&#x27;)</span><br><span class="line">            bug(2);</span><br></pre></td></tr></table></figure>

<p>这种检查让随机化产生资料的fuzzer 没办法继续执行，然而如果想要走到<code>bug(1)</code>或是<code>bug(2)</code>的话，虽然可以利用taint analysis 与symbolic execution 产生对应的input，但实际情况会面临两个问题：</p>
<ul>
<li>我们并不能知道实际程式当中的<code>bug()</code>在哪里</li>
<li>大量的条件判断会让overhead 过大</li>
</ul>
<p>因此这并非一个有效的解法。而研究人员观察到程式在大多数的情况，多少会将输入存放在记忆体或是暂存器当中，于是他们提出<strong>input-to-state</strong>的概念与<strong>colorizing</strong>的机制，将<strong>特定部分的输入</strong>取代成magic number，借此绕过magic number 的检查，并且实作出一个<strong>patching-based</strong>的解决方法处理checksum 的比对。</p>
<h3 id="Bypass-magic-number-check"><a href="#Bypass-magic-number-check" class="headerlink" title="Bypass magic number check"></a>Bypass magic number check</h3><p>REDQUEEN 会执行下面的处理：</p>
<ul>
<li><strong>Tracing</strong> - 以当前的input 执行一次程式，并hook 所有比较相关的操作，像是instruction<code>cmp</code>或是字串比较function <code>strcmp()</code>，同时将参数抽取出来</li>
<li><strong>Variants</strong> - 对要被比较的值做些微的改动，像是+1 或-1，用来区别不同的比较操作</li>
<li><strong>Encoding</strong> - 模拟input 到达比较之前做了哪些处理，像是变成以小端来处理</li>
<li><strong>Application</strong> - 使用格式为<code>&lt;pattern → repl&gt;</code>的mutation，将<code>pattern</code>的部分直接换成<code>repl</code></li>
<li><strong>Colorization</strong> - 增加input 当中随机byte 的个数，避免子字串重复出现</li>
</ul>
<p>论文中以一开始介绍magic number 与checksum 检查的程式码为例子，将上述提到的处理做对应：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281106479.png" alt="img"></p>
<ul>
<li><strong>Tracing</strong> - 以<code>&quot;TestSeedInput&quot;</code>作为程式输入，并且hook 在比较程式码<code>u64(input) == u64(&quot;MAGICHDR&quot;)</code>，而因为比较时使用整数型态，因此实际上值应该等于<code>&quot;deeStesT&quot;</code></li>
<li><strong>Variants</strong> -<code>u64(&quot;MAGICHDR&quot;)</code>转成整数型态并+1 会得到<code>&quot;RDHCIGAN&quot;</code>，而-1 得到<code>&quot;RDHCIGAL&quot;</code>，于是会有三种不同的比较值：<code>&quot;RDHCIGAN&quot;</code>(+1)、<code>&quot;RDHCIGAM&quot;</code>(0)、<code>&quot;RDHCIGAL&quot;</code>(-1)</li>
<li><strong>Encoding &amp; Application</strong> - 将这些整数值做了小端编码，并将对input 当中<code>&quot;TestSeed&quot;</code>的部分替换成经过mutate 的magic number</li>
<li><strong>Colorization</strong> - 让input 尽量长得像<code>&quot;TestSeedInput&quot;</code>而不是<code>&quot;ZZZZZZZZZZZZZ&quot;</code>，因为input 如果是<code>&quot;ZZZZZZZZZZZZZ&quot;</code>，就会让<code>pattern</code>没办法确定要替换的是前8 个<code>&quot;Z&quot;</code>而不是其他的</li>
</ul>
<h3 id="Bypass-checksum-check"><a href="#Bypass-checksum-check" class="headerlink" title="Bypass checksum check"></a>Bypass checksum check</h3><p>对于checksum 的处理，REDQUEEN 采取的解决方式很直观，一共分成三个步骤：</p>
<ul>
<li><p>Identify</p>
<p> - 在程式中找出长得像是checksum check 的处理，而checksum check 的程式码pattern 是以研究人员的观察为基础</p>
<ul>
<li>我并没有很了解论文中对这部分的叙述，因此在这边就不介绍</li>
</ul>
</li>
<li><p>Patch</p>
<p> - 暂时将checksum check 的结果patch 成永远成立</p>
<ul>
<li>如果此时fuzzer 因为这个patch 而走到新的路径，则进入validation mode</li>
</ul>
</li>
<li><p>Veriﬁcation</p>
<p> - 将其视为bypass magic number check 的情况，尝试产生满足该检查的input。最后把patch 拿掉重新执行，如果能通过条件比对的话，就将此input 放入input queue 当中</p>
<ul>
<li>如果patch 了多个条件，就由最深的条件开始处理</li>
</ul>
</li>
</ul>
<p>仍以先前的程式码为例，假设初始input 为<code>&quot;01234567abcdefghRQ&quot;</code>，在一开始执行时checksum check (1) (2) 都会暂时被patch：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(u64(input) == sum(input+8, len-8)) // (1)</span><br><span class="line">	if(u64(input+8) == sum(input+16, len-16)) // (2)</span><br><span class="line">		if(input[16] == &#x27;R&#x27; &amp;&amp; input[17] == &#x27;Q&#x27;) // 不考慮</span><br><span class="line">	    	bug(2);</span><br></pre></td></tr></table></figure>

<p>当触发<code>bug(2)</code>，则REDQUEEN 进入到validation mode，将checksum check (2) 加回来，并产生可以满足条件的input，最后得到input <code>&quot;01234567\xa3\0\0\0\0\0\0\0RQ&quot;</code>，当input 确定可以走到<code>bug(2)</code>，就会被加到input queue 当中。而后重复相同的行为，把checksum sum (1) 加回来，产生可以满足条件的input，最后得到input <code>&quot;\x46\x01\0\0\0\0\0\0\xa3\0\0\0\0\0\0\0RQ&quot;</code>，验证成功后就能产生crash report，代表顺利处理掉checksum check。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>在处理magic number check 的部分，也有论文提出将一个大的比对处理切成许多小部分的方法，可行的原因在于，fuzzer 分别满足条件，比一次满足所有条件还要简单许多。以先前<code>&quot;MAGICHDR&quot;</code>的比对处理为例，如果换成下方程式码的形式，则代表每次input 只需要满足外层的if 条件，就会走到下一个if 条件，产生新的path，fuzzer 原本就会对能走到新path 的input 有兴趣，借此不断诱导fuzzer 产生input 满组每一个比对条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(input[0] == &#x27;R&#x27;)</span><br><span class="line">    if(input[1] == &#x27;D&#x27;)</span><br><span class="line">        if(input[2] == &#x27;H&#x27;)</span><br><span class="line">            if(input[3] == &#x27;C&#x27;)</span><br><span class="line">                if(input[4] == &#x27;I&#x27;)</span><br><span class="line">                    if(input[5] == &#x27;G&#x27;)</span><br><span class="line">                        if(input[6] == &#x27;A&#x27;)</span><br><span class="line">                            if(input[7] == &#x27;M&#x27;)</span><br><span class="line">							    bug(1);</span><br></pre></td></tr></table></figure>

<p>不过REDQUEEN 提出的作法对fuzzing 领域有很大的影响，实际上这篇论文我已经看了三次，每次看都还是会对一些细节感到困惑，不过借着今天的介绍，我也算是好好整理出对REDQUEEN 机制的理解。如果内容有误或是对内文有问题，都欢迎在下方留言区做讨论。</p>
<h1 id="Day-20-优化seed-selection"><a href="#Day-20-优化seed-selection" class="headerlink" title="[Day 20] 优化seed selection"></a>[Day 20] 优化seed selection</h1><p>Seed selection 指的是fuzzer 从input queue 当中挑选input 的行为，而fuzzer 会先挑哪个input 是由input 的价值(或者说优先度) 来决定，不过如何恒定input 的价值见仁见智，但通常都会把<strong>执行时间</strong>与<strong>新增的path 数量</strong>考虑进去，如果程式会处理档案，也会把<strong>档案大小</strong>纳入评分标准。</p>
<p>即使有数千个seed selection algorithm，但衡量各自的品质也是难处之一，于是在2014 年就有人发表论文<a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-rebert.pdf">Optimizing Seed Selection for Fuzzing</a>提出测量标准，并且透过相关的实验得出某些常见演算法的好坏。</p>
<p>虽然先前没有特别提到hypervisor fuzzer 与OS fuzzer，但必须知道的是，当target 位于不同的ring level (eg OS, hypervisor)，有可能会有专属的seed selection algorithm，像是<a target="_blank" rel="noopener" href="https://www.usenix.org/conference/usenixsecurity18/presentation/pailoor">MoonShine: Optimizing OS Fuzzer Seed Selection with Trace Distillation</a>就是针对OS fuzzer 做优化，所以没办法实作在一般的userspace fuzzer 或hypervisor fuzzer。</p>
<p>接下来会介绍论文<a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-rebert.pdf">Optimizing Seed Selection for Fuzzing</a>，了解其研究方法与过程，对整个seed selection 的优化方式做overview。</p>
<h2 id="Optimizing-Seed-Selection-for-Fuzzing"><a href="#Optimizing-Seed-Selection-for-Fuzzing" class="headerlink" title="Optimizing Seed Selection for Fuzzing"></a>Optimizing Seed Selection for Fuzzing</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>在此论文之前多多少少有做相关的研究，总结来说<strong>code coverage</strong>一定是第一个看的，毕竟执行速度在快、档案在小，只要没走到新的path 都没用。不过通常一个seed 并不能代表整个执行状态，因此论文中使用了<strong>set covering problem</strong>来更好的分析，下面就对论文提出的一些变数做介绍：</p>
<ul>
<li><p>假设程式的输入是一个档案，使用者会先决定一个<code>n</code>，代表每用<code>n</code>个档案执行后就做一次coverage 分析</p>
</li>
<li><p>以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = 6</span><br></pre></td></tr></table></figure>

<p>为例子，以数字作为basic block 的编号的情况下，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S-N</span><br></pre></td></tr></table></figure>

<p>代表第</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N</span><br></pre></td></tr></table></figure>

<p>个档案作为input 时所执行到的basic block</p>
<ul>
<li><code>S-1 = &#123;1,2,3,4,5,6&#125;</code>，代表走到1 … 6 的basic block</li>
</ul>
</li>
<li><p>变数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X</span><br></pre></td></tr></table></figure>

<p>代表所有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S-N</span><br></pre></td></tr></table></figure>

<p>的联集，也就是这组input 可以走到哪些basic block</p>
<ul>
<li>同个数字的basic block 可能会来自不同的档案，代表这些档案都能够让程式执行到该basic block</li>
</ul>
</li>
<li><p>将</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X</span><br></pre></td></tr></table></figure>

<p>尝试用不同的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S-N</span><br></pre></td></tr></table></figure>

<p>组合起来，并用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C-M</span><br></pre></td></tr></table></figure>

<p>表示，也就是说如果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C-1 = &#123;S-1, S-2&#125;</span><br></pre></td></tr></table></figure>

<p>，就代表只需要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S-1</span><br></pre></td></tr></table></figure>

<p>与</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S-2</span><br></pre></td></tr></table></figure>

<p>就能走到所有的basic block</p>
<ul>
<li>在此情况下<code>C-2 = &#123;S-1, S-2, S-3&#125;</code>也满足条件，虽然<code>S-3</code>并非必要</li>
</ul>
</li>
</ul>
<p>不过如果要求得最小的<code>C-N</code>，就是要解**minimal set covering problem (MSCP)**，但是这是一个NP-hard problem，所以只能用一些估算的方式求得。而MSCP 还有一个可选参数<code>k</code>，<code>k-MSCP</code>代表在set 当中最多只能有<code>k</code>个元素，并且不在要求覆盖所有的basic block，而是求得最大值。</p>
<p>假设可以求出MSCP 的多个解，又因为这些解当中的每个seed 元素都有对应的属性，像是执行时间、档案大小等等，可以再透过<strong>weighted</strong> MSCP (WMSCP) 求出不同weight (ie执行时间、档案大小) 的最小set，意即这组解的总共花的执行时间最少、档案大小的总和最少等等。</p>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>论文以下面几种常见的seed selection algorithm 作为测量对象，执行目标已经被设计成存在一些bug，所有algorithm 都接收 个<code>|F|</code>档案作为seed，并使用其中的<code>k</code>个档案做优化并测试：</p>
<ul>
<li><strong>MINSET</strong></li>
<li><strong>TIME MINSET</strong> - 执行时间最少的MSCP 解</li>
<li><strong>SIZE MINSET</strong> - 档案大小最小的MSCP 解</li>
<li><strong>PEACH SET</strong> - 工具peach 自己写的演算法</li>
<li><strong>RANDOM SET</strong> - 随便选k 个</li>
<li><strong>HOT SET</strong> - 将每个seed ( <code>|F|</code>) 个别fuzz 给定的时间<code>t</code>，并以找到bug 的数量取出前<code>k</code>个seed</li>
</ul>
<h3 id="Hypothesis"><a href="#Hypothesis" class="headerlink" title="Hypothesis"></a>Hypothesis</h3><p>对于实验，论文提出了四种实验结果的假设：</p>
<ul>
<li><p><strong>MINSET &gt; RANDOM</strong> - 在参数<code>k</code>相同的情况下，MINSET 找bug 能力比RANDOM SET 好</p>
</li>
<li><p><strong>MINSET 的Beneﬁts &gt; Cost</strong> - 将MINSET 的计算考虑进去后，成效还是会比一般的fuzzing 好</p>
</li>
<li><p><strong>MINSET Transferability</strong> - 相同性质的两个程式AB，将程式A 的MINSET 给程式B 使用，会有差不多的效果</p>
</li>
<li><p>MINSET Data Reduction</p>
<p> - 使用MINSET 的效果比整个seed</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|F|</span><br></pre></td></tr></table></figure>

<p>还要好</p>
<ul>
<li>这个假设似乎跟第一点有部分重叠</li>
</ul>
</li>
</ul>
<h3 id="Quality"><a href="#Quality" class="headerlink" title="Quality"></a>Quality</h3><p>假设需要测试AB 演算法，则最简单的做法就是直接取出seed subset，之后做seed selection algorithm，执行相同时间后比较结果即可。然而研究人员认为这样的方法虽然只能知道特定subset 适合的algorithm，并不能代表符合所有的情况。</p>
<p>因此研究人员决定在测量之前，先将所有的seed<code>si</code>个别执行给定的<code>t</code>时间，并记录找到的bug 数量，将前几个找到最多bug 的seed 视为<strong>optimal case</strong>，之后在实际测量是就以这组seed 作为<strong>initial seed</strong>，借此可以找出各个演算法的<strong>upper bound</strong>，确保实验结果的公平。</p>
<p>论文中还有介绍求得optimal case 的过程，不过中间掺杂许多数学运算，在此就不做介绍。</p>
<h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><ol>
<li><strong>是否提出的seed selection algorithm 比random 好</strong>- PEACH SET 跟TIME MINSET 与RANDOM 较为接近，剩下几个都远比RANDOM 好</li>
<li><strong>哪个seed selection algorithm 表现最好</strong>- (UNWEIGHTED) MINSET</li>
<li><strong>Data reduction 是否有用</strong>- 非常有用</li>
<li><strong>是否具有Transferability</strong> - 如果程式行为类似，并且输入的档案形式相同，MINSET 才具有转移性</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>目前一般的fuzzer 都已经会参考执行时间跟输入大小来评估input 价值，但就没有额外使用MINSET 做分析。如果想要更优化seed selection，根据论文的实验结果，可以实作演算法在静态&#x2F;动态挑出重要的几个seed 为<strong>MINSET</strong>，并且以<strong>输入大小</strong>为主要评估依据(TIME MINSET 实验结果较差)，这样应该就能产生比较好的效果。</p>
<h1 id="Day-21-优化mutation-MOpt"><a href="#Day-21-优化mutation-MOpt" class="headerlink" title="[Day 21] 优化mutation - MOpt"></a>[Day 21] 优化mutation - MOpt</h1><p>今天要介绍的是优化mutation 的方法，同时这也是优化fuzzer 系列的最后一篇文章。 Mutation 中文翻译为变异，也就是对input 做随机化的处理，不过即使是随机化，通常也会制定一系列有意义的随机操作，并不是完全的”随机”。</p>
<p>以AFL 来说，当对input 做mutation 时，会依序进入deterministic 阶段、havoc 阶段与splice 阶段，各阶段所做的操作如下：</p>
<ul>
<li><p>Deterministic 阶段</p>
<p>- 依序对input 的部分范围做</p>
<ul>
<li>Bitflip - 位元反转(0 –&gt; 1, 1 –&gt; 0)</li>
<li>Arith - 加减运算</li>
<li>Interest - 替换成edge value，像是INT_MAX、0、-1 等等</li>
</ul>
</li>
<li><p><strong>Havoc 阶段</strong>- 尽量破坏整个input 的架构，因此<strong>随机</strong>执行deterministic 阶段的操作，并且新增了删除、增加、覆盖字元的操作</p>
</li>
<li><p><strong>Splice 阶段</strong>- 当前两个阶段都没效才会走到，会将input 拼接上不同的seed</p>
</li>
</ul>
<p>因此实际上这些半随机的行为是可以被调整的，其中论文<a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/sec19-lyu.pdf">MOpt: Optimized Mutation Scheduling for Fuzzers</a>将已知的演算法应用在mutation 做优化，并且由于模型已经透过数学证明有效，所以不用担心是否单纯只是heuristic。最后测试结果表示，比起一般的mutation 策略，MOpt 在同样的时间内找到了更多的bug。</p>
<p>接下来会从MOpt 的论文著手，探讨研究人员的观察与发现，以及如何将<strong>粒子群最佳化</strong>演算法实作在mutation，有效提升fuzzing 的能力。</p>
<h2 id="Mopt"><a href="#Mopt" class="headerlink" title="Mopt"></a>Mopt</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>AFL 的mutation 操作有一定的意义在，因为如果程式没有特别对整数做检查，输入edge value 确实很容易造成integer overflow&#x2F;underflow，导致程式执行不符合预期，但这也产生一个疑问：如果input 只会被视为纯字串，那比起把一些bytes 替换成edge value，反而增加字串长度会比较有可能戳到漏洞，像是buffer overflow？更精确来说，是否每个程式都有<strong>比较适合</strong>的mutation 操作？</p>
<p>研究人员提出了这个疑问，并且实际做了一些测试，而实验结果也证明了这个猜想是正确的，对于不同的程式，有些input 做bitflip 就会产生比较多path，有些反而是arith 操作比较有效。以此为基础，如果fuzzer 能够自动找到适合的mutation 操作，或许就能有效提升coverage，要做到这件事情也很直观：</p>
<ul>
<li>先使用预设的mutation 顺序与次数，并将各个操作走到的新path 个数记录起来</li>
<li>每经过一个周期就检查一次纪录，依据new path 的个数将mutation 操作的优先度从高排到低</li>
<li>根据优先度调整不同mutation 操作的执行顺序与执行次数</li>
</ul>
<p>不过MOpt 的实作方式又更聪明一些，他将mutation 的操作对应到<strong>粒子群最佳化</strong>演算法，也就是**Particle Swarm Optimization (PSO)**，让fuzzer 能找到当前较为适合的mutation 策略。接下来会介绍PSO 以及MOpt 是如何将fuzzing 的机制对应到演算法的变数。</p>
<h3 id="PSO-amp-mutation"><a href="#PSO-amp-mutation" class="headerlink" title="PSO &amp; mutation"></a>PSO &amp; mutation</h3><p>PSO 是一个能在没有太多资讯的情况下，有效找到<strong>局部最佳解</strong>的演算法，而下方会根据<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96">维基百科</a>定义，为PSO 演算法做详细的介绍。</p>
<h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>将每个个体看作是D 维搜寻空间中的一个没有体积的微粒(点)，这群微粒在第d+1 维(1 ≤ d+1 ≤ D) 的变化为方程式1： $$ \left . \begin{align} &amp; v_{id+1} &#x3D; w \cdot v_{id} + c_1 \cdot rand() \cdot (p_{id} - x_{id}) + c2 \cdot Rand() \cdot (p_{gd}-x_{id}) \tag{1-a} \</p>
<p>&amp; x_{id+1} &#x3D; x_{id} + v_{id+1} \tag{1-b} \end{align} \right. $$</p>
<ul>
<li>第i 个微粒的适应值表示为Xi &#x3D; (xi1, xi2, …, xiD)</li>
<li>位置为Pi &#x3D; (pi1, pi2, …, piD)，最好的位置称为pbest (也就是yi1, yi2, …)</li>
<li>所有微粒经历过的最好位置的index 用符号g 表示，即Pg，也称为gbest</li>
<li>微粒i 的速度用Vi &#x3D; (vi1, vi2, …, viD) 表示</li>
<li>w 为惯性权重</li>
<li>c1 和c2 为加速常数</li>
<li>rand() 和Rand() 为两个在[0,1] 范围中变化的随机值</li>
</ul>
<h4 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h4><p>标准的PSO 执行流程如下：</p>
<ol>
<li>初始化一群微粒(群体规模为m)，包括随机的位置和速度</li>
<li>评价每个微粒的适应度</li>
<li>对每个微粒，将它的适应值和它经历过的最好位置pbest 的做比较，如果较好，则将其视为当前最佳pbest</li>
<li>对每个微粒，将它的适应值和全域所经历最好位置gbest 的做比较，如果较好，则重新设定gbest 的index</li>
<li>根据方程式(1) 变化微粒的速度和位置</li>
<li>如果没有达到结束条件就回到步骤 2</li>
</ol>
<p>简单来说，每个微粒个体的位置会不断做更新，而每次更新会建立在惯性、常数与随机性，并且数学式参考了局部最佳与历史最佳位置，让微粒群同时具备<strong>全域搜寻</strong>与<strong>局部搜寻</strong>能力。</p>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><p>MOpt 将fuzzing 使用到的机制与PSO 做对应，将MOPT 的微粒对应到mutation 操作，而这些微粒试图在事先定义好的机率空间探索最佳位置，也就是产生最多interesting test 的地方，x 则代表着mutation 操作被选到的机率。两者名词对照如下：</p>
<ul>
<li>Mutation 操作→ 微粒 i</li>
<li>所有Mutation 操作→ 微粒群(swarm)</li>
<li>Mutation 操作被选到的机率→ 适应值xi</li>
<li>Mutation 操作产生的interesting test - 位置pi</li>
<li>Mutation 操作产生最多interesting test - 局部最佳位置pbest</li>
<li>所有Mutation 操作中产生最多interesting test - 全域最佳位置gbest</li>
</ul>
<p>而其他常数就根据使用者需求给予初始值，不过因为被挑选的机率总和应该要是1，因此MOpt 有对更新结果做标准化。</p>
<p>MOpt 也额外定义名词efficiency，定义为”找到的interesting test” 除以”更新时该mutation 操作做了几次”，efficiency 也分成local、global 以及now，分别为局部最佳、全域最佳以及当前的eifficiency。我自己将efficiency 定义成”interesting test 数量” 除以”机率”，其实就是斜率(y&#x2F;x)。</p>
<p>为了避免特定操作进到局部最佳解，因此MOpt 还使用<strong>多个微粒群</strong>做计算，并且让微粒的更新直接参考所有微粒群中的最佳位置。</p>
<p>最后fuzzer 会选择<strong>最好的swarm</strong>做为各个mutation 操作的机率，后续在fuzzing 时就能使用优化过的mutation 策略。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>这个做法听起来就很有用，先测量每个mutation 操作的好坏，之后fuzzing 时就倾向使用较好的mutation 操作，降低不必要或没什么用的mutation 的执行机率，况且MOpt 使用的PSO 演算法还有用数学证明过有效。我看过不少直接将数学模型或演算法引入fuzzer 的论文，而且都是发在不错的会议，或许对mutation 优化有兴趣的读者，可以找找有哪些模型或演算法可以对应上去，如果实验结果很好，就可以投稿看看了。</p>
<hr>
<p>这几天介绍了fuzzer 的优化，加上先前文章的介绍，读者应该已经对于userspace fuzzing 有非常深入的理解，剩下的几天会介绍<strong>OS</strong> fuzzer 与<strong>hypervisor</strong> fuzzer，前者会介绍kAFL 与syzkaller 的实作机制，其中syzkaller 已经成为OS fuzzer 的翘楚；后者会介绍nyx，如果还有时间也会介绍hyperCube。</p>
<h1 id="Day-22-OS-fuzzer-kAFL-论文-概念总览-amp-背景知识"><a href="#Day-22-OS-fuzzer-kAFL-论文-概念总览-amp-背景知识" class="headerlink" title="[Day 22] OS fuzzer - kAFL 论文- 概念总览&amp; 背景知识"></a>[Day 22] OS fuzzer - kAFL 论文- 概念总览&amp; 背景知识</h1><p>先前介绍的fuzzer 如果没有特别说明，基本上目标都是执行在userspace 的程式，然而当fuzzing 这个主题越来越热门，开始有研究人员思考是否可以把这个概念实作在不同层级的目标，因为只要目标有办法喂入输入并取得feedback (也许不限于coverage)，就能透过fuzzer 逐步调整input，让目标执行到更广更深的处理，同时先前研究的优化方法也能重新使用。在这个概念上，针对各种会需要执行程式，并且有办法得到输出的目标，都能尝试接上fuzzer 自动化找程式漏洞，例如IOT fuzzer、firmware fuzzer 等各式各样的fuzzer，也包含这几天要介绍的OS fuzzer (kernel fuzzer) 与hypervisor fuzzer，而OS 又因为大多数的情况一定会用到，因此OS fuzzer 的研究又特别热门。</p>
<p>如果将OS 视为一个codebase 很大的程式，撇开interrupt handler 那种基础机制不说，程式的输入就是来自userspace 的system call，输出直观来看就是return code，代表有没有成功执行。</p>
<p>如果将hypervisor 视为目标，那输入基本上就是在虚拟机中使用PIO 或MMIO 对模拟的硬体设备做存取，输出就是看硬体设备暂存器所存放的回传值。</p>
<h2 id="OS-fuzzer"><a href="#OS-fuzzer" class="headerlink" title="OS fuzzer"></a>OS fuzzer</h2><p><strong>OS fuzzer</strong>泛指以OS 为fuzzing 对象的fuzzer，并且OS 不限于Linux，其他像是以Windows、FreeBSD 为目标的fuzzer 也算在内，不过这边基本上只会介绍Linux fuzzer。在我的知识范围中，最著代表性的两个Linux kernel fuzzer 分别是<a target="_blank" rel="noopener" href="https://github.com/RUB-SysSec/kAFL">kAFL</a>与<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller">syzkaller</a>，两者都是以Linux kernel 为目标(虽然现在也支援其他作业系统)，前者全名为kernel-AFL，从名字就能知道它的重要性；后者为google 开发的fuzzing 框架，具有效能不差、好部署、资讯完全、客制化方便等优点，成为了目前Linux kernel fuzzer 的龙头。</p>
<p>虽然现在直接google 搜寻”linux kernel fuzzer”，大概有一半的结果都与syzkaller 有关，但稍微推算一下时间，kAFL 应该是早于syzkaller 开始，并在OS fuzzer 讨论初期为相较成熟的fuzzer。接下来会介绍kAFL 使用到的机制与实作方式，一开始以论文<a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-schumilo.pdf">kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels</a>介绍整个框架，而后透过原始码来深入了解内部运作。</p>
<blockquote>
<p>kAFL 为2017 年发表论文，因此在2016 年时应该就实作的差不多了，反之syzkaller 虽然在<a target="_blank" rel="noopener" href="https://blog.linuxplumbersconf.org/2016/ocw/system/presentations/3561/original/Syzkaller.pdf">2016 年</a>被提出来，但到了2018 年有较为成熟的框架。</p>
</blockquote>
<h2 id="kAFL-paper"><a href="#kAFL-paper" class="headerlink" title="kAFL paper"></a>kAFL paper</h2><h3 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h3><p>可以将整个kernel fuzzing 的执行流程拆成下面几个部分讨论：</p>
<ul>
<li><strong>产生输入</strong>- 程式是透过system call 喂input 给作业系统，跟userspace 程式单纯吃byte stream 或档案不相同，因此对kernel fuzzing 来说，要产生的输入是system call</li>
<li><strong>喂进输入</strong>- 呼叫一连串产生出来的system call sequence</li>
<li><strong>得到回馈</strong>- 一般来说system call 的执行结果会是回传值，但fuzzing 想要得到的是code coverage</li>
</ul>
<p>与先前所介绍的fuzzing 知识结合，能提出一些关键问题以及可能解法：</p>
<ul>
<li><p>产生输入</p>
<ul>
<li>如果是单纯产生system call 很简单，但要产生<strong>有意义</strong>的system call 很难，各个system call 都有自己的参数与使用条件，像是<code>read()</code>会需要合法的file descriptor，如果直接传入记忆体位址或是fd非法都会失败</li>
<li>如果能产生有意义的system call 参数，字串的变异方式应该会需要跟整数的不相同，怎么对不同型态的参数做mutation 才会有意义<ul>
<li>针对不同型态的设计不同的mutation 操作</li>
</ul>
</li>
<li>如果能取得code coverage，则seed selection 并不会有什么太大的问题</li>
</ul>
</li>
<li><p>喂进输入</p>
<ul>
<li><p>会需要有一个程式需要持续呼叫system call sequence，并在执行完该次的输入后，要想办法跟fuzzer 取得下一次的输入，这个程式被称作</p>
<p>harness</p>
<ul>
<li>直观的解法就是将产生出来的sequence 做序列化后存到档案中，再由harness 反序列化后读到程式内执行</li>
</ul>
</li>
</ul>
</li>
<li><p>得到回馈</p>
<ul>
<li>如果Linux kernel 当中已经有现成的coverage collection feature 就可以直接拿来用，否则只能使用硬体或是DBT 来搜集<ul>
<li>根据<a target="_blank" rel="noopener" href="https://lwn.net/Articles/671640/">lwn 文章</a>所述，KCOV 在2016 年就已经支援，而开发人员就是syzkaller 的维护者<a target="_blank" rel="noopener" href="https://github.com/dvyukov">dvyukov</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>首先kAFL 一共使用到以下两个主要的机制来建构fuzzing 环境，而下方条列也对各机制做介绍：</p>
<ul>
<li><p>Intel-VX</p>
<p> - 由Intel 开发的硬体支援的模拟执行技术</p>
<ul>
<li>如果直接fuzz host 环境，不但可能会因为syscall 的操作弄脏环境，当戳到洞的时候有可能会因为panic 导致系统没有储存到input，因此通常fuzzing OS 时会跑在虚拟机里面</li>
<li>在没有硬体支援的情况下，通常会使用system level 的虚拟化技术模拟作业系统的执行环境，相关的工具有QEMU，其实底层就是DBT 与硬体设备虚拟化的实作，虽然可行但就是执行效果不好</li>
<li>如果有硬体支援，就可以执行一些特殊的instruction，让CPU 建立虚拟机的环境并执行，这样效果基本上跟原生(native) 环境差不了多少</li>
<li>kAFL 避免效能太低，因此使用了<strong>Intel-VX</strong>来执行虚拟机</li>
</ul>
</li>
<li><p>Intel-PT</p>
<p> - Intel 提供的追踪程式特定行为的指令集(Day15 有对Intel-PT 做详细介绍)</p>
<ul>
<li>kAFL 选择使用硬体指令集取得coverage 而非DBT，是因为kernel 并非透过DBT 执行</li>
<li>目前透过linux feature KCOV 可以做到kernel code coverage collection，但可能因为该技术在当时没有这么成熟，所以kAFL 没有使用(或者有可能因为是敌人开发的技术)</li>
</ul>
</li>
</ul>
<h4 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h4><p>对于没有hypervisor 相关知识的读者，在此做一些基本的介绍。</p>
<p>虚拟化技术一开始只是因为过去硬体太贵，所以为了最大化硬体资源，有人想到是否可以在电脑里面再开一台电脑，这样如果需要使用两台电脑的环境，就不用物理上再买另一台电脑了。随着技术的开发，<strong>QEMU</strong> (Quick EMUlator) 成功做到在原本的作业系统上，以userspace 的程式模拟运行另一个作业系统，这也称作full-system emulation。虽然能成功运行，但代价就是效能上面的不足，因为原本native 环境也许只是一行instruction 能做到的事情，但透过模拟执行就可能要数百数千行instruction，因此一些CPU 厂商就开始设计用硬体的方式执行虚拟环境，所以有了<strong>Intel-VX</strong>以及<strong>AMD-V</strong>的出现。此外arm 指令集也能透过EL2 的相关设定与操作，建置虚拟机的执行环境，细节请参考<a target="_blank" rel="noopener" href="http://www.cs.columbia.edu/~cdall/pubs/KVMARM_talk.pdf">KVM&#x2F;ARM: The Design and Implementation of the Linux ARM Hypervisor</a>。</p>
<p>上述的虚拟化技术只是浅层皮毛，实际上有非常多细节与机制没有介绍到，不过做overview 已经算足够了。接下来介绍一些虚拟化技术的名词定义：</p>
<ul>
<li><strong>VM (virtual machine)</strong> - 正在被模拟执行的作业系统</li>
<li><strong>Host</strong> - 原本使用者所在的环境</li>
<li><strong>Guest</strong> - VM 内的环境</li>
<li><strong>Virtual machine monitor (VMM, 又称作hypervisor)</strong> - 在host 执行的程式，负责将VM 运行起来</li>
<li><strong>Hypercall</strong> - VM 用来请求hypervisor 的一些特权操作，类似于instruction<code>syscall</code>的定位，只是将userspace 与kernel 的角色换成hypervisor 与VM</li>
</ul>
<p>大量化简后的VM 与VMM 互动如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281113292.png" alt="image-20241028111357218"></p>
<ul>
<li>当OS 跑在虚拟机后，guest 使用的作业系统会在VM 里面执行(guest)，如果没有特别设置，interrupt 也会在VM 当中处理，不会跳到外面(host)</li>
<li>若VM 执行到特权指令( <code>hypercall</code>)，则会发生trap 到host，之后将trap 资讯转给hypervisor 做处理</li>
<li>当硬体暂存器与主机的memory 做mapping 后，就可以使用MMIO &#x2F; PIO 来存取硬体。如果尝试在VM 当中存取，因为两者底层都是用模拟出来的device handler 来处理，因此会先trap 到hypervisor，再由hypervisor 的device emulation component 模拟硬体行为</li>
</ul>
<hr>
<p>今天从设计者的角度分析kernel fuzzer 的实作方式与挑战，为虚拟化技术做了简单的介绍，同时这些也是kAFL 使用到的技术。明天会介绍论文提出的kAFL 架构设计，并再透过2~3 天的时间介绍原始码，深入了解实作方法。</p>
<h1 id="Day-23-OS-fuzzer-kAFL-论文-设计框架-amp-实验结果"><a href="#Day-23-OS-fuzzer-kAFL-论文-设计框架-amp-实验结果" class="headerlink" title="[Day 23] OS fuzzer - kAFL 论文- 设计框架&amp; 实验结果"></a>[Day 23] OS fuzzer - kAFL 论文- 设计框架&amp; 实验结果</h1><p>昨天花了满大的篇幅介绍虚拟化技术，今天会着重在kAFL 论文提出的设计架构。</p>
<h3 id="Design-1"><a href="#Design-1" class="headerlink" title="Design"></a>Design</h3><p>kAFL 将整个系统分成三个component：</p>
<ul>
<li>kAFL-fuzzer<ul>
<li><strong>Loader</strong> - 执行在虚拟机的userspace，负责接收来自fuzzer 的程式码(assembly code) 并执行，而这段程式码也就对应不同的agent</li>
<li><strong>Agent</strong> - 呼叫一连串的system call sequence，同时也负责接收由fuzzer 传入已经变异好的payload</li>
<li><strong>Fuzzer</strong> - 除了做fuzzing strategy 之外，也包含建立执行环境、向loader 发号施令</li>
</ul>
</li>
<li><strong>QEMU-PT</strong> - 修改后的QEMU，建立与虚拟机沟通的桥梁如shared memory，同时也负责解析Intel-PT packet，将执行结果送给kAFL-fuzzer</li>
<li><strong>KVM-PT</strong> - 修改后的KVM，用来设定Intel-PT、接收VM 传送的hypercall 命令</li>
</ul>
<h3 id="Workflow-1"><a href="#Workflow-1" class="headerlink" title="Workflow"></a>Workflow</h3><p>整个执行流程如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281114950.png" alt="img"></p>
<ol>
<li>运行在VM 的loader 会<strong>执行hypercall</strong>传送<code>HC_SUBMIT_CRASH</code>命令，通知QEMU-PT 为VM 装一个crash handler，用来处理VM kernel crash。同时当QEMU-PT 收到此命令，也代表loader 确实有执行起来</li>
<li>Loader 会在初始化后发送一个<code>HC_GET_PROGRAM</code>命令给fuzzer，fuzzer 就会把agent 的执行档内容传给loader</li>
<li>Loader 被替换成agent (by <code>execve()</code>) 后，agent 会透过<code>HC_SUBMIT_CR3</code>将存放page table 位址的cr3 暂存器的内容传给QEMU-PT，这样QEMU-PT 就可以直接修改记忆体来传送payload。处理后还会送一个<code>HC_SUBMIT_BUFFER</code>命令把用来存放payload 的buffer 位址传给QEMU-PT</li>
<li>Agent 用<code>HC_GET_INPUT</code>跟fuzzer 请求输入，而fuzzer 就会进行mutation 并产生input，传送给QEMU-PT 做处理</li>
<li>QEMU-PT 有在步骤3 取得buffer 位址，因此直接将payload 复制到buffer 当中，同时也会通知KVM-PT 开启Intel-PT 来搜集VM kernel code coverage</li>
<li>Agent 一检查到payload buffer 有资料，就会以此作为参数值来执行system call</li>
<li>执行结束后在送<code>HC_FINISHED</code>，通知QEMU-PT 此轮执行完毕，可以叫KVM-PT 停止Intel-PT</li>
<li>QEMU-PT 通知KVM-PT 停止继续tracing，并解析Intel-PT 的packet，最后将结果送给fuzzer 做分析</li>
</ol>
<p>而后整个kAFL 会不断重复步骤4~8，让host fuzzer 能够以agent 呼叫syscall 产生的coverage 为feedback，不断改进input payload，借此探索到更多的程式码。</p>
<h3 id="Evaluation-1"><a href="#Evaluation-1" class="headerlink" title="Evaluation"></a>Evaluation</h3><p>实验使用一台Thinkpad laptop，拥有<a href="mailto:i7-6700HQ@2.6GHz">i7-6700HQ@2.6GHz</a> CPU 跟32GB RAM，然后因为当时没有太多的kernel fuzzer，加上他们说因为实作的机制不相同，因此没办法与syzkaller ，所以实验结果通常都直接呈现。</p>
<p>单纯就执行效率来说，论文实测kAFL 每秒执行程式的次数能达到6830 次，我是觉得这个实验数据不准，或是使用了一些话术做包装，因为<code>hypercall</code>本身是一个很昂贵的instruction，从VM trap 到host 需要保存一次执行状态，host 到VM 又要载入原本的执行状态，而执行一次程式要做2 个hypercall，但效能却可以跟一些简单操作的userspace fuzzer 相同。也有可能是因为他没有说明详细的测试环境，说不定在他设计的测试环境中确实可以跑出不错的效果。</p>
<p>然后如果有在看fuzzing 相关的论文，不少篇都会提到不使用Intel-PT 的原因在于处理packet 会有一定的overhead，不过处理packet 造成多少额外的overhead 并没有提及，单纯只有提到比现有的decoder 好上不少。</p>
<p>最后，kAFL 的agent 似乎只能fuzzing kernel 的filesystem，也就是执行一连串固定与filesystem 沟通的system call，mutation 的对象是参数内的资料。</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>综合来讲，kAFL 整个框架设计带给我满大的启发，当然感觉还是有很多可以优化的地方，但身为一个OS fuzzer 的拓荒者之一，不论是虚拟化或是硬体搜集coverage，这样的设计已经充分利用当时的技术，但因为没办法自定义system call 的格式，加上依赖QEMU 与KVM 的版本，在可扩充性与携带性不足的情况下，使用人数渐渐不如syzkaller。</p>
<h2 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code"></a>Source code</h2><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>首先kAFL 论文在发布时使用的程式码为<a target="_blank" rel="noopener" href="https://github.com/RUB-SysSec/kAFL">RUB-SysSec</a>组织所发布的版本，但目前仍有在维护的版本则是<a target="_blank" rel="noopener" href="https://github.com/IntelLabs/kAFL">IntelLabs</a>所拥有，在此以前者的程式码为主。整个kAFL repo 根据功能拆成不同的目录，而功能种类就跟论文介绍一样：</p>
<ul>
<li>kAFL-Fuzzer</li>
<li>QEMU-PT</li>
<li>KVM-PT</li>
</ul>
<hr>
<p>明天会介绍<strong>QEMU-PT</strong>与<strong>KVM-PT</strong>的实作方法，究竟对现有的工具QEMU 与KVM 做了哪些patch，是怎样透过这些改动让host 能与VM 按照论文所提出的方法传递资料。而后天会介绍loader&#x2F;agent&#x2F;fuzzer 是如何共存在kAFL-Fuzzer 目录，也会再次介绍论文提出的执行流程与实作方法。</p>
<h1 id="Day-24-OS-fuzzer-kAFL-原始码-Patched-QEMU-amp-KVM"><a href="#Day-24-OS-fuzzer-kAFL-原始码-Patched-QEMU-amp-KVM" class="headerlink" title="[Day 24] OS fuzzer - kAFL 原始码- Patched QEMU &amp; KVM"></a>[Day 24] OS fuzzer - kAFL 原始码- Patched QEMU &amp; KVM</h1><p>由于kAFL 是透过instruction<code>hypercall</code>在host 与guest (VM) 之间交换资讯，因此需要新增客制化的<code>hypercall</code>handler。并且搜集coverage 使用的是Intel-PT，因此也需要在hypervisor 内执行相关设定。因为这些缘故，所以kAFL 对QEMU 与KVM 做了一些更动，目的就是要支援这些功能。接下来会介绍kAFL 分别对QEMU 与KVM 做了哪些程式码的更动，以及这些更动的目的为何。</p>
<h3 id="KVM-PT"><a href="#KVM-PT" class="headerlink" title="KVM-PT"></a>KVM-PT</h3><p>KVM-PT 的档案架构如下，有些档案比较没什么特别的，像是Makefile 就是新增一些编译时的参数，这就不会额外说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── arch</span><br><span class="line">│   └── x86</span><br><span class="line">│       ├── include</span><br><span class="line">│       │   ├── asm</span><br><span class="line">│       │   │   └── kvm_host.h.patch</span><br><span class="line">│       │   └── uapi</span><br><span class="line">│       │       └── asm</span><br><span class="line">│       │           └── kvm.h.patch</span><br><span class="line">│       └── kvm</span><br><span class="line">│           ├── vmx.c.patch</span><br><span class="line">│           ├── vmx.h</span><br><span class="line">│           ├── vmx_pt.c</span><br><span class="line">│           ├── vmx_pt.h</span><br><span class="line">│           └── x86.c.patch</span><br><span class="line">└── include</span><br><span class="line">    └── uapi</span><br><span class="line">        └── linux</span><br><span class="line">            └── kvm.h.patch</span><br></pre></td></tr></table></figure>

<ul>
<li>新增档案<ul>
<li><strong>vmx_pt.*</strong> - 由于Intel-PT 要追踪的是VM 执行流程，所以需要更新VMX (Intel-VX) 的相关暂存器，不过这部分大多需要参考手册才能知道对应暂存器的功能</li>
</ul>
</li>
<li>档案更动<ul>
<li><strong>kvm_host.h.patch</strong> - 为kvm file operation 结构新增两个function pointer 成员，分别为<code>setup_trace_fd</code>与<code>vmx_pt_enabled</code></li>
<li><strong>x86.c.patch</strong> - kAFL hypercall interface，当VM 呼叫<code>hypercall</code>而trap 到KVM，会先到此处理请求与相关参数，像是更新代表失败原因的结构成员<code>exit_reason</code></li>
<li><strong>kvm.h.patch</strong> - 定义一些与QEMU 共用的macro</li>
</ul>
</li>
</ul>
<h4 id="vmx-pt-c"><a href="#vmx-pt-c" class="headerlink" title="vmx_pt.c"></a>vmx_pt.c</h4><p>vmx_pt.c 程式码分为四个部分：</p>
<ul>
<li><strong>Userspace interface</strong> - userspace 的程式可以透过<code>ioctl</code>设定Intel-PT</li>
<li><strong>Entry&#x2F;exit</strong> - 处理进VM 跟从VM 出来时，需要对Intel-PT 的设定做调整</li>
<li><strong>Setup</strong> - 建置Intel-PT 的设定环境</li>
<li><strong>Initialization</strong> - 建置环境时会需要初始化一些设定值</li>
</ul>
<p>接下来用于介绍的程式码都已经删除了相较不重要的部分，有兴趣的读者在参考原本内容。首先先看userspace interface 的程式码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 對 vmx-pt fd 呼叫 ioctl 時會執行 vmx_pt_ioctl()</span><br><span class="line">static struct file_operations vmx_pt_fops = &#123;</span><br><span class="line">    .unlocked_ioctl = vmx_pt_ioctl, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static long vmx_pt_ioctl(..., unsigned int ioctl, ...)</span><br><span class="line">&#123;</span><br><span class="line">    // 根據 ioctl 參數做不同的處理</span><br><span class="line">    switch (ioctl) &#123;</span><br><span class="line">        // 設定、開啟、關閉特定範圍的 Intel-PT 追蹤</span><br><span class="line">        case KVM_VMX_PT_&#123;CONFIGURE,ENABLE,DISABLE&#125;_ADDR&#123;0...3&#125;: ...</span><br><span class="line">        // 設定、開啟、關閉特定 CR3 的追蹤</span><br><span class="line">        case KVM_VMX_PT_&#123;CONFIGURE,ENABLE,DISABLE&#125;_CR3: ...</span><br><span class="line">        // 開啟、關閉 Intel-PT</span><br><span class="line">        case KVM_VMX_PT_&#123;ENABLE,DISABLE&#125;: ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int vmx_pt_create_fd(...)&#123;</span><br><span class="line">    // 回傳 &quot;vmx-pt&quot; 類別的 fd，並使用 vmx_pt_fops 作為 function table</span><br><span class="line">    // 此 function 能透過 KVM request 呼叫</span><br><span class="line">    if (enabled)&#123;</span><br><span class="line">        return anon_inode_getfd(&quot;vmx-pt&quot;, &amp;vmx_pt_fops, ...); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry&#x2F;exit 的处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void vmx_pt_vmentry(struct vcpu_vmx_pt *vmx_pt)&#123;</span><br><span class="line">    // 進到 VM 前，將 Intel-PT 的設定寫入對應的 msr 當中</span><br><span class="line">    vmx_pt_reconfigure_cpu(vmx_pt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void vmx_pt_vmexit(struct vcpu_vmx_pt *vmx_pt)&#123;</span><br><span class="line">    // 從 rtit msr 讀 topa 並存入 vmx_pt 結構</span><br><span class="line">    // topa 為 table of physical address</span><br><span class="line">   	// rtit 為 real time instruction trace</span><br><span class="line">    rdmsrl(MSR_IA32_RTIT_OUTPUT_BASE, topa_base);</span><br><span class="line">    rdmsrl(MSR_IA32_RTIT_OUTPUT_MASK_PTRS, topa_mask_ptrs);</span><br><span class="line">    WRITE_ONCE(vmx_pt-&gt;ia32_rtit_output_base, topa_base);</span><br><span class="line">    WRITE_ONCE(vmx_pt-&gt;ia32_rtit_output_mask_ptrs, topa_mask_ptrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Setup 与initialization 基本上就是设置一开始的topa 以及rtit msr，比较没什么特别的，在此就不赘述。</p>
<h4 id="x86-c-patch"><a href="#x86-c-patch" class="headerlink" title="x86.c.patch"></a>x86.c.patch</h4><p>考虑到markdown 不支援patch syntax，接下来类似的档案会都经过修改，以C code 方式呈现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 新增 ioctl 時傳入的 KVM 請求處理</span><br><span class="line">case KVM_VMX_PT_SUPPORTED:</span><br><span class="line">    r = kvm_x86_ops-&gt;vmx_pt_enabled();</span><br><span class="line">case KVM_VMX_PT_SETUP_FD:</span><br><span class="line">    r = kvm_x86_ops-&gt;setup_trace_fd(vcpu);</span><br><span class="line"></span><br><span class="line">// 用 rax 是否存放 magic number 來判斷是否為</span><br><span class="line">// VM 透過 hypercall 發送給 KVM 的請求</span><br><span class="line">if (kvm_register_read(vcpu, VCPU_REGS_RAX) == HYPERCALL_KAFL_RAX_ID)&#123;</span><br><span class="line">    switch(kvm_register_read(vcpu, VCPU_REGS_RBX))&#123;</span><br><span class="line">        // 各個請求值對應的 exit_reason 其意義 self-explanatory</span><br><span class="line">        case 0:</span><br><span class="line">            // 會將請求值與相關狀態儲存到 exit_reason 成員，</span><br><span class="line">            // 此成員會在 QEMU-PT 使用到</span><br><span class="line">            vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_KAFL_ACQUIRE;</span><br><span class="line">        case 1 ... 13: ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QEMU-PT"><a href="#QEMU-PT" class="headerlink" title="QEMU-PT"></a>QEMU-PT</h3><p>不考虑QEMU monitor (hmp) 的更动，QEMU-PT 的目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── qom</span><br><span class="line">│       └── cpu.h.patch</span><br><span class="line">├── kvm-all.c.patch</span><br><span class="line">├── linux-headers</span><br><span class="line">│   └── linux</span><br><span class="line">│       └── kvm.h.patch</span><br><span class="line">├── pt</span><br><span class="line">│   ├── decoder.&#123;c,h&#125;</span><br><span class="line">│   ├── disassembler.&#123;c,h&#125;</span><br><span class="line">│   ├── filter.&#123;c,h&#125;</span><br><span class="line">│   ├── hypercall.&#123;c,h&#125;</span><br><span class="line">│   ├── interface.&#123;c,h&#125;</span><br><span class="line">│   ├── khash.h</span><br><span class="line">│   ├── logger.&#123;c,h&#125;</span><br><span class="line">│   ├── memory_access.&#123;c,h&#125;</span><br><span class="line">│   └── tnt_cache.&#123;c,h&#125;</span><br><span class="line">├── pt.&#123;c,h&#125;</span><br><span class="line">└── vl.c.patch</span><br></pre></td></tr></table></figure>

<ul>
<li><p>新增档案</p>
<ul>
<li><p>pt&#x2F;</p>
<p> - 与解析Intel-PT packet 相关</p>
<ul>
<li><strong>hypercall.c</strong> - 定义hypercall handler</li>
<li><strong>interface.c</strong> - 注册QEMU device object 与一些客制化属性，这些属性能透过command option 传入。同时也会初始化object member，像是bitmap memory</li>
</ul>
</li>
<li><p><strong>pt.c</strong> - 与呼叫KVM 执行Intel-PT 相关</p>
</li>
</ul>
</li>
<li><p>档案更动</p>
<ul>
<li><strong>cpu.h.patch</strong> - 在QEMU 的virtual CPU 结构中新增与tracing 相关的结构</li>
<li><strong>kvm.h.patch</strong> - 与KVM 共用的macro</li>
<li><strong>vl.c.patch</strong> - vl.c 存放QEMU main function <code>qemu_init()</code>，而patch 会额外做一些Intel-PT 相关的初始化</li>
<li><strong>kvm-all.c.patch</strong> - 新增KVM <code>exit_reason</code>handler，也就是像<code>KVM_EXIT_KAFL_ACQUIRE</code>的hypercall 请求</li>
</ul>
</li>
</ul>
<h4 id="kvm-all-c-patch"><a href="#kvm-all-c-patch" class="headerlink" title="kvm-all.c.patch"></a>kvm-all.c.patch</h4><p>根据KVM 回传的<code>exit_reason</code>执行hypercall handler，function name 的格式为<code>handle_hypercall_XXX</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch (exit_reason) &#123;</span><br><span class="line">    case KVM_EXIT_KAFL_ACQUIRE:</span><br><span class="line">        handle_hypercall_kafl_acquire(run, cpu);</span><br><span class="line">    case ...; handle_hypercall_...();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pt-x2F-hypercall-c"><a href="#pt-x2F-hypercall-c" class="headerlink" title="pt&#x2F;hypercall.c"></a>pt&#x2F;hypercall.c</h4><p>以request<code>KVM_EXIT_KAFL_ACQUIRE</code>来说，会交由<code>handle_hypercall_kafl_acquire()</code>来处理，初始化QEMU 中Intel-PT 相关资讯：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void handle_hypercall_kafl_acquire(...) &#123;</span><br><span class="line">    // 如果還沒初始化</span><br><span class="line">    if (!init_state)&#123;</span><br><span class="line">		// 初始化 filter，也就是追蹤的範圍</span><br><span class="line">        init_det_filter();</span><br><span class="line">        // 開啟 PT</span><br><span class="line">        pt_enable(cpu, false);</span><br><span class="line">        cpu-&gt;pt_enabled = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pt-c"><a href="#pt-c" class="headerlink" title="pt.c"></a>pt.c</h4><p>以解析packet 来更新bitmap 来说，pt.c 定义了function<code>pt_enable_ip_filtering()</code>注册指定IP 范围使用的decoder function <code>pt_bitmap</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int pt_enable_ip_filtering(CPUState *cpu, uint8_t addrn, uint64_t ip_a, uint64_t ip_b, bool hmp_mode)&#123;</span><br><span class="line">    // 指定追蹤範圍</span><br><span class="line">    cpu-&gt;pt_ip_filter_a[addrn] = ip_a;</span><br><span class="line">    cpu-&gt;pt_ip_filter_b[addrn] = ip_b;</span><br><span class="line">    // 透過 ioctl KVM 設定 Intel-PT</span><br><span class="line">    r += pt_cmd(cpu, KVM_VMX_PT_CONFIGURE_ADDR0+addrn, hmp_mode);</span><br><span class="line">    r += pt_cmd(cpu, KVM_VMX_PT_ENABLE_ADDR0+addrn, hmp_mode);</span><br><span class="line">    // 註冊 decoder 結構，並且 decode function 為 pt_bitmap</span><br><span class="line">    cpu-&gt;pt_decoder_state[addrn] = pt_decoder_init(buf, ip_a, ip_b, &amp;pt_bitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// kAFL 紀錄 bitmap 分成 vertex 與 edge：</span><br><span class="line">// vertex 用來存某個 basic block 走到的次數</span><br><span class="line">// edge 就是 path</span><br><span class="line">static void pt_bitmap(uint64_t addr)&#123;</span><br><span class="line">    // 更新 vertex bitmap</span><br><span class="line">    hypercall_submit_address(addr);</span><br><span class="line">    // transition 即是 AFL 中的 edge value</span><br><span class="line">    transition_value = (addr ^ (last_ip &gt;&gt; 1)) &amp; 0xffffff;</span><br><span class="line">    // 紀錄當前 edge value 總共產生的次數</span><br><span class="line">    hypercall_submit_transition(transition_value);</span><br><span class="line">    // 更新 edge bitmap</span><br><span class="line">    bitmap[transition_value &amp; (kafl_bitmap_size-1)]++;</span><br><span class="line">    last_ip = addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Function<code>trace_disassembler()</code>存在于pt&#x2F;disassembler.c，用来解析Intel-PT packet，而在过成中会呼叫<code>self-&gt;handler()</code>，实际上会执行到<code>pt_bitmap()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool trace_disassembler(...)&#123;</span><br><span class="line">    // obj 為每個封包結構，彼此會用 linked list 串起來</span><br><span class="line">    obj = get_obj(self, entry_point, tnt_cache_state);</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        // cofi：Change of Flow Instruction</span><br><span class="line">        switch(obj-&gt;cofi-&gt;type) &#123;</span><br><span class="line">			// conditional branch</span><br><span class="line">            case COFI_TYPE_CONDITIONAL_BRANCH:</span><br><span class="line">                // 取得 taken or non-taken 資訊</span><br><span class="line">                tnt = process_tnt_cache(tnt_cache_state);</span><br><span class="line">                switch(tnt) &#123;</span><br><span class="line">                    case TAKEN:</span><br><span class="line">                        // 呼叫 handler 也就是 pt_bitmap() 來更新 bitmap</span><br><span class="line">                        self-&gt;handler(obj-&gt;cofi-&gt;ins_addr);</span><br><span class="line">                        obj = get_obj(self, obj-&gt;cofi-&gt;target_addr, tnt_cache_state);</span><br><span class="line">                        break;</span><br><span class="line">                    case NOT_TAKEN: ...;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>因为架构相较复杂，如果对QEMU 或是KVM 不太熟的读者，在研究这些程式码时建议与workflow 的架构图一起看，能更清楚了解每个component 之间是怎么运作的。</p>
<p>新增hypercall handle 执行VM 的请求固然简单明了，但是只要QEMU 或是KVM 一改版，patch 就必须重更新一次，这也减少了便利性，同时因为QEMU-PT 负责通知KVM 开启Intel-PT，因此纪录相关资讯与解析packet 的操作都必须整合到QEMU 内，这个部分也是比较不直观的地方。</p>
<p>明天会介绍kAFL-fuzzer 目录底下的档案，包含loader、agent 与fuzzer 的实作细节，像是instruction<code>hypercall</code>到底长什么样子、loader 是怎么传送hypercall 给fuzzer、范例agent 会做什么事情、fuzzer 是如何产payload的等等。</p>
<h1 id="Day-25-OS-fuzzer-kAFL-原始码-The-fuzzer"><a href="#Day-25-OS-fuzzer-kAFL-原始码-The-fuzzer" class="headerlink" title="[Day 25] OS fuzzer - kAFL 原始码- The fuzzer"></a>[Day 25] OS fuzzer - kAFL 原始码- The fuzzer</h1><p>再来介绍kAFL 原始码中最后一个component： kAFL-fuzzer。 kAFL 在host 执行的部分基本上都是用python 所撰写，包含执行整个kAFL、fuzzer 做mutation、传入payload 等操作，好处是方便开发，而坏处则是效能不好，这又让我再次怀疑他的实验结果是否效能真的这么好。</p>
<h3 id="kAFL-fuzzer"><a href="#kAFL-fuzzer" class="headerlink" title="kAFL-fuzzer"></a>kAFL-fuzzer</h3><p>档案结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── agents</span><br><span class="line">│   ├── kafl_user.h</span><br><span class="line">│   └── linux_x86_64</span><br><span class="line">│       ├── fuzzer/fs_fuzzer.c</span><br><span class="line">│       └── loader/loader.c</span><br><span class="line">├── common</span><br><span class="line">│   ├── config.py</span><br><span class="line">│   ├── debug.py</span><br><span class="line">│   ├── evaluation.py</span><br><span class="line">│   ├── qemu.py</span><br><span class="line">│   ├── self_check.py</span><br><span class="line">│   ├── ui.py</span><br><span class="line">│   └── util.py</span><br><span class="line">├── fuzzer</span><br><span class="line">│   ├── communicator.py</span><br><span class="line">│   ├── core.py</span><br><span class="line">│   ├── process</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── mapserver.py</span><br><span class="line">│   │   ├── master.py</span><br><span class="line">│   │   ├── slave.py</span><br><span class="line">│   │   └── update.py</span><br><span class="line">│   ├── protocol.py</span><br><span class="line">│   ├── state.py</span><br><span class="line">│   ├── technique</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   │   └── interesting_values.py</span><br><span class="line">│   └── tree.py</span><br><span class="line">└── kafl_fuzz.py</span><br></pre></td></tr></table></figure>

<p>以kafl_fuzz.py 的<code>main()</code>为整个kAFL 的进入点，起初初始化执行环境，而后解析使用者自定义的设定档，最后在VM 中执行agent 做fuzzing。</p>
<p>整个过程中component 之间彼此会使用各种机制来传送资讯，像是共享一个queue，每个component 透过queue element 就能得知资讯是否属于他，此外fuzzer 会用socket 与QEMU 做沟通，QEMU 也会用shared memory 与VM 做沟通。</p>
<h4 id="agents-x2F-linux-x86-64"><a href="#agents-x2F-linux-x86-64" class="headerlink" title="agents&#x2F;linux_x86_64"></a>agents&#x2F;linux_x86_64</h4><p>存放三个档案，分别为：</p>
<ul>
<li><strong>fuzzer&#x2F;fs_fuzzer.c</strong> - 虽然名称为fuzzer，但实际上是agent 的程式码</li>
<li><strong>loader&#x2F;loader.c</strong> - 接收fuzzer 传来的agent 执行档并执行</li>
<li><strong>kafl_user.h</strong> - 定义hypercall 所执行的instruction 为何，如何传递请求类型与参数</li>
</ul>
<hr>
<p>首先介绍fs_fuzzer.c 的程式码，其中部分的hypercall 请求的功能已经由macro 名称解释，就不额外写注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    // 建立存放 payload 的記憶體區塊</span><br><span class="line">    kAFL_payload* payload_buffer = mmap((void*)NULL, PAYLOAD_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">	// setup</span><br><span class="line">    // ...</span><br><span class="line">    kAFL_hypercall(HYPERCALL_KAFL_SUBMIT_CR3, 0);</span><br><span class="line">    // 傳送 payload 位址給 fuzzer</span><br><span class="line">    kAFL_hypercall(HYPERCALL_KAFL_GET_PAYLOAD, (uint64_t)payload_buffer);</span><br><span class="line">	// KAFL_TMP_FILE 為存放 payload 的檔案</span><br><span class="line">    backingfile = open(KAFL_TMP_FILE, O_RDWR | O_CREAT | O_SYNC, 0777);</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        // 請求 fuzzer 傳入 payload</span><br><span class="line">        kAFL_hypercall(HYPERCALL_KAFL_NEXT_PAYLOAD, 0);</span><br><span class="line">        // payload 寫入 payload file &quot;backingfile&quot;</span><br><span class="line">        write(backingfile, payload_buffer-&gt;data, payload_buffer-&gt;size-4);</span><br><span class="line">        </span><br><span class="line">        // 通知 fuzzer 開始執行</span><br><span class="line">        kAFL_hypercall(HYPERCALL_KAFL_ACQUIRE, 0);</span><br><span class="line">        // =========== syscall sequence ===========</span><br><span class="line">        mount(loopname, &quot;/tmp/a/&quot;, &quot;ext4&quot;, payload_buffer-&gt;data[payload_buffer-&gt;size-4], NULL);</span><br><span class="line">        mkdir(&quot;/tmp/a/trash&quot;, 0700);</span><br><span class="line">        stat(&quot;/tmp/a/trash&quot;, &amp;st);</span><br><span class="line">        umount2(&quot;/tmp/a&quot;, MNT_FORCE);</span><br><span class="line">        // ========================================</span><br><span class="line">        // 該次執行結束，請求 fuzzer 處理這次 tracing 結果</span><br><span class="line">        kAFL_hypercall(HYPERCALL_KAFL_RELEASE, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用来载入agent 的loader 的原始码则是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static inline void load_programm(void* buf) &#123;</span><br><span class="line">    // 把 fuzzer 傳來的 program data 寫進檔案</span><br><span class="line">    payload_file = open(TARGET_FILE, O_RDWR | O_CREAT | O_SYNC, 0777);</span><br><span class="line">    write(payload_file, buf, PROGRAM_SIZE);</span><br><span class="line">    close(payload_file);</span><br><span class="line">    // 執行檔案</span><br><span class="line">    payload_file = open(TARGET_FILE, O_RDONLY);</span><br><span class="line">    fexecve(payload_file, newargv, newenviron);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    program_buffer = mmap((void*)0xabcd0000, PROGRAM_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">    // 與 fuzzer 做 handshake</span><br><span class="line">    kAFL_hypercall(HYPERCALL_KAFL_ACQUIRE, 0);</span><br><span class="line">    kAFL_hypercall(HYPERCALL_KAFL_RELEASE, 0);</span><br><span class="line">    // 傳給 fuzzer 要寫入 agent 的位址</span><br><span class="line">    kAFL_hypercall(HYPERCALL_KAFL_GET_PROGRAM, (uint64_t)program_buffer);</span><br><span class="line">    // 載入 agent</span><br><span class="line">    load_programm(program_buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kafl_user.h 定义了function <code>kAFL_hypercall()</code>，内部实际上是执行instruction <code>vmcall</code>，执行后会触发VM exit，并将exit reason 储存到对应的暂存器当中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// hypercall magic number</span><br><span class="line">#define HYPERCALL_KAFL_RAX_ID			0x01f</span><br><span class="line">#define HYPERCALL_KAFL_ACQUIRE			0</span><br><span class="line">#define HYPERCALL_KAFL_GET_PAYLOAD		1</span><br><span class="line">// ...</span><br><span class="line">#define HYPERCALL_KAFL_NEXT_PAYLOAD		12</span><br><span class="line"></span><br><span class="line">#define TARGET_FILE						&quot;/tmp/fuzzing_engine&quot;</span><br><span class="line">#define TARGET_FILE_WIN					&quot;fuzzing_engine.exe&quot;	</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	int32_t size;</span><br><span class="line">	uint8_t data[PAYLOAD_SIZE-4];</span><br><span class="line">&#125; kAFL_payload;</span><br><span class="line"></span><br><span class="line">static inline void kAFL_hypercall(uint64_t rbx, uint64_t rcx)&#123;</span><br><span class="line">	uint64_t rax = HYPERCALL_KAFL_RAX_ID;</span><br><span class="line">    // rcx 放請求參數</span><br><span class="line">	asm (&quot;movq %0, %%rcx;&quot; : : &quot;r&quot;(rcx));</span><br><span class="line">    // rbx 放請求類型</span><br><span class="line">	asm (&quot;movq %0, %%rbx;&quot; : : &quot;r&quot;(rbx));</span><br><span class="line">    // rax 放 magic number</span><br><span class="line">    asm (&quot;movq %0, %%rax;&quot; : : &quot;r&quot;(rax));</span><br><span class="line">    asm (&quot;vmcall&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="comoon-x2F"><a href="#comoon-x2F" class="headerlink" title="comoon&#x2F;"></a>comoon&#x2F;</h4><p>此目录底下放的大多是与fuzzer 机制无直接关系的程式码，大概介绍一下各个档案的行为，并挑出比较值得看的部分拿出来说明：</p>
<ul>
<li><strong>config.py</strong> - 用来解析config 档</li>
<li><strong>debug.py</strong> - 定义logger</li>
<li><strong>evalutation.py</strong> - 储存执行的累积数据，像是panic 数量</li>
<li><strong>self_check.py</strong> - 检查host 执行环境，像是是否安装必要的package、是否支援Intel-VMX 等等</li>
<li><strong>util.py</strong> - 定义通用的function</li>
<li><strong>ui.py</strong> - kAFL 使用者介面</li>
<li><strong>qemu.py</strong> - 比较重要的档案，除了执行QEMU 之外，同时也担任fuzzer 中负责与QEMU 沟通的桥梁，像是传送payload、复制bitmap</li>
</ul>
<p>单纯看qemu.py 中<code>class qemu</code>的成员名称与function 名称，就可以大概推敲出qemu.py 负责处理fuzzer 的哪些部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class qemu:</span><br><span class="line">    def __init__(self, qid, config):</span><br><span class="line">        # ...</span><br><span class="line">        self.bitmap_size = config.config_values[&#x27;BITMAP_SHM_SIZE&#x27;]</span><br><span class="line">        self.config = config</span><br><span class="line">        self.qemu_id = str(qid)</span><br><span class="line"></span><br><span class="line">        # 各式各樣 kafl 的 predefined 檔案名稱</span><br><span class="line">        self.payload_filename   = &quot;/dev/shm/kafl_qemu_payload_&quot; + self.qemu_id</span><br><span class="line">		# ...</span><br><span class="line">        self.cmd =  self.config.config_values[&#x27;QEMU_KAFL_LOCATION&#x27;] + &quot; &quot; \</span><br><span class="line">                    &quot;-hdb &quot; + self.config.argument_values[&#x27;ram_file&#x27;] + &quot; &quot; \</span><br><span class="line">                    # 一些 qemu command option，如果好奇加了哪些</span><br><span class="line">        			# 可以直接去看沒有刪減的程式碼</span><br><span class="line">        			# ...</span><br><span class="line">                    &quot;,bitmap=&quot; + self.bitmap_filename</span><br><span class="line">	</span><br><span class="line">    	# 對 option 中的 ip property 做設定</span><br><span class="line">        # ...</span><br><span class="line">        self.cmd += &quot; -loadvm &quot; + self.config.argument_values[&quot;S&quot;] + &quot; &quot;</span><br><span class="line">        self.cmd += &quot; -machine pc-i440fx-2.6 &quot;</span><br><span class="line"></span><br><span class="line">        # shared memory 與對應的 fd</span><br><span class="line">        # 種類包含 bitmap, payload 等等</span><br><span class="line">        self.kafl_shm_f = None</span><br><span class="line">        self.kafl_shm   = None</span><br><span class="line">        self.fs_shm_f   = None</span><br><span class="line">        self.fs_shm     = None</span><br><span class="line">        self.payload_shm_f   = None</span><br><span class="line">        self.payload_shm     = None</span><br><span class="line">        self.bitmap_shm_f   = None</span><br><span class="line">        self.bitmap_shm     = None</span><br><span class="line">        # 其他類型成員的初始化</span><br><span class="line">        # ...</span><br><span class="line">        # 將編譯後的 agent 透過 share memory 傳到 VM</span><br><span class="line">        self.__set_binary(self.binary_filename,</span><br><span class="line">                          self.config.argument_values[&#x27;executable&#x27;], (16 &lt;&lt; 20))</span><br><span class="line">		</span><br><span class="line">        # 執行 qemu，運行 VM</span><br><span class="line">        def start(self, ...): ...</span><br><span class="line">        # 設置 payload 到 shared memory</span><br><span class="line">        def set_payload(self, ...): ...</span><br><span class="line">        # 複製 bitmap</span><br><span class="line">        def copy_bitmap(self, ...): ...</span><br><span class="line">        # 接收從 QEMU 傳來的執行結果</span><br><span class="line">        def check_recv(self, ...): ...</span><br></pre></td></tr></table></figure>

<h4 id="fuzzer-x2F"><a href="#fuzzer-x2F" class="headerlink" title="fuzzer&#x2F;"></a>fuzzer&#x2F;</h4><p>资料夹底下还有一些资料夹与档案，根据<strong>功能</strong>大致上可以分成以下部分：</p>
<ul>
<li><strong>Communicator</strong> - 包装资源存取的形式，并建立<code>class Message</code>描述传送资讯的格式</li>
<li><strong>Master</strong> - 向slave 发号施令，实作fuzzing 策略</li>
<li><strong>Slave</strong> - 执行QEMU instance 并听master 的命令</li>
<li><strong>Mapserver</strong> - 更新执行状态与coverage</li>
</ul>
<p>主要是因为可以执行多个QEMU 做平行化，因此才需要有一个master process 负责管理，同时程式中也写了不少用来预防race condition 发生的程式码。</p>
<p>如果是以档案或目录区分，则分成：</p>
<ul>
<li><strong>technique&#x2F;</strong> - 存放payload 的bitflip、arith 等常见的mutation 操作</li>
<li><strong>process&#x2F;</strong> - master、slave 与mapserver</li>
<li><strong>communicator.py</strong> - 部分资源的使用包装与初始化，像是shared memory 就能用function<code>get_bitmap_shm()</code>来存取</li>
</ul>
<p>接下来就挑实作mapserver 的mapserver.py、 实作master 的master.py、实作slave 的slave.py 以及实作communicator 的communicator.py 来做介绍。</p>
<hr>
<p><strong>Communicator</strong>实作在communicator.py，主要是负责各个component 的沟通，但我认为用来传资料的queue 设计的不太好，不同名称的queue 容易让人造成误会，因此读者只需要记得每个component 之间是用queue 来传送资料。程式码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Communicator:</span><br><span class="line">    def __init__(self, ...):</span><br><span class="line">        # 雖然一共只有 master、slave 與 mapserver，不過卻有一些看似會重複使用的 queue</span><br><span class="line">        # 大概能猜測到是為了加速，因為有些資訊可能只會有 A 傳給 B</span><br><span class="line">        self.to_update_queue = multiprocessing.Queue()</span><br><span class="line">        self.to_master_queue = multiprocessing.Queue()</span><br><span class="line">        self.to_master_from_mapserver_queue = multiprocessing.Queue()</span><br><span class="line">        self.to_master_from_slave_queue = multiprocessing.Queue()</span><br><span class="line">        self.to_mapserver_queue = multiprocessing.Queue()</span><br><span class="line">        </span><br><span class="line">        # 取得 shared memory</span><br><span class="line">        # master shm (shared memory) 用來傳 payload 給 VM 中的 agent</span><br><span class="line">        def get_master_payload_shm(self, slave_id):</span><br><span class="line">        # mapserver shm 用來儲存 interesting payload</span><br><span class="line">		def get_mapserver_payload_shm(self, slave_id):</span><br><span class="line">        # 取得 bitmap shm</span><br><span class="line">        def get_bitmap_shm(self, slave_id):</span><br><span class="line">        # 建立 shm</span><br><span class="line">        def create_shm(self):</span><br></pre></td></tr></table></figure>

<p><strong>Master</strong>实作在master.py，管理slave 并下达命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class MasterProcess:</span><br><span class="line">    def __init__(self, comm):</span><br><span class="line">        # comm 為 communicator</span><br><span class="line">        self.comm = comm</span><br><span class="line">        self.kafl_state = State()</span><br><span class="line">        self.payload = &quot;&quot;</span><br><span class="line"></span><br><span class="line">        # 紀錄用來做效能評估的執行狀態</span><br><span class="line">        self.counter = 0</span><br><span class="line">        self.round_counter = 0</span><br><span class="line">		# ...</span><br><span class="line"></span><br><span class="line">        # 讀取設定檔中客製化 fuzzing 策略的參數值</span><br><span class="line">        self.config = FuzzerConfiguration()</span><br><span class="line">        self.skip_zero = self.config.argument_values[&#x27;s&#x27;]</span><br><span class="line">		# ...</span><br><span class="line">        </span><br><span class="line">        # 做 mutation，以下列兩個 function 為例</span><br><span class="line">        def __bitflip_handler(self, ...):</span><br><span class="line">		def __arithmetic_handler(self, ...):</span><br><span class="line">        # performance 的測量</span><br><span class="line">        def __perform_bechmark(self):</span><br><span class="line">        def __perform_sampling(self):</span><br><span class="line">        # 送 mutate 後的 payload 給 slave</span><br><span class="line">        def __task_send(self, tasks, qid, dest):</span><br></pre></td></tr></table></figure>

<p><strong>Slave</strong>实作于slave.py，接收master 命令并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class SlaveProcess:</span><br><span class="line">    def __init__(self, comm, slave_id, auto_reload=False):</span><br><span class="line">        self.config = FuzzerConfiguration()</span><br><span class="line">        # communicator</span><br><span class="line">        self.comm = comm</span><br><span class="line">        self.slave_id = slave_id</span><br><span class="line">        # 一個 qemu instance 就代表一台 VM</span><br><span class="line">        self.q = qemu(self.slave_id, self.config)</span><br><span class="line">	# 負責送 payload 並新增 interesting payload 到 mapserver shm</span><br><span class="line">	def __respond_job_req(self, response):</span><br><span class="line">    # 等待 master 命令的迴圈</span><br><span class="line">    def interprocess_proto_handler(self):</span><br><span class="line">        # 從 master 傳來的命令</span><br><span class="line">        response = recv_msg(self.comm.to_slave_queues[self.slave_id])</span><br><span class="line">        # tag 代表不同類型的命令，像是 KAFL_TAG_JOB 就是送 payload 給 agent</span><br><span class="line">        if response.tag == KAFL_TAG_JOB:</span><br><span class="line">            self.__respond_job_req(response)</span><br><span class="line">            send_msg(KAFL_TAG_REQ, self.q.qemu_id, self.comm.to_master_queue, source=self.slave_id)</span><br><span class="line">		# ...</span><br><span class="line">        elif response.tag == KAFL_TAG_REQ_BENCHMARK:</span><br><span class="line">            self.__respond_benchmark_req(response)</span><br></pre></td></tr></table></figure>

<p>最后一个为实作<strong>mapserver</strong>的mapserver.py，主要管理fuzzing 结果的更新，并且还需要同步每个slave 的状态，其他component 会透过<code>to_mapserver_queue</code>传送请求给mapserver ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MapserverProcess:</span><br><span class="line">    def __init__(self, comm, initial=True):</span><br><span class="line">        self.comm = comm</span><br><span class="line">        self.mapserver_state_obj = MapserverState()</span><br><span class="line">        # 大多都與 fuzzing 結果的處理有關係，感覺與 performance 測量有部分重疊</span><br><span class="line">        self.hash_list = set()</span><br><span class="line">        self.crash_list = []</span><br><span class="line">        self.shadow_map = set()</span><br><span class="line">        # ...</span><br><span class="line"></span><br><span class="line">	# 用來分析執行結果</span><br><span class="line">	def __result_tag_handler(self, request):</span><br><span class="line">	def loop(self):</span><br><span class="line">        while True:</span><br><span class="line">            self.__sync_handler()</span><br><span class="line">            # 接收請求</span><br><span class="line">            request = recv_msg(self.comm.to_mapserver_queue)</span><br><span class="line">			# 舉例來說，slave 執行結束後就會送 KAFL_TAG_RESULT 請求給 mapserver，</span><br><span class="line">            # mapserver 就會呼叫對應的 handler (__result_tag_handler) 來分析執行結果</span><br><span class="line">            if request.tag == KAFL_TAG_RESULT:</span><br><span class="line">                self.__result_tag_handler(request)</span><br><span class="line">            elif request.tag == KAFL_TAG_MAP_INFO:</span><br><span class="line">			# ...</span><br></pre></td></tr></table></figure>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>这两天迅速对kAFL 做简单的介绍，我个人认为并不用深入了解kAFL-fuzzer 这个部分怎么处理，一方面是没有注解，看得很辛苦，一方面是架构与效能还可以优化。比较值得花时间看的反而是QEMU-PT 与KVM-PT 做的事情，了解patch 做了哪些事能够更了解虚拟化技术以及Intel-PT，而我在文章没有讲负责解析Intel-PT 产生出来packet的程式码，但那个部分也可以稍微看一下，虽然行为只是根据Intel-PT 封包格式做处理，但如果知道程式码要怎么写，应该会对Intel-PT 有更深入的了解。</p>
<h1 id="Day-26-OS-fuzzer-syzkaller-介绍-amp-执行环境建置"><a href="#Day-26-OS-fuzzer-syzkaller-介绍-amp-执行环境建置" class="headerlink" title="[Day 26] OS fuzzer - syzkaller - 介绍&amp; 执行环境建置"></a>[Day 26] OS fuzzer - syzkaller - 介绍&amp; 执行环境建置</h1><p>先前有提到<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller">syzkaller</a>可以说是目前最广为使用的OS fuzzer，不但整个部署的过程只需要下几个命令，也提供使用者客制化执行环境，像是允许执行的syscall、VM instance 个数、自定义syscall 与呼叫dependency 等等，并且他有清楚明了的使用者介面，让使用者可以知道当下执行的状态，包含crash 发生的位置与错误回报、当前尚未执行的seed，甚至还可以在原始码中看各个basic block 的执行次数。</p>
<p>如果好奇使用者介面提供了哪些功能，这边提供一个开在外面的<a target="_blank" rel="noopener" href="https://elisa-builder-00.iol.unh.edu/syzkaller/">syzkaller server</a>给各位参考，同时syzkaller 也有官方维护，不断fuzz 最新版本kernel 的<a target="_blank" rel="noopener" href="https://syzkaller.appspot.com/">syzbot</a>，如果研究人员想知道某个作业系统比较常发生错误的部分，也可以透过分析syzbot 都在哪些地方找到漏洞来得知。</p>
<p>syzkaller 并没有额外发论文，但其<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller">repo</a>中有分享此设计曾经在哪些地方演讲过，可以参考<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/talks.md">Tech talks and articles</a>，接下来会对syzkaller 做一些简单的介绍，并将整个环境架设起来。</p>
<h2 id="Syzkaller"><a href="#Syzkaller" class="headerlink" title="Syzkaller"></a>Syzkaller</h2><h3 id="Introduction-3"><a href="#Introduction-3" class="headerlink" title="Introduction"></a>Introduction</h3><p><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller">syzkaller</a>为google 开发的open source OS fuzzer，目前主要由<a target="_blank" rel="noopener" href="https://github.com/dvyukov">dvyukov</a>维护，有着部署快、使用简单的优点，同时还支援多个作业系统。接下来介绍会以fuzzing Linux 为主，下方为syzkaller 的架构图，主要分成三个component，分别为<strong>syz-manager</strong>、<strong>syz-fuzzer</strong>以及<strong>syz-executor</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/u1f383/fuzzing-learning-in-30-days/blob/main/images/26-0.png"><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281115724.png" alt="img"></a></p>
<ul>
<li><strong>syz-manager</strong> - 执行在host，主要用来执行VM instance 与管理使用者介面<ul>
<li>一开始会将整个环境初始化，而后负责管理系统与输出结果，比较少fuzzer 相关的机制</li>
</ul>
</li>
<li><strong>syz-fuzzer</strong> - fuzzer engine，负责执行syz-executor 并接收coverage 做分析<ul>
<li>Fuzzer 会根据使用者的设定来产生syscall sequence，之后传送给syz-executor 执行</li>
<li>搜集coverage 的部分使用kernel feature <code>KCOV</code>，因此不需要额外对kernel 做patch</li>
</ul>
</li>
<li><strong>syz-executor</strong> - 负责执行syscall sequence<ul>
<li>不断等待syz-fuzzer 传来的”program”，也就是一组syscall 组合</li>
<li>重复执行</li>
</ul>
</li>
</ul>
<p>除此之外syzkaller 还有提供许多工具可以使用，像是复现crash input，或是对input 做最小化(minimization) 等等，但这些工具不一定会使用到，就没有列在架构图上。其中编译kernel 时所使用kernel config 只需要满足syzkaller 所使用的功能，其他部分都可以自己调整。</p>
<h4 id="KCOV"><a href="#KCOV" class="headerlink" title="KCOV"></a>KCOV</h4><p>搜集coverage 的方式也是syzkaller 的一大特色，先前在Day22 介绍kAFL 时有稍微提到过，syzkaller 是用<code>KCOV</code>搜集coverage，而<code>KCOV</code>的开发人员之一就是syzkaller 的维护者，这里会稍微介绍一下<code>KCOV</code>，细节部分可以参考<a target="_blank" rel="noopener" href="https://docs.kernel.org/dev-tools/kcov.html">KCOV documentation</a>。</p>
<p>先介绍使用方式，参考下面的范例程式码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#define KCOV_INIT_TRACE  _IOR(&#x27;c&#x27;, 1, unsigned long)</span><br><span class="line">#define KCOV_ENABLE      _IO(&#x27;c&#x27;, 100)</span><br><span class="line">#define KCOV_DISABLE     _IO(&#x27;c&#x27;, 101)</span><br><span class="line">#define COVER_SIZE       (64&lt;&lt;10) // 0x10000</span><br><span class="line"></span><br><span class="line">#define KCOV_TRACE_PC  0</span><br><span class="line">#define KCOV_TRACE_CMP 1</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    // 用來蒐集 coverage 的介面</span><br><span class="line">    // fd 只能用在目前的 thread</span><br><span class="line">    fd = open(&quot;/sys/kernel/debug/kcov&quot;, O_RDWR);</span><br><span class="line">    // 初始化 trace mode，設置 trace size</span><br><span class="line">	ioctl(fd, KCOV_INIT_TRACE, COVER_SIZE);</span><br><span class="line">    // 建立一塊 kernel 與 userspace 共享的記憶體空間</span><br><span class="line">    cover = (unsigned long*)mmap(NULL, COVER_SIZE * sizeof(unsigned long),</span><br><span class="line">                                 PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">    // 開啟當前 thread 的 coverage collection</span><br><span class="line">    // 除了 KCOV_TRACE_PC 之外，還有 KCOV_TRACE_CMP，</span><br><span class="line">    // 用來蒐集 comparison 的資訊</span><br><span class="line">	ioctl(fd, KCOV_ENABLE, KCOV_TRACE_PC);</span><br><span class="line"></span><br><span class="line">    // reset coverage</span><br><span class="line">    __atomic_store_n(&amp;cover[0], 0, __ATOMIC_RELAXED);</span><br><span class="line">    </span><br><span class="line">    // 目標 syscall</span><br><span class="line">    read(-1, NULL, 0);</span><br><span class="line">    </span><br><span class="line">    // 取得紀錄的位址數量</span><br><span class="line">    n = __atomic_load_n(&amp;cover[0], __ATOMIC_RELAXED);</span><br><span class="line">    // 遍歷整個 buffer，印出走到的位址</span><br><span class="line">    for (i = 0; i &lt; n; i++)</span><br><span class="line">        printf(&quot;0x%lx\n&quot;, cover[i + 1]);</span><br><span class="line"></span><br><span class="line">    // 關閉當前 thread 的 coverage collection</span><br><span class="line">	ioctl(fd, KCOV_DISABLE, 0);</span><br><span class="line">    // 釋放資源</span><br><span class="line">	munmap(cover, COVER_SIZE * sizeof(unsigned long)))</span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>背后的原理是Day11 介绍的<code>__sanitizer_cov_trace_pc()</code>插桩，也就是每个basic block 执行前都呼叫一次，而KCOV 做的插桩内容如下，参考linux kernel 的<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/kernel/kcov.c#L192">kcov.c</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void notrace __sanitizer_cov_trace_pc(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 取得 return address，也就是 basic block 的開頭</span><br><span class="line">    unsigned long ip = canonicalize_ip(_RET_IP_);</span><br><span class="line"></span><br><span class="line">    // 檢查當前 thread 是否需要正透過 KCOV trace</span><br><span class="line">    t = current;</span><br><span class="line">    if (!check_kcov_mode(KCOV_MODE_TRACE_PC, t))</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    area = t-&gt;kcov_area;</span><br><span class="line">    // pos 為目前記錄到的個數+1，也就是下一個個數</span><br><span class="line">    pos = READ_ONCE(area[0]) + 1;</span><br><span class="line">    // 如果大於 buffer size，就不處理</span><br><span class="line">    if (likely(pos &lt; t-&gt;kcov_size)) &#123;</span><br><span class="line">        // 更新個數</span><br><span class="line">        WRITE_ONCE(area[0], pos);</span><br><span class="line">        barrier();</span><br><span class="line">        // 紀錄起來</span><br><span class="line">        area[pos] = ip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>syzkaller 需要以下执行环境：</p>
<ul>
<li>Go compiler &amp; C compiler</li>
<li>Linux kernel</li>
<li>syzkaller repo</li>
<li>一台实体&#x2F;虚拟机</li>
</ul>
<h4 id="General-packages-amp-QEMU"><a href="#General-packages-amp-QEMU" class="headerlink" title="General packages &amp; QEMU"></a>General packages &amp; QEMU</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line"># 安裝一些使用到的 package</span><br><span class="line">sudo apt install make flex bison libncurses-dev libelf-dev libssl-dev</span><br><span class="line"># 安裝 qemu</span><br><span class="line">sudo apt install qemu-system-x86</span><br></pre></td></tr></table></figure>

<h4 id="GO-dependencies-amp-C-compiler"><a href="#GO-dependencies-amp-C-compiler" class="headerlink" title="GO dependencies &amp; C compiler"></a>GO dependencies &amp; C compiler</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Golang</span><br><span class="line">wget https://dl.google.com/go/go1.17.6.linux-amd64.tar.gz</span><br><span class="line">tar -xf go1.17.6.linux-amd64.tar.gz</span><br><span class="line">export GOROOT=`pwd`/go</span><br><span class="line">export PATH=$GOROOT/bin:$PATH</span><br><span class="line"></span><br><span class="line"># C</span><br><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure>

<h4 id="syzkaller-repo"><a href="#syzkaller-repo" class="headerlink" title="syzkaller repo"></a>syzkaller repo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/google/syzkaller</span><br><span class="line">cd syzkaller</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>产生的执行档会存放在目录syzkaller&#x2F;bin&#x2F; 当中</li>
<li>如果需要跨OS 或是指令集编译，需要额外定义<code>TARGETOS</code>、<code>TARGETVMARCH</code>或<code>TARGETARCH</code>环境变数</li>
</ul>
<h4 id="Linux-kernel"><a href="#Linux-kernel" class="headerlink" title="Linux kernel"></a>Linux kernel</h4><p>以kernel 版本5.14 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git clone --branch v5.14 git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git $KERNEL</span><br><span class="line"></span><br><span class="line"># 產生預設 config</span><br><span class="line">cd $KERNEL</span><br><span class="line">make defconfig</span><br><span class="line">make kvm_guest.config</span><br><span class="line">make olddefconfig</span><br><span class="line"></span><br><span class="line"># 修改 config，設定指定的 feature</span><br><span class="line"># 參考下方</span><br><span class="line">vim .config</span><br><span class="line"></span><br><span class="line"># 更新 config</span><br><span class="line">make olddefconfig</span><br><span class="line"></span><br><span class="line">make -j`nproc`</span><br></pre></td></tr></table></figure>

<p>syzkaller 所需要的feautre，主要是打开<code>KCOV</code>搜集kernel coverage，以及<code>KASAN</code>来侦测记忆体错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KCOV=y</span><br><span class="line">CONFIG_DEBUG_INFO=y</span><br><span class="line">CONFIG_KASAN=y</span><br><span class="line">CONFIG_KASAN_INLINE=y</span><br><span class="line"></span><br><span class="line">CONFIG_CONFIGFS_FS=y</span><br><span class="line">CONFIG_SECURITYFS=y</span><br></pre></td></tr></table></figure>

<h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p>建立一个debian stretch linux image，作为VM 的档案系统：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install debootstrap</span><br><span class="line"></span><br><span class="line">export IMAGE=&quot;/path/to/image&quot;</span><br><span class="line">mkdir $IMAGE</span><br><span class="line">cd $IMAGE/</span><br><span class="line">wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh</span><br><span class="line">chmod +x create-image.sh</span><br><span class="line">./create-image.sh</span><br></pre></td></tr></table></figure>

<h4 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h4><p>当以上的环境设置好后，就可以开始写syzkaller 的设定档，以下为官方范例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;target&quot;: &quot;linux/amd64&quot;,</span><br><span class="line">	&quot;http&quot;: &quot;127.0.0.1:56741&quot;,</span><br><span class="line">	&quot;workdir&quot;: &quot;$GOPATH/src/github.com/google/syzkaller/workdir&quot;,</span><br><span class="line">	&quot;kernel_obj&quot;: &quot;$KERNEL&quot;,</span><br><span class="line">	&quot;image&quot;: &quot;$IMAGE/stretch.img&quot;,</span><br><span class="line">	&quot;sshkey&quot;: &quot;$IMAGE/stretch.id_rsa&quot;,</span><br><span class="line">	&quot;syzkaller&quot;: &quot;$GOPATH/src/github.com/google/syzkaller&quot;,</span><br><span class="line">	&quot;procs&quot;: 8,</span><br><span class="line">	&quot;type&quot;: &quot;qemu&quot;,</span><br><span class="line">	&quot;vm&quot;: &#123;</span><br><span class="line">		&quot;count&quot;: 4,</span><br><span class="line">		&quot;kernel&quot;: &quot;$KERNEL/arch/x86/boot/bzImage&quot;,</span><br><span class="line">		&quot;cpu&quot;: 2,</span><br><span class="line">		&quot;mem&quot;: 2048</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>http</strong> - 使用者介面开在local 的56741 port</li>
<li><strong>image</strong> - 先前产生的image 位置</li>
<li><strong>syzkaller</strong> - syzkaller 专案的根目录，这边会因为安装syzkaller 的方式不同而有所不同</li>
</ul>
<p>再来的就是一些VM 设定，像是VM 是使用QEMU 运行、开启四台VM、每台的硬体资源与kernel image 路径等等。</p>
<h4 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h4><p>假设上个步骤写的config 名称为my.cfg，在此直接执行下列命令来运行整个syzkaller：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-manager -config=my.cfg</span><br></pre></td></tr></table></figure>

<p>执行后存取使用者介面<a target="_blank" rel="noopener" href="http://localhost:56741/">http://localhost:56741</a> (default)，会看到下图，代表执行成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281115839.png" alt="img"></p>
<p>今天对syzkaller 做简单的介绍，并且将执行环境建立起来，让读者可以感受一下syzkaller 跑起来的感觉。明天会介绍syzkaller 用来定义syscall 的语言<strong>syzlang</strong>，并一探究竟syz-manager 的实作方式。</p>
<h1 id="Day-27-OS-fuzzer-syzkaller-syzlang-amp-syz-manager"><a href="#Day-27-OS-fuzzer-syzkaller-syzlang-amp-syz-manager" class="headerlink" title="[Day 27] OS fuzzer - syzkaller - syzlang &amp; syz-manager"></a>[Day 27] OS fuzzer - syzkaller - syzlang &amp; syz-manager</h1><p>今天会简单介绍syzlang 的格式与撰写方法，并透过原始码来了解syz-manager 如何初始化执行环境与管理系统。</p>
<h3 id="syzlang"><a href="#syzlang" class="headerlink" title="syzlang"></a>syzlang</h3><p>syzkaller 自定义了一种语言syzlang 来描述syscall 的格式，像是syscall number、参数、回传型态等等，<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md">官方文件</a>已经说明的很详细，在这边就转成中文懒人包。</p>
<p>首先，直接拿现成的档案sys&#x2F;linux&#x2F;sys.txt 来参考，在档案的开头有一些kernel header file，这只是表示里面使用到的一些const 或是define 的值是来自哪些档案，而实际上syzkaller在解析完kernel header file 后会存到档案sys.txt.const，可以随便加上<code>include &lt;hello/world&gt;</code>并编译来观察，实际上编译后不会坏掉，因为syzlang parser 根本不看这个部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include &lt;linux/socket.h&gt;</span><br><span class="line">include &lt;linux/ptrace.h&gt;</span><br><span class="line">include &lt;linux/resource.h&gt;</span><br><span class="line">include &lt;linux/stat.h&gt;</span><br><span class="line">...</span><br><span class="line">include &lt;hello/world&gt;</span><br></pre></td></tr></table></figure>

<p>而解析header file 所产生档案sys.txt.const 为下，就是一些macro 展开的值或是const value：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADDR_COMPAT_LAYOUT = 2097152</span><br><span class="line">ADDR_LIMIT_32BIT = 8388608</span><br><span class="line">ADDR_LIMIT_3GB = 134217728</span><br><span class="line">ADDR_NO_RANDOMIZE = 262144</span><br><span class="line">ADJ_ESTERROR = 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>再来则是一些type define 像是<code>alignptr</code>、<code>align32</code>与<code>align64</code>，接收另一个type<code>T</code>并自动alignment 到特定bytes：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type alignptr[T] &#123;</span><br><span class="line">	v	T</span><br><span class="line">&#125; [align[PTR_SIZE]]</span><br><span class="line"></span><br><span class="line">type align32[T] &#123;</span><br><span class="line">	v	T</span><br><span class="line">&#125; [align[4]]</span><br><span class="line"></span><br><span class="line">type align64[T] &#123;</span><br><span class="line">	v	T</span><br><span class="line">&#125; [align[8]]</span><br></pre></td></tr></table></figure>

<p>Type define 的语法类似于C 的<code>typedef</code>，而<code>[0:65]</code>代表只会产生0~65 此型态的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type signalno int32[0:65]</span><br><span class="line">type signalnoptr intptr[0:65]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>再来是定义syscall format，下列包含<code>open()</code>与<code>openat()</code>与一些结构、定值。<code>$dir</code>则是代表特定的<code>open()</code>格式的名字为<code>dir</code>，<code>sock_fprog</code>定义新的结构，<code>open_flags</code>则是定义value set。参数的话下方会以<code>open()</code>做介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">open(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode]) fd</span><br><span class="line">open$dir(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode]) fd_dir</span><br><span class="line"></span><br><span class="line">openat$dir(...) fd_dir</span><br><span class="line">openat(...) fd</span><br><span class="line"></span><br><span class="line">sock_fprog &#123;</span><br><span class="line">	len	len[filter, int16]</span><br><span class="line">	filter	ptr[in, array[sock_filter]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>file</code>、<code>flags</code>与<code>mode</code>都是参数的名字，<code>fd</code>则是回传值的名称</p>
</li>
<li><p><code>in</code>与<code>out</code>用来定义资源顺序，<code>in</code>代表写资料进去，<code>out</code>代表输出的结果</p>
</li>
<li><p>&#96;&#96;&#96;<br>ptr</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">、</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>flags</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  则是参数型态，虽然self-explanatory，不过细节可以参考</span><br><span class="line"></span><br><span class="line">  文件</span><br><span class="line"></span><br><span class="line">  说明</span><br><span class="line"></span><br><span class="line">  - `ptr`- 指向object ( `filename`) 的指标，可以额外给一些option 定义指标属性</span><br><span class="line">  - `flags`- 一些数值的集合，以此为例就是`open_flags`，mutate 时就会从中选一或多个作为`flags`参数</span><br><span class="line"></span><br><span class="line">- `filename`为`string`的特例，能在执行时产生合法的档案名称</span><br><span class="line"></span><br><span class="line">在sys.txt.const 下方的位置定义了各个syscall 在不同指令集的number：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>__NR_acct &#x3D; 51, amd64:163, arm64:riscv64:89, mips64le:5158<br>__NR_alarm &#x3D; 27, amd64:37, arm:arm64:riscv64:???, mips64le:5037<br>__NR_brk &#x3D; 45, amd64:12, arm64:riscv64:214, mips64le:5012<br>…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">除了sys.txt 之外，sys/linux/ 底下也有许多*.txt 档，sys.txt 定义了比较多通用的syscall 格式，而其他.txt 档则是定义与subsystem 沟通的syscall，举例来说bpf. txt 定义与linux ebpf system 互动的syscall。</span><br><span class="line"></span><br><span class="line">而当修改完这些档案后，可以执行下列命令做更新：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>bin&#x2F;syz-sysgen</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实际上syz-sysgen 就是syzlang 的parser，在读完这些&quot;source code&quot; 之后，就会产生&quot;output file&quot;，而&quot;output file&quot; 即是sys/linux/gen/amd64.go，不同指令集与作业系统的格式为`sys/$OS/gen/$INSN.go`。下列为amd64.go 的部分内容，能清楚知道syzlang parser，也就是syz-sysgen 做了什么事情：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>package gen</p>
</li>
</ul>
<p>import . “github.com&#x2F;google&#x2F;syzkaller&#x2F;prog”<br>import . “github.com&#x2F;google&#x2F;syzkaller&#x2F;sys&#x2F;linux”</p>
<p>&#x2F;&#x2F; RegisterTarget() 會向 fuzzer 註冊 linux amd64 的 syscall 格式、規則以及常數<br>func init() {<br>    RegisterTarget(&amp;Target{OS: “linux”, Arch: “amd64”, Revision: revision_amd64, PtrSize: 8, PageSize: 4096, NumPages: 4096, DataOffset: 536870912, LittleEndian: true, ExecutorUsesShmem: true, Syscalls: syscalls_amd64, Resources: resources_amd64, Consts: consts_amd64}, types_amd64, InitTarget)<br>}</p>
<p>&#x2F;&#x2F; resource，像是 value 範圍<br>var resources_amd64 &#x3D; []*ResourceDesc{<br>    {Name:”ANYRES16”,Kind:[]string{“ANYRES16”},Values:[]uint64{18446744073709551615,0}},<br>    {Name:”ANYRES32”,Kind:[]string{“ANYRES32”},Values:[]uint64{18446744073709551615,0}},<br>    {Name:”ANYRES64”,Kind:[]string{“ANYRES64”},Values:[]uint64{18446744073709551615,0}},<br>    {Name:”ANYRES8”,Kind:[]string{“ANYRES8”},Values:[]uint64{18446744073709551615,0}},<br>    {Name:”IMG_DEV_VIRTADDR”,Kind:[]string{“IMG_DEV_VIRTADDR”},Values:[]uint64{0}},<br>    …<br>}</p>
<p>&#x2F;&#x2F; syscall，包含 number 以及傳入的參數<br>var syscalls_amd64 &#x3D; []*Syscall{<br>    {NR:43,Name:”accept”,CallName:”accept”,Args:[]Field{<br>        {Name:”fd”,Type:Ref(11387)},<br>        {Name:”peer”,Type:Ref(10173)},<br>        {Name:”peerlen”,Type:Ref(10453)},<br>    },Ret:Ref(11387)},<br>    {NR:43,Name:”accept$alg”,CallName:”accept”,Args:[]Field{<br>        {Name:”fd”,Type:Ref(11390)},<br>        {Name:”peer”,Type:Ref(5022)},<br>        {Name:”peerlen”,Type:Ref(5022)},<br>    },Ret:Ref(11391)},<br>    …<br>}</p>
<p>&#x2F;&#x2F; consts，也就是常數<br>var consts_amd64 &#x3D; []ConstValue{<br>    {“ABS_CNT”,64},<br>    {“ABS_MAX”,63},<br>    {“ACL_EXECUTE”,1},<br>    …<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">透过function`RegisterTarget()`即可跟fuzzer 注册使用者定义的syscall 格式。</span><br><span class="line"></span><br><span class="line">### syz-manager</span><br><span class="line"></span><br><span class="line">syz-manager 也是整个syzkaller 系统的进入点，以下为程式码syz-manager/manager.go：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>func RunManager(cfg *mgrconfig.Config) {<br>    &#x2F;&#x2F; 建立 VM<br>    vmPool, err &#x3D; vm.Create(cfg, *flagDebug)<br>    &#x2F;&#x2F; … 目錄相關的處理</p>
<pre><code>// 初始化各 sub component，名字就 self-explanatory
reporter, err := report.NewReporter(cfg)
mgr := &amp;Manager&#123;...&#125;
mgr.preloadCorpus()
mgr.initStats()
mgr.initHTTP()
mgr.collectUsedFiles()
mgr.serv, err = startRPCServer(mgr)
mgr.dash, err = dashapi.New(cfg.DashboardClient, cfg.DashboardAddr, cfg.DashboardKey)

// 每 10 秒在 terminal 印出執行狀況
go func() &#123;
    for lastTime := time.Now(); ; &#123;
        time.Sleep(10 * time.Second)
        // ... 一些統計資料
        corpusCover := mgr.stats.corpusCover.get()
        log.Logf(0, &quot;VMs %v, executed %v, cover %v, ...&quot;, numFuzzing, executed, corpusCover, ...)
    &#125;
&#125;()
// 定期更新 dashboard 的 thread
go mgr.dashboardReporter()
// 喚起 VM
mgr.vmLoop()
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Function`vmLoop()`不断等待VM 的执行结果并执行对应的处理：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>func (mgr <em>Manager) vmLoop() {<br>    &#x2F;&#x2F; 計算最多可以有幾個 VM instance 復現 (reproduce) 漏洞發生<br>    instancesPerRepro :&#x3D; 4 &#x2F;&#x2F; 多少 VM 來 repro<br>    vmCount :&#x3D; mgr.vmPool.Count() &#x2F;&#x2F; total<br>    &#x2F;&#x2F; 每隔 10 秒建立一個 VM instances<br>    instances :&#x3D; SequentialResourcePool(vmCount, 10</em>time.Second*mgr.cfg.Timeouts.Scale)</p>
<pre><code>for shutdown != nil &#123;
    // 將要被 repro 的 crash 加到 queue 當中
    for crash := range pendingRepro &#123;
        reproducing[crash.Title] = true
        reproQueue = append(reproQueue, crash)
    &#125;

    // 取出最後一個 repro 並 assign 給 VM
    for canRepro() &#123;
        vmIndexes := instances.Take(instancesPerRepro)
        crash := reproQueue[ len(reproQueue) - 1 ]
        go func() &#123;
            reproDone &lt;- mgr.runRepro(crash, vmIndexes, instances.Put)
        &#125;()
    &#125;
    // 運行沒有事情的 VM instance
    for !canRepro() &#123;
        idx := instances.TakeOne()
        go func() &#123;
            crash, err := mgr.runInstance(*idx)
            runDone &lt;- &amp;RunResult&#123;*idx, crash, err&#125;
        &#125;()
    &#125;

    // 處理 VM 的執行狀況
    wait:
    select &#123;
        case &lt;-instances.Freed: // VM 被釋放
        case stopRequest &lt;- true: // VM 停止執行
        case res := &lt;-runDone: // VM 執行結束
        case res := &lt;-reproDone: // VM 復現 crash
        case &lt;-shutdown: // syzkaller system shutdown
        ...
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">For loop 的逻辑非常简单，需要注意的是VM instance 呼叫的function 会因为使用的hypervisor 不同而不同，举例来讲档案vm/qemu/qemu.go 就定义了以QEMU 为hypervisor 时，呼叫`inst.boot()`或是`inst.Copy()`底部的实作方法。再来往前看当初建立VM pool 时`vm.create()`是怎么处理的：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>func Create(cfg *mgrconfig.Config, debug bool) (*Pool, error) {<br>    typ, ok :&#x3D; vmimpl.Types[cfg.Type]<br>    &#x2F;&#x2F; cfg 為 config，即為使用者定義的資料，像是目標 OS 與指令集<br>    env :&#x3D; &amp;vmimpl.Env{<br>        Name:     cfg.Name,<br>        OS:       cfg.TargetOS,<br>        Arch:     cfg.TargetVMArch,<br>        Workdir:  cfg.Workdir,<br>        Image:    cfg.Image,<br>        SSHKey:   cfg.SSHKey,<br>        SSHUser:  cfg.SSHUser,<br>        Timeouts: cfg.Timeouts,<br>        Debug:    debug,<br>        Config:   cfg.VM,<br>    }<br>    impl, err :&#x3D; typ.Ctor(env)<br>    return &amp;Pool{<br>        impl:     impl,<br>        workdir:  env.Workdir,<br>        template: cfg.WorkdirTemplate,<br>        timeouts: cfg.Timeouts,<br>    }, nil<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">到此分析整个系统入口syz-manager 做的事情，虽然范例程式码删除了细节处理的部分，但是整个概念非常清楚。此外也介绍了syzlang 的语法与输出结果，但虽然可以知道`RegisterTarget()`向fuzzer 注册一个linux amd target，但fuzzer 会怎么利用他，又怎么以此来产生syscall sequence，就留着明天介绍。</span><br><span class="line"></span><br><span class="line"># [Day 28] OS fuzzer - syzkaller - syz-fuzzer &amp; syz-executor</span><br><span class="line"></span><br><span class="line">昨天介绍syz-manager 建立了VM pool 来复现漏洞或是fuzzing，但实际上是用RPC (remote procedure call) 呼叫syz-fuzzer 做fuzzing，因此fuzzing 逻辑与处理都是由syz-fuzzer 实作。接下来就会介绍syz-fuzzer 怎么实作其他OS fuzzer 难以模仿的mutation 机制，也就是产生出&quot;有意义的syscall sequence&quot;，并且这些syscall sequence 又是怎么传给syz-executor 执行。</span><br><span class="line"></span><br><span class="line">### syz-fuzzer</span><br><span class="line"></span><br><span class="line">syz-fuzzer 的原始码档案为syz-fuzzer/fuzzer.go，内容如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>func main() {<br>    &#x2F;&#x2F; 這裡指的 target 就是 syz-manager 透過 RegisterTarget() 的<br>    target, err :&#x3D; prog.GetTarget(*flagOS, *flagArch)<br>    &#x2F;&#x2F; 儲存 syz-manager 要檢查的成員<br>    checkArgs :&#x3D; &amp;checkArgs{<br>        target:         target,<br>        …<br>    }<br>    &#x2F;&#x2F; 與 manager 建立連線<br>    manager, err :&#x3D; rpctype.NewRPCClient(*flagManager, timeouts.Scale)<br>    &#x2F;&#x2F; a 與 r 分別為呼叫 RPC 時用來傳遞參數與接收結果的變數<br>    a :&#x3D; &amp;rpctype.ConnectArgs{…}<br>    r :&#x3D; &amp;rpctype.ConnectRes{}<br>    &#x2F;&#x2F; 呼叫 RPC “Manager.Connect”，與 manager 建立連線<br>    manager.Call(“Manager.Connect”, a, r)<br>    checkArgs.gitRevision &#x3D; r.GitRevision<br>    &#x2F;&#x2F; … 儲存到結構當中<br>    r.CheckResult, err &#x3D; checkMachine(checkArgs)<br>    &#x2F;&#x2F; 呼叫 RPF “Manager.Check”，載入 corpus<br>    manager.Call(“Manager.Check”, r.CheckResult, nil)<br>    fuzzer :&#x3D; &amp;Fuzzer{<br>        name:                     *flagName,<br>        …<br>    }</p>
<pre><code>for needCandidates, more := true, true; more; needCandidates = false &#123;
    // 等待 input candidate
    more = fuzzer.poll(needCandidates, nil)
&#125;
// 紀錄哪些 syscall 才能執行
calls := make(map[*prog.Syscall]bool)
for _, id := range r.CheckResult.EnabledCalls[sandbox] &#123;
    calls[target.Syscalls[id]] = true
&#125;
// choice table 記錄了被允許的 syscall，
// 在後續 mutate 時會略過這些 syscall
fuzzer.choiceTable = target.BuildChoiceTable(fuzzer.corpus, calls)
// 執行數個 syz-executor 開始 fuzzing
for pid := 0; pid &lt; *flagProcs; pid++ &#123;
    proc, err := newProc(fuzzer, pid)
    fuzzer.procs = append(fuzzer.procs, proc)
    go proc.loop()
&#125;
fuzzer.pollLoop()
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Fuzzer 的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  poll()<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实际上是向manager 发送RPC 来呼叫</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  Manager.Poll<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ，取得input candidate</span><br><span class="line"></span><br><span class="line">  - Candidate 的定义为从corpus 取出且没做过&quot;triaged&quot; 的input，triaged 会在后续介绍，可以先视candidate 为初始input</span><br><span class="line">  - 透过RPC 呼叫的function 会定义在syz-manager/rpc.go，在呼叫syz-manager 的function 来处理</span><br><span class="line"></span><br><span class="line">而原本的thread 会呼叫`fuzzer.pollLoop()`，更新一些执行资讯而已，不是很重要，因此接下来会看`proc.loop()`做了哪些处理，原始码位于syz-fuzzer/proc.go：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>func (proc *Proc) loop() {<br>    for i :&#x3D; 0; ; i++ {<br>        item :&#x3D; proc.fuzzer.workQueue.dequeue()<br>        &#x2F;&#x2F; 執行哪個 handler 取決於 workqueue 內存放的 item 是什麼型態，<br>        &#x2F;&#x2F; 這些操作都是針對當前的 program<br>        if item !&#x3D; nil {<br>            switch item :&#x3D; item.(type) {<br>            case *WorkTriage:<br>                proc.triageInput(item)<br>            case *WorkCandidate:<br>                proc.execute(proc.execOpts, item.p, item.flags, StatCandidate)<br>            case *WorkSmash:<br>                proc.smashInput(item)<br>            }<br>            continue<br>        }</p>
<pre><code>    ct := proc.fuzzer.choiceTable
    fuzzerSnapshot := proc.fuzzer.snapshot()
    // 沒有其他 input，或是到達一定週期時滿足 if-condition
    if len(fuzzerSnapshot.corpus) == 0 || i%generatePeriod == 0 &#123;
        // 建立一個新的 program，可以看到傳入 choice table 給 generator
        p := proc.fuzzer.target.Generate(proc.rnd, prog.RecommendedCalls, ct)
        proc.executeAndCollide(proc.execOpts, p, ProgNormal, StatGenerate)
    &#125; else &#123;
        // 對現有的 program 做 mutate，也傳了 choice table 給 mutator
        p := fuzzerSnapshot.chooseProgram(proc.rnd).Clone()
        p.Mutate(proc.rnd, prog.RecommendedCalls, ct, fuzzerSnapshot.corpus)
        proc.executeAndCollide(proc.execOpts, p, ProgNormal, StatFuzz)
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在此介绍syzkaller 与program 相关的处理：</span><br><span class="line"></span><br><span class="line">- **Generation** - 产生syscall sequences 与参数</span><br><span class="line"></span><br><span class="line">- **Mutation** - 对program 的参数或是syscall sequence 做随机的变化，像是改变资料，或是新增新的syscall</span><br><span class="line"></span><br><span class="line">- Triage</span><br><span class="line"></span><br><span class="line">   \- 在program 产生新的coverage 时执行，可以再拆成两个部分：</span><br><span class="line"></span><br><span class="line">  - **Verification** - 认证coverage 是可以被重现的</span><br><span class="line">  - **Minimization** - 保持coverage 的情况下移除多余的syscall，并且缩短必要的参数</span><br><span class="line"></span><br><span class="line">- **Smash** - 对新的seed 做100 次的mutation</span><br><span class="line"></span><br><span class="line">虽然执行很多操作，不过这里不会一一介绍，只会以执行syz-executor 的`proc.execute()`与做mutation 的`p.Mutate()`为目标。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">首先先看`proc.execute()`，基本上是一层层的wrapper function，因此已经大量删除了比较不重要的程式码：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>func (proc *Proc) execute(execOpts *ipc.ExecOpts, p *prog.Prog, …) … {<br>    info :&#x3D; proc.executeRaw(execOpts, p, …)<br>}</p>
<p>func (proc *Proc) executeRaw(opts *ipc.ExecOpts, p *prog.Prog…) … {<br>    &#x2F;&#x2F; 檢查 disabled syscall<br>    proc.fuzzer.checkDisabledCalls(p)<br>    &#x2F;&#x2F; 載入 program<br>    proc.logProgram(opts, p)<br>    &#x2F;&#x2F; 這邊會執行 syz-executor<br>    output, info, hanged, err :&#x3D; proc.env.Exec(opts, p)<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`proc.env.Exec()`会执行传入的program `p`，并回传执行资讯给syz-fuzzer。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">`p.Mutate()`一共会执行五种mutation 操作，分别为：</span><br><span class="line"></span><br><span class="line">- **squashAny** - 替换有结构性的参数，换成是随机binary blob (binary large object)</span><br><span class="line">- **splice** - 拼接参数</span><br><span class="line">- **intertCall** - 在随机位置插入一个syscall</span><br><span class="line">- **mutateArg** - 对随机一个syscall 参数做mutate</span><br><span class="line">- **removeCall** - 随机移除一个syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>func (p *Prog) Mutate(rs rand.Source, ncalls int, ct *ChoiceTable, corpus []*Prog) {<br>    &#x2F;&#x2F; …<br>    for stop, ok :&#x3D; false, false; !stop; stop &#x3D; ok &amp;&amp; len(p.Calls) !&#x3D; 0 &amp;&amp; r.oneOf(3) {<br>        switch {<br>        case r.oneOf(5):<br>            ok &#x3D; ctx.squashAny()<br>        case r.nOutOf(1, 100):<br>            ok &#x3D; ctx.splice()<br>        case r.nOutOf(20, 31):<br>            ok &#x3D; ctx.insertCall()<br>        case r.nOutOf(10, 11):<br>            ok &#x3D; ctx.mutateArg()<br>        default:<br>            ok &#x3D; ctx.removeCall()<br>        }<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">拿比较简单的操作`insertCall()`为例，在program 中随机位置插入一个syscall 的程式码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>func (ctx *mutator) insertCall() bool {<br>    p, r :&#x3D; ctx.p, ctx.r<br>    &#x2F;&#x2F; 產生隨機位址<br>    idx :&#x3D; r.biasedRand(len(p.Calls)+1, 5)<br>    &#x2F;&#x2F; …<br>    &#x2F;&#x2F; 產生 syscall<br>    calls :&#x3D; r.generateCall(s, p, idx)<br>    &#x2F;&#x2F; 插入 syscall<br>    p.insertBefore(c, calls)<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">想得简单一点，就是在一个list 当中随机选个位置，并将element 塞到这个位置前面，list 就是整个syscall sequence，而element 就是新产生的syscall。</span><br><span class="line"></span><br><span class="line">### syz-executor</span><br><span class="line"></span><br><span class="line">Syzkaller 用一种特别的资料结构来储存program，并且各个component 之间都用此结构来传递program，这种结构能将program 序列化成类似C function call 的形式：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>r0 &#x3D; open(&amp;(0x7f0000000000)&#x3D;”.&#x2F;file0”, 0x3, 0x9)<br>read(r0, &amp;(0x7f0000000000), 42)<br>close(r0)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">最后program 传给syz-executor 后，syz-executor 内部会将program parse 成syscall 的形式来呼叫。</span><br><span class="line"></span><br><span class="line">syz-executor 的原始码路径为executor/executor.cc，是用C++ 来撰写的程式，但实际上大多还是写C，只是一些algorithm 的处理用C++ library 比较好处理。除了执行syscall 之外，syz-executor 本身还支援多个功能，不过这次介绍以`exec`，也就是执行syscall sequence 为主，并且不考虑其他define，原始码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>int main(int argc, char** argv)<br>{<br>    &#x2F;&#x2F; 功能用第一個參數判斷 (argv[1])<br>    if (argc &#x3D;&#x3D; 2 &amp;&amp; strcmp(argv[1], “version”) &#x3D;&#x3D; 0) {…}<br>    &#x2F;&#x2F; 下方為 “exec” 邏輯</p>
<pre><code>// 類似於 AFL 的 control pipe
setup_control_pipes();
// 接收 exeuctable
receive_execute();
if (flag_coverage) &#123;
    // 每個 thread coverage 的初始化，包含設置 KCOV
    // ...
    cover_open(&amp;extra_cov, true);
    // mmap kcov fd
    cover_mmap(&amp;extra_cov);
&#125;
// 
status = do_sandbox_none();
// 回傳 execute_reply 結構
reply_execute(status);
return status;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接收program 会先读一些input 资讯，像是长度、magic number，而后才会接收program 资料：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>void receive_execute()<br>{<br>    execute_req&amp; req &#x3D; last_execute_req;<br>    &#x2F;&#x2F; 接收 execute request 並檢查是否合法<br>    if (read(kInPipeFd, &amp;req, sizeof(req)) !&#x3D; (ssize_t)sizeof(req))<br>        fail(“control pipe read failed”);<br>    if (req.magic !&#x3D; kInMagic)<br>        failmsg(“bad execute request magic”, “magic&#x3D;0x%llx”, req.magic);<br>    if (req.prog_size &gt; kMaxInput)<br>        failmsg(“bad execute prog size”, “size&#x3D;0x%llx”, req.prog_size);<br>    &#x2F;&#x2F; 處理 request flags<br>    parse_env_flags(req.env_flags);<br>    &#x2F;&#x2F; 將 flag value 存到變數當中<br>    flag_collect_signal &#x3D; req.exec_flags &amp; (1 &lt;&lt; 0);<br>    &#x2F;&#x2F; …</p>
<pre><code>// 接收 program 直到給定大小 (req.prog_size)
uint64 pos = 0;
for (;;) &#123;
    ssize_t rv = read(kInPipeFd, input_data + pos, sizeof(input_data) - pos);
    pos += rv;
    if (rv == 0 || pos &gt;= req.prog_size)
        break;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">呼叫执行program 的wrapper function `do_sandbox_none()`：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static int do_sandbox_none(void)<br>{<br>    unshare(CLONE_NEWPID);<br>    int pid &#x3D; fork();<br>    &#x2F;&#x2F; parent 進 loop 等待 child process 得離開<br>    if (pid !&#x3D; 0)<br>        return wait_for_loop(pid);</p>
<pre><code>// setup fuse
setup_common();
// 與 parent 區隔執行環境
sandbox_common();
unshare(CLONE_NEWNET);
// 降低程式的部分權限，避免有 hang 住的情況
drop_caps();
// 初始化網路設備 (optional)
// ...
initialize_netdevices_init();

loop();
doexit(1);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">根据不同的模式，`loop()`有不同的define，以下为正常情况：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static void loop(void)<br>{<br>    execute_one();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`execute_one()`会解析整个program 并执行，其中也包含开启KCOV、参数设置等等处理：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>void execute_one()<br>{<br>    &#x2F;&#x2F; input_data 即是在 receive_execute() 所接收的 program<br>    uint64* input_pos &#x3D; (uint64*)input_data;</p>
<pre><code>// 允許 KCOV 追蹤 coverage，不過執行前還是會重置
cover_enable(&amp;threads[0].cov, flag_comparisons, false);

for (;;) &#123;
    // call_num 可以想成是 bytecode instruction
    uint64 call_num = read_input(&amp;input_pos);
    if (call_num == instr_eof) break; // 結束
    // 複製參數
    if (call_num == instr_copyin) &#123;
        char* addr = (char*)read_input(&amp;input_pos);
        uint64 typ = read_input(&amp;input_pos);
        switch (typ) &#123;
        // 參數的種類
        case arg_const: ...
        case arg_result: ...
        case arg_data: ...
        case arg_csum: ... // checksum handle
            uint64 size = read_input(&amp;input_pos);
            uint64 csum_kind = read_input(&amp;input_pos);
            switch (csum_kind) &#123;
            case arg_csum_inet: ...
            &#125;
        &#125;
        continue;
    &#125;
    if (call_num == instr_copyout) &#123;...&#125;
    if (call_num == instr_setprops) &#123;...&#125;
    
    // 接下來就是 syscall 的呼叫
    const call_t* call = &amp;syscalls[call_num];
    // 檢查 syscall 是否能執行
    if (call-&gt;attrs.disabled) error();
    // 參數數量
    uint64 num_args = read_input(&amp;input_pos);
    uint64 args[kMaxArgs] = &#123;&#125;;
    // 讀參數
    for (uint64 i = 0; i &lt; num_args; i++)
        args[i] = read_arg(&amp;input_pos);
    // 將剩下參數初始為 0
    for (uint64 i = num_args; i &lt; kMaxArgs; i++)
        args[i] = 0;
    
    // 分配給 worker thread，但先不執行
    thread_t* th = schedule_call(call_index++, call_num, copyout_index,
                     num_args, args, input_pos, call_props);
    // 執行 syscall
    execute_call(th);
    // 處理並傳送執行結果
    handle_completion(th);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">终于来到最后一个function，`execute_call()`首先重置KCOV 确保干净，接着执行syscall，最后储存该次执行产生的coverage 个数，等着待会分析：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>void execute_call(thread_t* th)<br>{<br>    const call_t* call &#x3D; &amp;syscalls[th-&gt;call_num];<br>    &#x2F;&#x2F; 重置 KCOV<br>    cover_reset(&amp;th-&gt;cov);<br>    &#x2F;&#x2F; 執行 syscall<br>    NONFAILING(th-&gt;res &#x3D; execute_syscall(call, th-&gt;args));<br>    &#x2F;&#x2F; 蒐集該次執行的 coverage<br>    if (flag_coverage)<br>        cover_collect(&amp;th-&gt;cov);<br>}</p>
<pre><code>
到这边，已经将syzkaller 的整个架构与大概的执行流程说明一次，并且为了了解细节，对于各个component 也对原始码做完善的分析。

## OS fuzzer 总结

OS fuzzer 是一个很值得研究的主题，虽然syzkaller 很万用，但在一些kernel subsystem 的处理上可能就有满大的优化空间，像是filesystem 的fuzzing，最理想的情况是能够将机制整合到syzkaller当中，这样也能让syzbot 持续的跑并自动回报。

不论是userspace fuzzer 或是kernel fuzzer，现在对读者来说应该很熟悉了，接下来两天会介绍两个截然不同的hypervisor fuzzer，分别为Nyx 与Hypercube，只需要再两天，就已经可以说把目前fuzzing 领域所使用的大部分技巧、优化与实作方式都学习的差不多了。

# [Day 29] Hypervisor fuzzer - Nyx

相较于OS fuzzer 来说，hypervisor fuzzer 的可能又比较冷门一点，除了需要hypervisor 机制的背景知识，架构fuzzing 的环境可能也相较复杂。不过hypervisor 也是被广为使用在现实生活，像是大多数的云服务都是提供虚拟机给使用者使用，背后会由hypervisor 处理一些高权限请求，同时也出现center 版的hypervisor，除了针对虚拟化技术做优化外，也提供企业更方便的管理介面。

Hypervisor 本身是做系统执行的模拟，但更多的是硬体设备的模拟处理，做的就是利用软体来模拟硬体的行为。这些模拟出来的硬体设备也被称作virtual device，而fuzzing 大多都会针对那些virtual device 的处理，像是软体实作是否与手册上所描述的硬体行为相同。此外，虚拟硬体也会纪录当前的状态，因此fuzzing 时也需要确保硬体环境是干净没被污染的，否则复现时可能会出现问题。

Hypervisor 方面较为有名的fuzzer 有两个，分别为[Nyx](https://github.com/nyx-fuzz/QEMU-Nyx)以及[Hypercube](https://github.com/RUB-SysSec/hypercube)。有趣的是，Nyx 跟Hypercube 都是由kAFL 的核心研究人员所开发，前者利用了类似于kAFL 的系统框架来实作hypervisor fuzz，后者则提出的客制化的作业系统来fuzz hypervisor。不过后者虽然想法创新，但却没有公布原始码，因此也无从得知程式码架构，也不能复现实验结果。此外，这次介绍都不会看原始码，只会根据paper 提出的机制做说明。

接下来会以[Nyx 的论文](https://www.usenix.org/system/files/sec21summer_schumilo.pdf)内容做介绍，了解kAFL 的系统框架是如何移植到hypervisor fuzzing 上，同时也会说明过程中所遇到的问题。

## Nyx

### Introduction

由于hypervisor 的种类很多，有跑在userspace 的(eg QEMU)，有跑在kernel space 的(eg KVM)，还有取代作业系统来管理VM 的(eg exsi)，所以每篇论文针对的层级也不太一样，再加上大多数的hypervisor 因为是企业产品，所以都没有原始码，所以也需要在不同层级处理这种情况。

至今为止也有一些hypervisor fuzzer 的实作，这边稍微介绍一下：

- [VDF](https://www.cs.ucr.edu/~heng/pubs/VDF_raid17.pdf) - 插桩在QEMU 当中特定virtual device 的程式码，然后模拟执行期间在用一大堆test cases 对指定virtual device，这样得到的coverage 就只限于目标
- [V-SHUTTLE](https://nesa.zju.edu.cn/download/pgn_pdf_V-SHUTTLE.pdf) - 针对QEMU 与virtualbox，会先对原始码做静态分析，对透过direct memory access (DMA) 操作的不同型态结构做纪录，并且hook DMA 的操作。在动态时会根据记录建置各自的seed pool，DMA 操作时触发hook，将seed pool 中的资料替换掉原本的

而Nyx 设计架构适用于各种层级的hypervisor，并且会对hypervisor 做snaphot，执行前会做重新载入，确保执行环境的干净。

### Design &amp; Workflow

![img](https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281116214.png)

- **NYX-Fuzzer** - 整个fuzzing engine
- **KVM-PT** - 支援nested hypercall，执行Guest L1 也就是hypervisor，而hypervisor 内部跑了一个Agent OS (L2) 负责执行payload
- **QEMU-PT** - 支援fast snapshot reload 与解析Intel-PT packet

除此之外Nyx 还在QEMU 中时做了snapshot 的机制，客制化的In-Memory Copy-On-Write 处理，实作方式为在QEMU 内用一个bitmap 记录被污染的记忆体区块，并在使用前储存整块记忆体内容，之后在执行完且要reset VM 时，只要把原本的内容复制到污染区块当中，就不需要将整个VM 初始化。

------

参考下图Nyx 执行流程，hypervisor (L1 Guest) 替代了原先kAFL 当中target kernel 的位置，而agent OS (L2 Guest) 替代了原本的loader/agent：

![img](https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281116935.png)

如果agent OS 需要送请求QEMU 或KVM，则都是直接呼叫hypercall 传送，而nested hypercall 则是让目标hypervisor 可以接收到非请求的hypercall 并做处理。下列根据上图，说明各个步骤的行为：

1. Agent OS 会分配payload buffer，并透过传给QEMU-PT
2. 准备开始fuzzing 前，agent OS 会通知QEMU-PT，而QEMU-PT 会建立snapshot 并要求Nyx fuzzer 将payload 写到buffer 当中
3. Agent OS 收到payload 后，会通知KVM-PT 开始追踪
4. 执行完payload 后，agent OS 通知KVM-PT 结束追踪
5. QEMU-PT 解析完封包后，将结果交给Nyx fuzzer 分析

### Evaluation

整体完胜VDF，毕竟是2017 年的论文，而跟hypercube 比的话，在复杂的device 中产生的coverage 胜出不少，但简单的device 会比hypercube 还要低，这主要跟hypercube 半黑箱的实作机制有关系。

而snapshot 的优化只比较了native 执行速度与QEMU 内建的snapshot 机制，结果为完胜QEMU 且接近native，但这个机制听起来能够产生不错的优化，不过是否接近native 就不得而知。

虽然Nyx 还有实作一种产生结构性payload 的演算法，但一方面是我没有很懂，一方面是要事先写spec，所以没有特别拿出来说明，但大致上就是让fuzzer 生成的payload 有特定的形式，这样就能避免产生没意义的payload。

### Conclusion

论文上写的效能一直让我保持怀疑态度，因为就算多了nested hypercall 的效能overhead，但跑的还是很快，不过这也许是因为使用的硬体设备很好的关系。其他的部分除了snapshot 的处理，大多等同于移植kAFL 框架，一些处理与相关架构都很相似，没什么特别的部分。

# [Day 30] Hypervisor fuzzer - Hypercube 与参赛心得

[Hypercube](https://www.ndss-symposium.org/wp-content/uploads/2020/02/23096-paper.pdf)用了与Nyx 截然不同的框架来对hypervisor 做fuzzing，今天就会介绍他在论文中提出的系统架构。而在文章最后，我也会分享一下参加铁人赛的心得。

## Hypercube

Hypercube 的精华在于自己写一个用来fuzzing hypervisor 的作业系统，研究员称他为Hypercube-OS ，架构如下：

![img](https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281116671.png)

- Host
  - **Minimizer** - 最小化payload
  - **Logger** - 纪录执行状态
  - **Decompiler** - 把执行的bytecode 转成C code 方便观察
- HyperCube OS
  - **Tesseract interceptor** - bytecode interpreter
  - **Simple heap management** - 简单的记忆体管理机制
  - **Scratch memory** - 给interpreter 使用，存放随机资料

执行流程非常简单，Hypercube OS 内部有一个pseudo random number generaotr (PRNG) 不断产生乱数到scratch memory，而interpreter 将这些乱数值视为bytecode，从中执行对应的操作，像是`mmio_write_16()`或是`io_xor_8()`等等需要hypervisor 硬体模拟来处理的操作，可以参考下图：

![img](https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410281117358.png)

执行过程中会纪录产生的乱数资料，当触发异常时会把这些乱数资料传回host，由minimizer 找出关键触发的部分，最后使用decompiler 转为C code 分析。

------

虽然这样的作法基本上不会考虑执行的feedback，但这样的好处就是执行效率快，对于简单的device 有非常好的效果，但是复杂的device 或是比较深的逻辑处理就没办法走到。

## 参赛心得

 因缘际会之下参加了这次的铁人赛，一开始还在想说主题要选什么，看了一下似乎过去没有什么人对模糊测试(fuzzing) 做系统性的介绍，因此想说藉由这次机会分享一下，顺便整理过去的知识。但这种主题其实满学术的，虽然实际上有在使用，不过多半是研究人员、资安公司，或者是大公司的资安部门，一般人鲜少有机会接触到，然后这东西背景知识又吃的有点重，一开始满担心没有人看的。

 在初期写文章时，我认真想过介绍专案时到底需不需要放程式码，但依照过去的经验，听不懂的东西看一下code 可能就会开窍，而且知道怎么实作的也很有趣，因此我尽量删除多余的程式码，留下最精华的部分，并基本上逐行加上注解，并且尽量将使用到的技术做完整的说明，目标让认真看或简单看的人都能获得一些知识，毕竟一些kernel feature 或是虚拟化技术，已经被许多系统使用着。

 不过写到后期，感觉开始力不从心，不是忘记程式码的意思，就是之前不熟悉，因此这系列文大概只有50% 是吃老本，后面都是一边写，一边学习、复习。而且这些实作介绍或是论文探讨，最怕的就是误会作者意思，然后还分享给其他人错误的资讯，因此我也很怕讲错知识，所以如果读者发现有问题的地方，我都很欢迎在下方留言讨论。

 最后，因为过去我有被说过类似讲话没逻辑或是没结构之类的话，因此我也不确定我在撰写这些文章时字句是否通顺，希望这系列文能清楚的分享这些技术与知识给其他人。
</code></pre>
</div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Matrwe</div><div class="author-info-description">1</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">0</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/imatrwe"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Matrwe的Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"></div></div><div class="card-widget card-archives"></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">0</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-10-28T13:25:56.985Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/footer.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 By Matrwe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>